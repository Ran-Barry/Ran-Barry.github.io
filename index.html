<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Lato:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"ran-barry.github.io",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:"disqus",storage:!0,lazyload:!1,nav:{disqus:{text:"Disqus 评论",order:-1},livere:{text:"LiveRe 评论",order:-2}}},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:-1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta property="og:type" content="website"><meta property="og:title" content="Hello"><meta property="og:url" content="http://ran-barry.github.io/index.html"><meta property="og:site_name" content="Hello"><meta property="og:locale" content="zh_CN"><meta property="article:author" content="Ran-Barry"><meta name="twitter:card" content="summary"><link rel="canonical" href="http://ran-barry.github.io/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!0,isPost:!1,lang:"zh-CN"}</script><title>Hello</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Hello</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">记录学习等</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><a href="https://github.com/Ran-Barry" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content index posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://ran-barry.github.io/2021/11/22/docker%E6%90%AD%E5%BB%BALAMP%E7%8E%AF%E5%A2%83/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Ran-Barry"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hello"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2021/11/22/docker%E6%90%AD%E5%BB%BALAMP%E7%8E%AF%E5%A2%83/" class="post-title-link" itemprop="url">docker搭建LAMP环境</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-22 17:56:36" itemprop="dateCreated datePublished" datetime="2021-11-22T17:56:36+08:00">2021-11-22</time></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>2.4k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>2 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><p>这里使用阿里云ECS服务器Ubuntu20.04版本进行搭建</p><p>首先看看有哪些lamp的使用的较多，使用docker search lamp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># docker search lamp</span><br><span class="line">NAME                                    DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">mattrayner/lamp                         A simple LAMP docker image running the prere…   285                  [OK]</span><br><span class="line">linode/lamp                             LAMP on Ubuntu 14.04.1 LTS Container            181                  </span><br><span class="line">tutum/lamp                              Out-of-the-box LAMP image (PHP+MySQL)           148                  </span><br><span class="line">fauria/lamp                             Modern, developer friendly LAMP stack. Inclu…   110                  [OK]</span><br><span class="line">greyltc/lamp                            a super secure, up-to-date and lightweight L…   103                  [OK]</span><br><span class="line">lioshi/lamp                             Docker image for LAMP under debian              14                   [OK]</span><br><span class="line">dgraziotin/lamp                                                                         11                   [OK]</span><br><span class="line">linuxconfig/lamp                        Automated build LAMP stack environment for f…   5                    [OK]</span><br><span class="line">jakubboucek/lamp-devstack-php           Prepared images for local development in LAM…   5                    </span><br><span class="line">thiagobarradas/lamp                     Use PHP (5.4, 5.5, 5.6, 7.0, 7.1, 7.2, 7.3, …   4                    </span><br><span class="line">lampson0505/ubuntu-phy                  An Ubuntu image with teamd for network inter…   3                    </span><br><span class="line">shelleyma/lampp2                        lampp from github                               3                    [OK]</span><br><span class="line">lead4good/lamp-php                      LAMP Stack PHP                                  2                    [OK]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这里我们使用第一个进行安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># docker pull mattrayner/lamp</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from mattrayner/lamp</span><br><span class="line">35807b77a593: Pull complete </span><br><span class="line">ccfecfa17ed6: Pull complete </span><br><span class="line">499764c8dc6b: Pull complete </span><br><span class="line">c6b0ddc4cdc0: Pull complete</span><br><span class="line">...</span><br><span class="line">Digest: sha256:f7caeba589eaea7e3d20f4ae3e3bf88233e66e7df59eb5adb49161a5365f9f90</span><br><span class="line">Status: Downloaded newer image for mattrayner/lamp:latest</span><br><span class="line">docker.io/mattrayner/lamp:latest</span><br></pre></td></tr></table></figure><p>启用名字mylamp，以便以后可以直接使用名字重启</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># docker run --name mylamp -p 80:80 -p 3306:3306 -d mattrayner/lamp</span><br><span class="line">e9c27bbc28366f0b00018a03b0b31be2f1ac1f1355ea31796b970c312e7f17cf</span><br></pre></td></tr></table></figure><p>测试运行结果</p><p><img src="/2021/11/22/docker%E6%90%AD%E5%BB%BALAMP%E7%8E%AF%E5%A2%83/测试phpmyadmin运行结果.png" alt="photo"></p><p>查看dklamp中的mysql的root密码，使用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># docker logs mylamp</span><br><span class="line">Updating for PHP 8.0</span><br><span class="line">Replacing CLI php.ini values</span><br><span class="line">Editing APACHE_RUN_GROUP environment variable</span><br><span class="line">Editing phpmyadmin config</span><br><span class="line">Setting up MySQL directories</span><br><span class="line">Allowing Apache/PHP to write to the app</span><br><span class="line">Allowing Apache/PHP to write to MySQL</span><br><span class="line">Editing MySQL config</span><br><span class="line">=&gt; An empty or uninitialized MySQL volume is detected in /var/lib/mysql</span><br><span class="line">=&gt; Installing MySQL ...</span><br><span class="line">=&gt; Done!</span><br><span class="line">=&gt; Waiting for confirmation of MySQL service startup</span><br><span class="line">=&gt; Creating MySQL admin user with random password</span><br><span class="line">ERROR 1064 (42000) at line 1: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;IDENTIFIED BY &#x27;&#x27;&#x27; at line 1</span><br><span class="line">=&gt; Done!</span><br><span class="line">========================================================================</span><br><span class="line">You can now connect to this MySQL Server with 46W9QD9oC5Co</span><br><span class="line"></span><br><span class="line">    mysql -uadmin -p46W9QD9oC5Co -h&lt;host&gt; -P&lt;port&gt;</span><br><span class="line"></span><br><span class="line">Please remember to change the above password as soon as possible!</span><br><span class="line">MySQL user &#x27;root&#x27; has no password but only allows local connections</span><br><span class="line"></span><br><span class="line">enjoy!</span><br></pre></td></tr></table></figure><p>查看密码为46W9QD9oC5Co，用户名为admin</p><h3 id="docker常用命令"><a href="#docker常用命令" class="headerlink" title="docker常用命令"></a>docker常用命令</h3><p>查看所有镜像:docker image ls<br>查看是否有容器在运行:docker ps<br>容器停止：docker stop mylamp<br>容器开始：docker start mylamp</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://ran-barry.github.io/2021/11/22/Ubuntu%E6%90%AD%E5%BB%BAdocker%E7%8E%AF%E5%A2%83/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Ran-Barry"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hello"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2021/11/22/Ubuntu%E6%90%AD%E5%BB%BAdocker%E7%8E%AF%E5%A2%83/" class="post-title-link" itemprop="url">Ubuntu搭建docker环境</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-22 17:25:11" itemprop="dateCreated datePublished" datetime="2021-11-22T17:25:11+08:00">2021-11-22</time></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>2.7k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>2 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><p>本文采用阿里云ECS服务器实例来进行搭建docker环境</p><h2 id="连接阿里云服务器"><a href="#连接阿里云服务器" class="headerlink" title="连接阿里云服务器"></a>连接阿里云服务器</h2><p>通过xshell或者其他shell工具连接阿里云服务器</p><h2 id="使用APT安装"><a href="#使用APT安装" class="headerlink" title="使用APT安装"></a>使用APT安装</h2><p>由于 apt 源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS 传输的软件包以及 CA 证书</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg \</span><br><span class="line">    lsb-release</span><br></pre></td></tr></table></figure><p>鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看</p><p>为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br><span class="line"># 官方源</span><br><span class="line"># $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br></pre></td></tr></table></figure><p>然后，我们需要向 sources.list 中添加 Docker 软件源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ echo \</span><br><span class="line">    &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \</span><br><span class="line">    $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line"># 官方原</span><br><span class="line"># $ echo \</span><br><span class="line">    #   &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \</span><br><span class="line">#   $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></pre></td></tr></table></figure><blockquote><p>以上命令会添加稳定版本的 Docker APT 镜像源，如果需要测试版本的 Docker 请将 stable 改为 test</p></blockquote><h2 id="使用官方安装脚本自动安装"><a href="#使用官方安装脚本自动安装" class="headerlink" title="使用官方安装脚本自动安装"></a>使用官方安装脚本自动安装</h2><p>在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，Ubuntu 系统上可以使用这套脚本安装，另外可以通过 —mirror 选项使用国内源进行安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure><p>执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 的稳定(stable)版本安装在系统中</p><p>也可以使用国内 daocloud 一键安装命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://get.daocloud.io/docker | sh</span><br></pre></td></tr></table></figure><h2 id="启动Docker"><a href="#启动Docker" class="headerlink" title="启动Docker"></a>启动Docker</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl enable docker</span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure><h2 id="建立docker用户组"><a href="#建立docker用户组" class="headerlink" title="建立docker用户组"></a>建立docker用户组</h2><p>默认情况下，docker 命令会使用 Unix socket与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组</p><p>建立<code>docker</code>组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo groupadd docker</span><br></pre></td></tr></table></figure><p>将当前用户加入<code>docker</code>组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure><p>退出当前终端并重新登录，进行如下测试</p><h2 id="测试Docker是否安装正确"><a href="#测试Docker是否安装正确" class="headerlink" title="测试Docker是否安装正确"></a>测试Docker是否安装正确</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm hello-world</span><br><span class="line"></span><br><span class="line">Unable to find image &#x27;hello-world:latest&#x27; locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">2db29710123e: Pull complete </span><br><span class="line">Digest: sha256:cc15c5b292d8525effc0f89cb299f1804f3a725c8d05e158653a563f15e4f685</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://ran-barry.github.io/2021/11/21/Web%E6%BC%8F%E6%B4%9E-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Ran-Barry"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hello"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2021/11/21/Web%E6%BC%8F%E6%B4%9E-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/" class="post-title-link" itemprop="url">Web漏洞-文件上传</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-21 17:01:00" itemprop="dateCreated datePublished" datetime="2021-11-21T17:01:00+08:00">2021-11-21</time></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>2.3k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>2 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><p><img src="/2021/11/21/Web%E6%BC%8F%E6%B4%9E-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/WEB漏洞-文件上传.png" alt="文件上传"></p><h2 id="文件上传漏洞介绍"><a href="#文件上传漏洞介绍" class="headerlink" title="文件上传漏洞介绍"></a>文件上传漏洞介绍</h2><h3 id="什么是文件上传漏洞"><a href="#什么是文件上传漏洞" class="headerlink" title="什么是文件上传漏洞"></a>什么是文件上传漏洞</h3><p>凡是存在文件上传的地方均有可能存在文件上传漏洞，关于上传文件操作的时候对方代码写的是否完整、是否安全，一旦疏忽了某个地方可能会造成文件上传漏洞</p><h3 id="文件上传的原理"><a href="#文件上传的原理" class="headerlink" title="文件上传的原理"></a>文件上传的原理</h3><p>网站Web应用都有一些文件上传功能，比如文档、图片、头像、视频上传，当上传功能的实现代码没有严格校验上传文件的后缀和文件类型，此时攻击者就可以上传一个webshell到一个Web可访问的目录上，并将恶意文件传递给如PHP解释器去执行，之后就可以在服务器上执行恶意代码，进行数据库执行、服务器文件管理，服务器命令执行等恶意操作。还有一部分是攻击者通过Web服务器的解析漏洞来突破Web应用程序的防护</p><h3 id="文件上传漏洞的危害"><a href="#文件上传漏洞的危害" class="headerlink" title="文件上传漏洞的危害"></a>文件上传漏洞的危害</h3><p>文件可以自定义，可以成为webshell，通过文件上传来上传网站后门，直接获取网站权限，属于高危漏洞。上传漏洞与SQL注入或 XSS相比 , 其风险更大 。可以获取数据库信息，可以对服务器提权，获取内网权限</p><h3 id="文件上传漏洞如何查找和判断"><a href="#文件上传漏洞如何查找和判断" class="headerlink" title="文件上传漏洞如何查找和判断"></a>文件上传漏洞如何查找和判断</h3><ol><li>黑盒查找<br>文件后台<br>进入网站后台不一定获得网站权限，可以从后台获取网站权限<br>会员中心<br>通过图片上传<br>文件扫描<br>使用工具扫描出后台路径</li><li>白盒查找<br>通过代码分析到上传漏洞<br>查找文件上传功能</li></ol><h2 id="文件上传的实现"><a href="#文件上传的实现" class="headerlink" title="文件上传的实现"></a>文件上传的实现</h2><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p><img src="/2021/11/21/Web%E6%BC%8F%E6%B4%9E-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/利用思路.png" alt="利用思路"></p><h3 id="文件上传在实际应用中的方式"><a href="#文件上传在实际应用中的方式" class="headerlink" title="文件上传在实际应用中的方式"></a>文件上传在实际应用中的方式</h3><p><strong>方式一</strong></p><p>先直接传一个PHP，实战先传马<br>实战先传一个正常的图片，看看有无返回存储地址<br>如果能直接上传并解析，已离成功不远</p><p><strong>方式二</strong></p><p>先传一个shell，然后进行修改<br>connect-Type:image/jpeg，看看是否可以进行绕过，如果不行，在上传内容添加GIF89a<br>当然上传了还得看是否能够被解析为php，所有的上传都要考虑是否能够被解析</p><p><strong>方式三</strong></p><ul><li>上传一个abc.abcd，目的只是为了查看是否为白名单还是黑名单绕过。黑名单限制一般为此文件类型不允许上传，考虑双写，大小写，空格，php2,php3,php4,php5,pht,phtml,等方式</li><li>我们继续上传一个/htaccess文件.htaccess文件能够设置服务器的解析文件的格式，匹配到dudu就已php的格式来解析，继而上传马</li><li>如果说.htaccess不能上传，接下来上传一个.user.ini，继而上传一个马</li></ul><p><strong>方法四</strong></p><p>如果白名单限制上传</p><ul><li>考虑00截断上传</li><li>文件包含漏洞+图片马</li><li>文件包含漏洞+二次渲染+图片马</li></ul><p><strong>方法五</strong></p><p>上传的东西是否被服务器很快的删除或者移除，或者说上传成功，但是无法访问，就得考虑条件竞争<br>以上均不行，考虑逻辑层面的思路</p><h2 id="文件上传常见验证"><a href="#文件上传常见验证" class="headerlink" title="文件上传常见验证"></a>文件上传常见验证</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>JS类防护</p><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p><strong>后缀名</strong></p><p>黑名单：明确不允许上传的格式后缀，asp、php、jsp、aspx等。<br>白名单：明确可以上传的文件后缀。jpg、png、zip、gif等</p><p><strong>文件类想</strong></p><p>MIME信息：</p><p>Content-Type称之为MIME信息，通过伪造Content-Type等来进行上传</p><p><strong>文件头</strong></p><p>内容头信息</p><h3 id="文件上传绕过"><a href="#文件上传绕过" class="headerlink" title="文件上传绕过"></a>文件上传绕过</h3><h4 id="黑名单绕过"><a href="#黑名单绕过" class="headerlink" title="黑名单绕过"></a>黑名单绕过</h4><p><strong>特殊解析信息</strong></p><p>使用yijuhua.jpg.zip.php等多后缀，如果没有添加strrchr()、和deldot()的话可以绕过<br>deldot():删除文件名末尾的点，防止多后缀<br>strchr(string1,string2):查找字符串在另一个字符串中最后一次出现的位置，并返回从该位置到字符串结尾的所有字符</p><p>如果php3、php5、phtml没有定义到黑名单中，且apache开启解析，则可以用这种格式进行绕过</p><p><strong>.htaccess解析</strong></p><p>仅存在于Apache中<br>htaccess文件时apache服务器中的一个配置文件，负责相关目录下的网页配置。通过htaccess文件，可以帮助我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能</p><p><strong>大小写绕过</strong></p><p>对大小写进行强制转换，后缀修改大小写即可绕过</p><p><strong>空格绕过</strong></p><p>源码中缺少收尾去空函数，则可以通过加空格进行绕过<br>trim():去除字符串中的空格</p><p><strong>点绕过</strong></p><p>windows中1.txt和1.txt.两者是一个文件，所以就和空格绕过是一个思路</p><p><strong>::$DATA绕过</strong></p><p>利用Windows特性<br>在windows的时候如果文件名+”::$DATA”会把::$DATA之后的数据当成文件流处理，不会检测后缀名，且保持::$DATA之前的文件名，他的目的就是不检查后缀名<br>例如：”phpinfo.php::$DATA”Windows会自动去掉末尾的::$DATA变成”phpinfo.php”</p><p><strong>点空格点绕过</strong></p><p>利用的就是程序员写代码时可能只会过滤一次特殊的关键词等，所以可以通过多次输入重复的关键词或者混着输入关键词来进行绕过</p><p>比如：</p><p>一次过滤<br>a.php-&gt;a.<br>a.pphphp-&gt;a.php 将中间的php过滤掉，还有一个php<br>但是当编写的是循环过滤的话，这个就会失效<br>a.pphphp-&gt;a.只要出现php就会过滤</p><p><strong>双后缀名绕过</strong></p><p>.pphphp</p><h4 id="白名单绕过"><a href="#白名单绕过" class="headerlink" title="白名单绕过"></a>白名单绕过</h4><p><strong>%00截断——GET</strong></p><p>原理：<br>www.xxx.com/qq.jpg<br>www.xxx.com/qq.php%00.jpg=&gt;www.xxx.com/qq.php<br>%00是被服务器解码为0x00发挥了截断作用<br>0x00是十六进制表示方法，是ascii码为0的字符，在有些函数处理时，会把这个字符当做结束符<br>%00和0x00是由区别的；%00是URL中的，0x00是文件命名<br>%00需要PHP版本小于5.3.4，且打开的配置文件php-ini，将magic_quotes_gpc设置为Off</p><p><strong>%00截断——POST</strong></p><p>post不会解码%00-&gt;url编码</p><p>参考资料：<a target="_blank" rel="noopener" href="https://www.yuque.com/samxara/swro13/tqdn5k">https://www.yuque.com/samxara/swro13/tqdn5k</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://ran-barry.github.io/2021/11/17/Web%E6%BC%8F%E6%B4%9E-SQL%E6%B3%A8%E5%85%A5/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Ran-Barry"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hello"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2021/11/17/Web%E6%BC%8F%E6%B4%9E-SQL%E6%B3%A8%E5%85%A5/" class="post-title-link" itemprop="url">Web漏洞-SQL注入</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-11-17 08:27:19" itemprop="dateCreated datePublished" datetime="2021-11-17T08:27:19+08:00">2021-11-17</time></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>4.6k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>4 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SQL注入是比较常见的网络攻击方式之一，它不是利用操作系统的BUG来实现攻击，而是针对程序员编写时的疏忽，通过SQL语句，实现无账号登录，甚至篡改数据库</p><p><img src="/2021/11/17/Web%E6%BC%8F%E6%B4%9E-SQL%E6%B3%A8%E5%85%A5/SQL注入.png" alt="photo"></p><h2 id="SQL注入产生的原理"><a href="#SQL注入产生的原理" class="headerlink" title="SQL注入产生的原理"></a>SQL注入产生的原理</h2><ol><li>对用户输入的参数没有进行严格过滤（如过滤单双引号 尖括号等），就被带到数据库执行，造成了SQL注入</li><li>使用了字符串拼接的方式构造SQL语句</li></ol><h2 id="SQL注入的分类"><a href="#SQL注入的分类" class="headerlink" title="SQL注入的分类"></a>SQL注入的分类</h2><ol><li>从注入手法分类可以分为：联合查询注入、报错型注入、布尔型注入、延时注入、堆叠注入</li><li>从数据类型上可以分为：字符型（即输入的输入使用符号进行过滤）、数值型（即输入的输入未使用符号进行过滤）</li><li>从注入位置可以分类为：GET数据（提交数据方式为GET，大多存在地址栏）、POST数据（提交数据方式为POST，大多存在输入框中）、HTTP头部（提交数据方式为HTTP头部）、cookie数据（提交数据方式为cookie）</li></ol><h2 id="SQL注入的危害"><a href="#SQL注入的危害" class="headerlink" title="SQL注入的危害"></a>SQL注入的危害</h2><p>分为两类：危害数据库里的数据、直接危害到网站的权限(需要满足条件)</p><ol><li>数据库信息泄露</li><li>网页篡改：登陆后台后发布恶意内容</li><li>网站挂马 : 当拿到webshell时或者获取到服务器的权限以后，可将一些网页木马挂在服务器上，去攻击别人</li><li>私自添加系统账号</li><li>读写文件获取webshell</li></ol><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><h3 id="系统函数"><a href="#系统函数" class="headerlink" title="系统函数"></a>系统函数</h3><p>information_schema.schemata 记录所有数据库名<br>information_schema.tables：记录所有表名信息的表<br>information_schema.columns：记录所有列名信息的表<br>schema_name 数据库名<br>table_name：表名<br>column_name：列名<br>table_schema：数据库名<br>system_user() 查看当前Mysqlsql登录用户名，同下<br>user() 查看当前MySQL登录的用户名<br>database() 查看当前使用MySQL数据库名<br>version() 查看当前MySQL版本<br>@@version_compile_os 查看操作系统<br>@@HOSTNAME 主机名称<br>@@datadir 数据库路径</p><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><ol><li>floor() 向下取整</li><li>rand() 返回一个大于0小于1的浮点数</li><li>length(str) 返回字符串长度</li><li>ascii(str) 返回字符串str的最左面字符的ASCII代码值，如果str是空字符串，返回0；如果str是NULL，返回NULL</li><li>load_file() 读取本地文件 用法：select load_file(‘C:\phpstudy\www\sqli\Less-7\text.txt’);<a target="_blank" rel="noopener" href="https://www.yuque.com/docs/share/8c58e841-32da-4c7e-a3ac-394f294a2aa6?">Mysql注入load_file常用路径</a></li><li>into outfile 写文件 用法：select ‘mysql is good’ into outfile ‘test.txt’;</li><li>if(condition,A,B)如果条件condition为true，则执行A，否则执行B</li><li>chr(数字),ord(‘字母’) python中将字符或布尔类型转成ascii码</li></ol><h3 id="字符串拼接函数"><a href="#字符串拼接函数" class="headerlink" title="字符串拼接函数"></a>字符串拼接函数</h3><ol><li>concat(str1,str2..)函数 没有分隔符串联多列结果</li><li>concat_ws(separator,str1,str2,…) 含有分隔符串联多列结果</li><li>group_concat(str1,str2,str3…) 用逗号，串联多行结果为一行</li><li>order by关键字(select * from table_name order by 3)表示按第三列排序</li><li>left(str,len) 对指定字符串从左边截取指定长度，正确返回1，错误返回0</li><li>right(str,len)对指定字符串从右边截取指定长度</li><li>substr(str,start,length)对于给定字符串，从start为开始截取length长度，如substr(“chinese”,3,2)=”in”.类似的还有substring()、mid()用法功能一致</li><li>regexp函数 匹配正则</li></ol><h3 id="判断注入点"><a href="#判断注入点" class="headerlink" title="判断注入点"></a>判断注入点</h3><p><strong>数字型</strong><br>通过2-1与1的回显结果判断是否为数字型注入。有可能被()或者(())括起来</p><p><strong>字符型</strong><br>用单引号和双引号进行闭合。也有可能被(),(())包裹</p><p><img src="/2021/11/17/Web%E6%BC%8F%E6%B4%9E-SQL%E6%B3%A8%E5%85%A5/MYSQL注入利用.png" alt="photo"></p><h2 id="显错注入"><a href="#显错注入" class="headerlink" title="显错注入"></a>显错注入</h2><p>Mysql在5.0以上版本加入了 information_schema 这个系统自带库 其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权限等</p><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><ol><li>判断字段数目order by 4…</li><li>判断显示位 union select 1,2,3,4…</li><li>查看当前数据库union select 1,2,database()</li><li>查表名union select 1,2,table_name from information_schema.tables where table_schema=database()</li><li>查列名union select 1,2,column_name from information_schema.columns where table_name=’表名’ and table_schema=database()</li><li>查询字段值union select 1,字段名,字段名 from 表名</li></ol><h2 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h2><h3 id="基于布尔的盲注"><a href="#基于布尔的盲注" class="headerlink" title="基于布尔的盲注"></a>基于布尔的盲注</h3><p>这里主要使用mid(),substr(),left()这几个函数来截取字符串慢慢尝试</p><ol><li>猜解当前数据库名称长度 and (length(database()))&gt;1</li><li>通过<a target="_blank" rel="noopener" href="http://127.0.0.1/sqli/Less-5/?id=1">http://127.0.0.1/sqli/Less-5/?id=1</a>‘ and left((select database()),1)=’s’—+ 判断第一位是否是s，然后可以用bp逐步进行爆破处理</li><li>或者使用if来判断测试<a target="_blank" rel="noopener" href="http://127.0.0.1/sqli/Less-5/?id=1">http://127.0.0.1/sqli/Less-5/?id=1</a>‘ and ascii(substr((select database()),1,1))&gt;156—+来通过二分法逐步判断</li><li>之后就是正常的注入流程，不断的猜表名、猜字段名和猜内容</li></ol><h3 id="基于时间的SQL盲注"><a href="#基于时间的SQL盲注" class="headerlink" title="基于时间的SQL盲注"></a>基于时间的SQL盲注</h3><p>一般来说，在页面没有任何回显和错误信息提示的时候，我们就会测试时间盲注的方法</p><p>主要通过if(length(database())=8,1,sleep())这样来判断语句是否注入成功<br>之后就是类似于布尔盲注的形式进行判定注入</p><p>例：/?id = 1’ and if((substr((select schema_name from information_schema.schmata limit 4,1),1,8)=’security’),1,sleep(5))—+</p><h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><h3 id="floor-报错"><a href="#floor-报错" class="headerlink" title="floor()报错"></a>floor()报错</h3><blockquote><p>and select 1 from (select count(),concat(version(),floor(rand(0)2))x from information_schema.tables group by x)a);</p></blockquote><h3 id="通过ExtractValue报错"><a href="#通过ExtractValue报错" class="headerlink" title="通过ExtractValue报错"></a>通过ExtractValue报错</h3><blockquote><p>and extractvalue(1, concat(0x5c, (select table_name from information_schema.tables limit 1)));</p></blockquote><h3 id="通过UpdateXml报错"><a href="#通过UpdateXml报错" class="headerlink" title="通过UpdateXml报错"></a>通过UpdateXml报错</h3><blockquote><p>and updatexml(1,concat(0x5c,(select user()),0x5c),1)</p></blockquote><p>其中concat函数是将其连接成一个字符串，因此不会符合XPath_string的格式，从而出现格式错误，爆出ERROR 1105 (HY000): XPATH syntax error: root@localhost</p><p>updatexml()函数</p><p>UPDATEXML(XML_document,XPath_string,new_value);<br>第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc<br>第二个参数：XPath_string(Xpath格式的字符串)<br>第三参数：new_value,String格式，替换查找到的符合条件的数据<br>作用：改变文档中符合条件的节点的值</p><h3 id="通过NAME-CONST报错注入"><a href="#通过NAME-CONST报错注入" class="headerlink" title="通过NAME_CONST报错注入"></a>通过NAME_CONST报错注入</h3><blockquote><p>and exists(selectfrom (selectfrom(selectname_const(@@version,0))a join (select name_const(@@version,0))b)c)</p></blockquote><h3 id="通过join报错注入"><a href="#通过join报错注入" class="headerlink" title="通过join报错注入"></a>通过join报错注入</h3><blockquote><p>select <em>from (select </em>from mysql.user a join mysql.user b)c;</p></blockquote><h3 id="通过exp报错注入"><a href="#通过exp报错注入" class="headerlink" title="通过exp报错注入"></a>通过exp报错注入</h3><blockquote><p>and exp(~(select * from (select user()) a) );</p></blockquote><h3 id="通过GeometryCollection-报错注入"><a href="#通过GeometryCollection-报错注入" class="headerlink" title="通过GeometryCollection()报错注入"></a>通过GeometryCollection()报错注入</h3><blockquote><p>and GeometryCollection(()select *from(select user() )a)b;</p></blockquote><h3 id="通过ploygon-报错注入"><a href="#通过ploygon-报错注入" class="headerlink" title="通过ploygon()报错注入"></a>通过ploygon()报错注入</h3><blockquote><p>and polygon (()select * from(select user())a)b;</p></blockquote><h3 id="通过multipoint-报错注入"><a href="#通过multipoint-报错注入" class="headerlink" title="通过multipoint()报错注入"></a>通过multipoint()报错注入</h3><blockquote><p>and multipoint (()select * from(select user() )a)b;</p></blockquote><h3 id="通过multingestring-报错注入"><a href="#通过multingestring-报错注入" class="headerlink" title="通过multingestring()报错注入"></a>通过multingestring()报错注入</h3><blockquote><p>and multlinestring (()select * from(select user() )a)b;</p></blockquote><h3 id="通过multpolygon-报错注入"><a href="#通过multpolygon-报错注入" class="headerlink" title="通过multpolygon()报错注入"></a>通过multpolygon()报错注入</h3><blockquote><p>and multpolygon (()select * from(select user() )a)b;</p></blockquote><h3 id="通过linestring-报错注入"><a href="#通过linestring-报错注入" class="headerlink" title="通过linestring()报错注入"></a>通过linestring()报错注入</h3><blockquote><p>and linestring (()select * from(select user() )a)b;</p></blockquote><h2 id="POST注入"><a href="#POST注入" class="headerlink" title="POST注入"></a>POST注入</h2><h3 id="头部POST注入"><a href="#头部POST注入" class="headerlink" title="头部POST注入"></a>头部POST注入</h3><p><strong>常用的请求头</strong></p><ul><li><p>HostHost<br>Host请求报头域主要用于指定被请求资源的Internet主机和端口号。<br>如：Host: localhost:8088</p></li><li><p>User-Agent<br>User-Agent请求报头域允许客户端将它的操作系统、浏览器和其他属性告诉服务器。登录一些网站时，很多时候都可以见到显示我们的浏览器、系统信息，这些都是此头的作用。<br>如：User-Agent: Mozilla/5.0</p></li><li><p>Referer<br>Referer包含一个URL，代表当前访问URL的上一个URL，也就是说，用户是从什么地方来到本页面。<br>如：Referer: <a target="_blank" rel="noopener" href="http://192.168.33.1/sqli/Less-18/">http://192.168.33.1/sqli/Less-18/</a></p></li><li><p>Cookie<br>Cookie是非常重要的请求头，它是一段文本，常用来表示请求者身份等。<br>如：Cookie: username=admin; password=admin</p></li><li><p>Range<br>Range可以请求实体的部分内容，多线程下载一定会用到此请求头。<br>如：表示头500字节：Range: bytes=0~499<br>  表示第二个500字节：Range: bytes=500~999<br>  表示最后500字节：Range: bytes=-500<br>  表示500字节以后的范围：Range: bytes=500-</p></li><li><p>X-Forwarded-For<br>X-Forwarded-For即XXF头，它代表请求端的IP，可以有多个，中间以逗号隔开。<br>如：X-Forwarded-For: 8.8.8.8</p></li><li><p>Accept<br>Accept请求报头域用于指定客户端接收哪些MIME类型的信息。<br>如：Accept: text/html</p></li><li><p>Accept-Charset<br>Accept-Charset请求报头域用于指定客户端接收的字符集。如果在请求消息中没有设置这个域，默认是任何字符集都可以接收。<br>如： Accept-Charset: gb2312</p></li></ul><h2 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h2><h2 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h2><h2 id="DNS注入"><a href="#DNS注入" class="headerlink" title="DNS注入"></a>DNS注入</h2><p>通过sqli-labs进行学习<br>学习参考视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1e441127Rd">https://www.bilibili.com/video/BV1e441127Rd</a></p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://ran-barry.github.io/2021/10/19/Java-%E9%AB%98%E7%BA%A7/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Ran-Barry"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hello"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2021/10/19/Java-%E9%AB%98%E7%BA%A7/" class="post-title-link" itemprop="url">Java-高级</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-10-19 16:44:14" itemprop="dateCreated datePublished" datetime="2021-10-19T16:44:14+08:00">2021-10-19</time></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>8.5k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>8 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><h3 id="类变量和类方法"><a href="#类变量和类方法" class="headerlink" title="类变量和类方法"></a>类变量和类方法</h3><h4 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h4><p>类变量也叫静态变量，是该类的所有对象共享的变量，任何一个该类的对象去访问它时，取到的都是相同的值，同样任何一个该类的对象去修改它时，修改的也是同一个变量</p><ol><li>static(静态)变量是同一个类所有对象共享</li><li>sataic类变量在类加载的时候就生成</li></ol><p>定义语法：<br>访问修饰符 static 数据类型 变量名（推荐）<br>static 访问修饰符 数据类型 变量名</p><h4 id="类变量与实例变量的区别"><a href="#类变量与实例变量的区别" class="headerlink" title="类变量与实例变量的区别"></a>类变量与实例变量的区别</h4><p>类变量是该类的所有对象共享的，而实例变量是每个对象独享的</p><h4 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h4><p>类方法也叫静态方法<br>静态方法使用时可以直接使用</p><ol><li>类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区：类方法中无this的参数，普通方法中隐含着this的参数</li><li>类方法可以通过类名调用，也可以通过对象名调用</li><li>普通方法和对象有关，需要通过对象名调用</li><li>类方法中不允许使用和对象有关的关键字，比如this和super。普通方法可以</li><li>静态方法中只能访问静态变量或静态方法</li><li>普通成员方法，既可以访问非静态成员，也可以访问静态成员</li><li>静态方法可以被继承，但不能被重写</li></ol><h3 id="理解main方法语法"><a href="#理解main方法语法" class="headerlink" title="理解main方法语法"></a>理解main方法语法</h3><ol><li>main方法是java虚拟机调用</li><li>java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是public</li><li>java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static</li><li>该方法接收String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数</li><li>java 执行的程序 参数1 参数2 参数3</li><li>在main()方法中，可以直接调用main方法所在类的静态方法或静态属性</li><li>不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员</li></ol><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>又称为初始化块，属于类中的成员，类似于方法，将逻辑语句封装在方法体中，通过{}包围起来<br>但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显式调用，而是加载类时，或创建对象时隐式调用</p><p>基本语法<br>[修饰符]{<br>代码<br>};</p><h4 id="代码块的好处"><a href="#代码块的好处" class="headerlink" title="代码块的好处"></a>代码块的好处</h4><ol><li>相当于另外一种形式的构造器，可以做初始化的操作</li><li>代码块调用顺序优先于构造器</li></ol><h4 id="细节讨论"><a href="#细节讨论" class="headerlink" title="细节讨论"></a>细节讨论</h4><ol><li>static代码块也叫静态代码块，作用就是对类进行初始化，而且它随着类的加载而执行，并且只会执行一次，如果是普通代码块，每创建一个对象，就执行</li><li>类什么时候被加载<ol><li>创建对象实例时</li><li>创建子类对象实例，父类也会被加载</li><li>使用类的静态成员时</li></ol></li><li>普通的代码块，在创建对象实例时，会被隐式的调用。被创建一次，就会调用一次。如果只是使用类的静态成员时，普通代码块并不会执行</li><li>创建一个对象时，在一个类调用顺序时<ol><li>调用静态代码块和静态属性初始化（两个优先级一样，按定义顺序调用）</li><li>调用普通代码块和普通属性的初始化（两个优先级一样，按定义顺序调用）</li><li>调用构造方法</li></ol></li><li>构造器的最前面其实隐含了super()和调用普通代码块，在类加载时，就执行完毕</li><li>创建一个子类时，它们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序<ol><li>父类的静态代码块和静态属性（优先级一样，按定义顺序）</li><li>子类的静态代码块和静态属性（优先级一样，按定义顺序）</li><li>父类的普通代码块和普通属性初始化（优先级一样，按定义顺序）</li><li>父类的构造方法</li><li>子类的普通代码块和普通属性初始化</li><li>子类的构造方法</li></ol></li><li>静态代码块只能调用静态成员，普通代码块可以调用任意成员</li></ol><h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><p>单例模式就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法</p><ol><li>构造器私有化=》防止直接new</li><li>类的内部创建对象</li><li>向外暴露一个静态的公共方法</li></ol><p>饿汉式VS懒汉式</p><ol><li>二者最主要的区别在于创建对象的时机不同；饿汉式是在类加载就创建了对象实例，而懒汉式是在使用时才创建</li><li>饿汉式不存在线程安全问题，懒汉式存在线程安全问题</li><li>饿汉式存在浪费资源的可能，因为如果程序员一个对象实例都没有使用，那么饿汉式创建的对象就浪费了，懒汉式是使用时才创建，就不存在这个问题</li><li>javaSE标准类中，java.lang.Runtime就是单例模式</li></ol><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>final可以修饰类、属性、方法和局部变量</p><ol><li>当不希望类被继承时，可以用final修饰</li><li>当不希望父类的某个方法被子类覆盖/重写时，可以用final关键字修饰</li><li>当不希望类的某个属性的值被修改，可以用final</li><li>当不希望某个局部变量被修改，可以使用final修饰</li></ol><h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><ol><li>final修饰的属性又叫常量</li><li>final修饰的属性在定义时，必须赋值，并且以后不能再修改，赋值可以在如下位置之一<ol><li>定义时</li><li>在构造器中</li><li>在代码块中</li></ol></li><li>如果final修饰的属性是静态的，则初始化的位置只能是定义时或在静态代码块，不能在构造器中赋值</li><li>final类不能继承，但是可以实例化对象</li><li>如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承</li><li>一般来说，如果一个方法以及是final类了，就没必要再将方法修饰成final方法</li><li>final不能修饰构造方法</li><li>final和static往往搭配使用，效率更高，底层编译器做了优化处理</li><li>包装类（Integer，Double，Boolean等都是final），String也是final类</li></ol><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>当父类的一些方法不能确定时，可以用abstract关键字来修饰该方法，这个方法就是抽象方法，用abstract来修饰该类就是抽象类</p><ol><li>用abstract关键字来修饰一个类时，这个类就叫抽象类访问修饰符abstract 类名{}</li><li>用abstract关键字来修饰一个方法时，这个方法就是抽象方法 访问修饰符 abstract 返回类型 方法名(参数列表)： //没有方法体</li><li>抽象类的价值更多作用是在于设计，是设计者设计好后，让子类继承并实现抽象类()</li></ol><h4 id="抽象类细节"><a href="#抽象类细节" class="headerlink" title="抽象类细节"></a>抽象类细节</h4><ol><li>抽象类不能被实例化</li><li>抽象类不一定要包含abstract方法</li><li>一旦类包含了abstract方法，则这个类必须声明为abstract</li><li>abstract只能修饰类和方法，不能修饰属性和其它的</li><li>抽象类可以有任意成员，比如：非抽象方法、构造器、静态属性等待</li><li>抽象方法不能有主体，即不能实现</li><li>如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类</li><li>抽象方法不能使用private、final和static来修饰，因为这些关键字都是和重写相违背的</li></ol><h4 id="抽象类-模板设计模式"><a href="#抽象类-模板设计模式" class="headerlink" title="抽象类-模板设计模式"></a>抽象类-模板设计模式</h4><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，在根据具体情况把这些方法写出来</p><p>在jdk8后，可以有默认实现方法，需要使用default关键字修饰，也可以有静态方法</p><h4 id="接口细节"><a href="#接口细节" class="headerlink" title="接口细节"></a>接口细节</h4><ol><li>接口不能被实例化</li><li>接口中所有方法是public方法，接口中抽象方法，可以不同abstract修饰</li><li>一个普通类实现接口，就必须将该接口的所有方法都实现</li><li>抽象类实现接口，可以不用实现接口的方法</li><li>一个类同时可以实现多个接口</li><li>接口中的属性只能是final，而且是public static final 修饰符</li><li>接口中属性的访问形式：接口名.属性名</li><li>一个接口不能继承其他的类，但是可以继承多个别的接口</li><li>接口的修饰符只能是public和默认，这点和类的修饰符一样</li></ol><h4 id="接口和继承类"><a href="#接口和继承类" class="headerlink" title="接口和继承类"></a>接口和继承类</h4><p>接口和继承解决的问题不同</p><p>继承的价值在于：解决代码的复用性和可维护性<br>接口的价值在于：设计好的各种规范，让其他类去实现这些方法</p><p>接口比继承更加灵活</p><p>接口在一定程度上实现代码解耦</p><h4 id="接口多态"><a href="#接口多态" class="headerlink" title="接口多态"></a>接口多态</h4><ol><li>多态参数</li><li>多态数组</li><li>接口存在多态传递现象</li></ol><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>一个类的内部又完整的嵌套了另一个类结构。被嵌套的类称为内部类，嵌套其他类的类称为外部类。内部类可以直接访问私有属性，并且可以体现类与类之间的包含关系</p><h4 id="内部类的分类"><a href="#内部类的分类" class="headerlink" title="内部类的分类"></a>内部类的分类</h4><p>定义在外部类局部位置上</p><ol><li>局部内部类（有类名）</li><li>匿名内部类（没有类名，重点）</li></ol><p>定义在外部类的成员位置上</p><ol><li>成员内部类（没用static修饰）</li><li>静态内部类（使用static修饰）</li></ol><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>局部内部类是定义在外部类的局部位置，比如方法中，并且有类名</p><ol><li>可以直接访问外部类的所有成员，包含私有的</li><li>不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量不能使用修饰符。但是可以使用final修饰</li><li>作用域：仅仅在定义它的方法或代码块中</li><li>局部内部类—-访问—-&gt;外部类的成员【直接访问】</li><li>外部类—-访问—-&gt;局部内部类的成员【创建对象，再访问】</li><li>外部其他类—-不能访问—-&gt;局部内部类</li><li>如果外部类和局部内部类的成员方法重名时，默认遵循就近原则，如果想访问外部类的成员，可以使用（外部类名.this.成员）去访问</li></ol><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>匿名内部类是定义在外部类的局部位置，比如方法中</p><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><p>定义在外部类的成员位置，没有static修饰</p><ol><li>可以直接访问外部类的所有成员，包含私有的</li><li>可以添加任意访问修饰符（pubic，protected，默认，private）</li><li>作用域和外部类的其他成员一样，为整个类体</li><li>成员内部类—-访问—-&gt;外部类【直接访问】</li><li>外部类—-访问—-&gt;内部类【创建对象，再访问】</li><li>外部其他类—-访问—-&gt;成员内部类</li><li>如果外部类和局部内部类的成员方法重名时，默认遵循就近原则，如果想访问外部类的成员，可以使用（外部类名.this.成员）去访问</li></ol><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>定义在外部类的成员位置，并且有static修饰</p><ol><li>可以直接访问外部类的所有静态成员，包含私有的，但不能直接访问非静态成员</li><li>可以添加任意访问修饰符</li><li>作用域：为整个类体</li><li>静态内部类—-访问—-&gt;外部类【直接访问所有静态成员】</li><li>外部类—-访问—-&gt;静态内部类【创建对象，再访问】</li><li>外部其他类—-&gt;访问—-&gt;静态内部类</li><li>如果外部类和局部内部类的成员方法重名时，默认遵循就近原则，如果想访问外部类的成员，可以使用（外部类名.this.成员）去访问</li></ol><h2 id="枚举和注释"><a href="#枚举和注释" class="headerlink" title="枚举和注释"></a>枚举和注释</h2><h3 id="自定义枚举"><a href="#自定义枚举" class="headerlink" title="自定义枚举"></a>自定义枚举</h3><ol><li>构造器私有化</li><li>本类内部创建一组对象</li><li>对外暴露对象</li><li>提供get方法，不提供set</li></ol><h3 id="枚举关键字"><a href="#枚举关键字" class="headerlink" title="枚举关键字"></a>枚举关键字</h3><ol><li>当我们使用enum关键字开发一个枚举类时，默认会继承Enum类，且不能继承其他类了</li><li>如果使用无参构造器 创建 枚举对象，则实参列表和小括号都可以省略</li><li>当有多个枚举对象时，使用，间隔，最后一个分号结尾</li><li>枚举对象必须放在枚举类的行首</li><li>枚举类和普通类一样，可以实现接口</li></ol><h3 id="Annotation元注解"><a href="#Annotation元注解" class="headerlink" title="Annotation元注解"></a>Annotation元注解</h3><ol><li>@Override：限定某个方法，是重写父类方法，该注解只能用于方法</li><li>@Deprecated：用于表示某个程序元素（类，方法等）已过时</li><li>@SuppressWarnings：抑制编译器警告</li><li>@Target是修饰注解的注解</li></ol><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ol><li>异常分为两大类，运行时异常和编译时异常</li><li>运行时异常，编译器不要求强制处置的一次。一般是指编程时的逻辑错误</li><li>对于运行时异常，可以不做处理，因为很普遍，全处理可能会对程序的可读性和运行效率产生影响</li><li>编译时异常，是编译器要求必须处置的异常</li></ol><h3 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h3><ol><li>NullPointerException空指针异常。当应用程序试图在需要对象的地方使用null时，抛出该异常</li><li>ArithmeticException数学运算异常。当出现异常的运算条件时，抛出此异常</li><li>ArrayIndexOutOfBoundsException数组下标越界异常</li><li>ClassCastException类型转换异常</li><li>NumberFormatException数字格式不正确异常</li></ol><h3 id="编译异常"><a href="#编译异常" class="headerlink" title="编译异常"></a>编译异常</h3><ol><li>SQLException。操作数据库时，查询表可能发生异常</li><li>IOException 操作文件时，发生的异常</li><li>FileNotFoundException 操作一个不存在的文件时，发生异常</li><li>ClassNotFoundException 加载类，而该类不存在时，异常</li><li>EOFException 操作文件，到文件末尾，发生异常</li><li>ILLegalArguementException 参数异常</li></ol><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ol><li>try-catch-finally。程序员自己处理</li><li>throws。</li></ol><h4 id="try-catch处理异常"><a href="#try-catch处理异常" class="headerlink" title="try-catch处理异常"></a>try-catch处理异常</h4><ol><li>如果异常发生了，则异常发生后面的代码不会执行，直接进入catch块</li><li>如果异常没有发生，则顺序执行try的代码块，不会进入到catch</li><li>如果希望不管是否发生异常，都执行某段代码，则使用finally</li><li>可以有多个catch，捕获不同的异常，要求父类异常在后，子类异常在前</li><li>可以进行try-finally配合使用，这种用法相当于没有捕获异常，因此程序会直接崩掉</li></ol><h4 id="try-catch-finally执行顺序"><a href="#try-catch-finally执行顺序" class="headerlink" title="try-catch-finally执行顺序"></a>try-catch-finally执行顺序</h4><ol><li>如果没有出现异常，则执行try块中所有语句，不执行catch块中语句，如果有finally，最后还需要执行finally里面的语句</li><li>如果出现异常，则try块中异常发生后，剩下的语句不再执行。将执行catch块中的语句，如果有finally，最后还需要执行finally里面的语句</li></ol><h4 id="throws异常处理"><a href="#throws异常处理" class="headerlink" title="throws异常处理"></a>throws异常处理</h4><ol><li>对于编译异常，程序中必须处理，比如try-catch或者throws</li><li>对于运行时异常，程序中如果没有处理，默认就是throws的方式处理</li><li>子类重写父类的方法时，对抛出异常的规定：子类重写的方法所抛出的异常类型要么和父类抛出的异常一致，要么为父类抛出的异常的类型的子类型</li><li>在throws过程中，如果有方法try-catch，就相当于处理异常，就可以不必throws</li></ol><h4 id="throw和throws的区别"><a href="#throw和throws的区别" class="headerlink" title="throw和throws的区别"></a>throw和throws的区别</h4><ol><li>throws是异常处理的一种方式，在方法声明出，后面跟异常类型</li><li>throw是手动生成异常对象的关键字，在方法体中，后面跟异常对象</li></ol><h2 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h2><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><h4 id="包装类和基本数据类型的转换"><a href="#包装类和基本数据类型的转换" class="headerlink" title="包装类和基本数据类型的转换"></a>包装类和基本数据类型的转换</h4><ol><li>jdk5前手动装箱和拆箱方式，装箱；基本数据类型-&gt;包装类型，反之，拆箱</li><li>jdk5以后的自动装箱和拆箱方式</li><li>自动装箱底层调用的是valueOf方法</li></ol><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><ol><li>String对象用于保存字符串，也就是一组字符序列</li><li>字符串常量对象时用双引号扩起的字符序列</li><li>字符串的字符使用Unicode字符编码，一个字符占两个字节</li><li>String类较常用构造方法</li><li>String是一个final类，代表不可变的字符序列</li><li>字符串是不可变的，一个字符串对象一旦被分配，其内容是不可变的</li></ol><h4 id="两种创建String对象的区别"><a href="#两种创建String对象的区别" class="headerlink" title="两种创建String对象的区别"></a>两种创建String对象的区别</h4><p>方式一：直接赋值String s = “hsp”;<br>方式二：调用构造器 String s2 = new String(“hsp”);</p><ol><li>方式一：先从常量池查看是否有”hsp”数据空间，如果有，直接指向；如果没有则重新创建，然后指向。s最终指向的是常量池的空间地址</li><li>方式二：先在堆中创建空间，里面维护了value属性，指向常量池的hsp空间。如果常量池没有”hsp”，重新创建，如果有，直接通过value指向。最终指向的是堆中的空间地址</li></ol><p><img src="/2021/10/19/Java-%E9%AB%98%E7%BA%A7/String内存.png" alt="photo"></p><h4 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h4><p>代表可变的字符序列，可以对字符串内容进行增删</p><p>StringBuffer保存的是字符串变量，里面的值可以更改，每次更新实际上可以更新内容，不用更新地址</p><h4 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h4><p>一个可变的字符序列。不保证同步，用在字符串缓冲区被单个线程使用</p><h3 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h3><ol><li>Calendar是一个抽象类，构造器是private</li></ol><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><ol><li>List集合类中元素有序、且可重复</li><li>List集合中的每个元素都有其对应的顺序索引，即支持索引</li><li>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素</li></ol><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><ol><li>可以加入null，并且多个</li><li>是由数组来实现数据存储的</li><li>基本等同于Vector，除了线程不安全</li><li>当创建ArrayList对象时，如果使用的是无参构造器，则初始elementData容量为0，第一次添加，则扩容elementData为10，如需要再次扩容，则扩容elementData为1.5倍</li><li>如果使用的是指定大小的构造器，则初始elementData容量为指定大小，如果需要扩容，则直接扩容elementData为1.5倍</li></ol><h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><ol><li>实现了双向链表和双端队列特点</li><li>可以添加任意元素（元素可以重复），包括null</li><li>线程不安全</li><li>remove()默认删除第一个</li></ol><h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h5><ol><li>底层也是对象数组</li><li>Vector是线程同步的，即线程安全</li><li>如果是无参构造，则初始容量是10，每次按2倍扩容</li><li>如果是有参构造，则初始容量为指定大小，每次按2倍扩容</li></ol><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><ol><li>无序（添加和取出的顺序不一致），没有索引</li><li>不允许重复元素，所以最多包含一个null</li></ol><h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><ol><li>HashSet实现了Set接口</li><li>实际上是HashMap，HashMap底层是(数组+链表+红黑树)</li><li>可以存放null值，但是只能有一个null</li><li>HashSet不保证元素是有序的，取决于hash后，再确定索引的结果</li><li>不能有重复元素/对象</li></ol><p>HashSet添加元素底层实现</p><ol><li>添加一个元素时，先得到hash值，会转成-&gt;索引值</li><li>找到存储数据表table，看这个索引位置是否已经存放的有元素</li><li>如果没有，直接加入。如果有，调用equals比较，如果相同，就放弃添加，如果不相同，则添加到最后</li><li>在Java8中，如果一条链表的元素个数超过TREEIFY_THRESHOLD（默认是8），并且table的大小 &gt;= MIN_TREEIFY_CAPACITY(默认64)就会进行树化</li></ol><p>扩容机制</p><ol><li>第一次添加时，table数组扩容到16，临界值是16*加载因子(loadFactor)是0.75=12</li><li>如果table数组使用到了临界值12，就会扩容到16<em>2=32，新的临界值就是32</em>0.75=24，依次类推</li><li>在Java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD(默认是8)并且table的大小 &gt;= MIN_TREEIFY_CAPACITY(默认64)，就会进行树化，否则仍然采用数组扩容机制</li></ol><p>去重机制<br>hashCode() + equals()，底层先通过存入对象，进行运算得到一个hash值，通过hash值得到对应的索引，如果发现table索引所在的位置，没有数据，就直接存放，如果有数据，就进行equals比较，不相同就加入，否则不加入</p><h5 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h5><ol><li>是HashSet的子类</li><li>底层是LinkedHashMap，底层维护了一个数组+双向链表</li><li>根据元素的hashCode值来决定元素的存储位置，同时使用链表维护元素的次序，使得元素看起来是以插入顺序保存的</li><li>不允许添加重复元素</li></ol><h5 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h5><p>去重机制<br>如果你传入了一个Comparator匿名对象，就使用实现的compare去重，如果方法返回0，就认为是相同的，不添加。如果没有传入一个Comparator匿名对象，则以添加的对象实现的Comparable接口的compareTo去重</p><h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><ol><li>与Collection并列存在，用于保存具有映射关系的数据</li><li>Map中的key和value可以是任何引用类型的数据，会封装到HashMap$Node对象中</li><li>Map中的key不允许重复</li><li>Map中的value可以重复</li><li>Map中的key可以为null，value也可以为null，key为null只能有一个，value为null可以多个</li><li>常用String类作为Map的key</li></ol><p>六大遍历方式</p><ol><li>containsKey</li><li>keySet：获取所有的键</li><li>entrySet：获取所有关系</li></ol><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><ol><li>底层是数组+链表+红黑树</li><li>是以key-val对的方式来存储数据</li><li>key不能重复，但是值可以重复，允许使用null键和null值</li><li>如果添加相同的key，则会覆盖原来的key-val，等同于修改</li><li>不保证映射的顺序，底层是以hash表的方式来存储的</li><li>没有实现同步，线程不安全</li></ol><h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h4><ol><li>存放的元素是键值对：即K-V</li><li>键和值不能为null</li><li>hashTable是线程安全的</li><li>底层有数组Hashtable$Entry[]初始化大小为11</li><li>临界值 threshold 8 = 11 * 0.75</li><li>扩容为2倍+1</li></ol><h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h4><ol><li>Properties类继承自Hashtable类并且实现了Map接口，也是使用一种键值对的形式来保存数据</li><li>键和值不能为null</li></ol><h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><h3 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h3><ol><li>是一个操作Set、List和Map等集合的工具类</li><li>提供了一系列静态的方法对集合元素进行排序、查询和修改等操作</li></ol><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ol><li>传统的方法不能对加入到集合中的数据类型进行约束</li><li>传统的方法遍历的时候需要进行类型转换，如果集合中数据量较大，对效率有影响</li></ol><p>使用泛型好处</p><ol><li>编译时，检查添加元素的类型，提高了安全性</li><li>减少了类型转换的次数，提高效率</li><li>不再提示编译警告</li></ol><p>泛型介绍</p><ol><li>泛型又称参数化类型，解决数据类型的安全性问题</li><li>在类声明或实例化时只要指定好需要的具体的类型即可</li><li>Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生异常。同时，代码更加简洁、健壮</li><li>可以在类声明时通过一个标识表示类中某个属性的类型，或者是某个方法的返回值的类型，或者是参数类型、</li><li>泛型不具备继承性</li></ol><p>细节</p><ol><li>普通成员可以使用泛型</li><li>使用泛型的数组，不能初始化</li><li>静态方法中不能使用类的泛型</li><li>泛型类的类型，是在创建对象时确定的</li><li>如果在创建对象时，没有指定对象，默认为Object</li></ol><h2 id="Java绘图技术"><a href="#Java绘图技术" class="headerlink" title="Java绘图技术"></a>Java绘图技术</h2><ol><li>Component类提供了两个和绘图相关最重要的方法<ol><li>paint(Graphics g)绘制组件的外观</li><li>repaint()刷新组件的外观</li></ol></li><li>当组件第一次在屏幕显示的时候，程序会自动的调用paint()方法来绘制组件</li><li>以下情况paint()将会被调用<ol><li>窗口最小化再最大化</li><li>窗口的大小发生变化</li><li>repaint函数被调用</li></ol></li></ol><h2 id="程序进程线程"><a href="#程序进程线程" class="headerlink" title="程序进程线程"></a>程序进程线程</h2></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://ran-barry.github.io/2021/10/02/Java%E5%AD%A6%E4%B9%A0/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Ran-Barry"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hello"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2021/10/02/Java%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">Java学习</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-10-02 20:10:18" itemprop="dateCreated datePublished" datetime="2021-10-02T20:10:18+08:00">2021-10-02</time></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>7k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>6 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="Java常见基础知识"><a href="#Java常见基础知识" class="headerlink" title="Java常见基础知识"></a>Java常见基础知识</h2><h3 id="Java概述"><a href="#Java概述" class="headerlink" title="Java概述"></a>Java概述</h3><h4 id="JDK-JRE-JVM的关系"><a href="#JDK-JRE-JVM的关系" class="headerlink" title="JDK,JRE,JVM的关系"></a>JDK,JRE,JVM的关系</h4><p>JDK(Java Development Kits Java开发工具包) = JRE(Java Runtime Environment Java运行环境)+ java开发工具<br>JRE = JVM(Java Virtual Machine Java虚拟机) + 核心类库</p><h4 id="Java编写步骤"><a href="#Java编写步骤" class="headerlink" title="Java编写步骤"></a>Java编写步骤</h4><ol><li>编写java的源代码</li><li>javac 编译，得到对应的 .class 字节码文件</li><li>java 运行，本质就是把 .class 加载到jvm 运行</li></ol><h4 id="Java编写7个规范"><a href="#Java编写7个规范" class="headerlink" title="Java编写7个规范"></a>Java编写7个规范</h4><ol><li>类，方法的注释，使用javadoc的方式，即文档注释</li><li>非javadoc注释，往往是对代码的说明（给程序的维护者），说明如何修改，注意事项</li><li>使用tab，整体将代码右移，使用shift+tab整体左移</li><li>运算符和 = 的两边，给空格，代码看上去清楚</li><li>源码文件使用 utf-8编码</li><li>行宽字符不要超过 80</li><li>代码编程风格有两种风格</li></ol><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="变量使用注意"><a href="#变量使用注意" class="headerlink" title="变量使用注意"></a>变量使用注意</h4><ol><li>变量表示内存中的一个存储区域</li><li>该区域有自己的名称和类型</li><li>变量必须先声明，后使用，即有顺序</li><li>该区域的数据/值可以在同一类型范围内不断变化</li><li>变量在同一个作用域内不能重名</li><li>变量=变量名+值+数据类型</li></ol><h4 id="程序中-号使用"><a href="#程序中-号使用" class="headerlink" title="程序中 +号使用"></a>程序中 +号使用</h4><p>当左右两边都是数值型时，则做加法运算<br>当左右两边有一方为字符串，则做拼接运算<br>System.out.println(“100”+98);//10098<br>System.out.println(100+”98”);/10098</p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul><li>基本数据类型<ul><li>数值型<ul><li><a href="#Integer">整数类型(byte[1],short[2],int[4],long[8])</a></li><li><a href="#Float">浮点类型(float[4],double[8])</a></li></ul></li><li><a href="#Char">字符型</a><pre><code>char[2]
</code></pre></li><li><a href="#boolean">布尔型</a><pre><code>boolean[1]
</code></pre></li></ul></li><li>引用数据类型<ul><li>类(class)</li><li>接口(interface)</li><li>数组([])</li></ul></li></ul><h5 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a><span id="Integer">整数类型</span></h5><ol><li>Java各整数类型有固定的范围和字段长度，不受具体OS的影响，以保证java程序的可移植性</li><li>Java的整型常量默认为int型，声明long型变量须后加“l”或“L”</li><li>java程序中变量声明为int型，除非不足以表示大数，才使用long</li><li>bit：计算机中的最小存储单位。byte：计算机中基本存储单元</li></ol><h5 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a><span id="Float">浮点类型</span></h5><ol><li>与整数类型类似，Java浮点类型也有固定的范围和字段长度，不受具体OS的影响</li><li>Java的浮点型常量默认为double型，声明float型常量，须后加“f”或“F”</li><li>浮点型常量两种表示形式<ol><li>十进制数形式：如5.12 512.0f .512</li><li>科学计数法形式：5.12e2</li></ol></li><li>通常情况下，应该使用double型，因为它比float型更精确</li><li>浮点数使用陷阱：2.7 和 8.1/3 比较</li></ol><h5 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a><span id="Char">字符类型</span></h5><ol><li>字符常量是用单引号(‘’)括起来的单个字符</li><li>Java中还允许使用转义字符’\’来将其后的字符转变为特殊字符型常量</li><li>在java中，char的本质是一个整数，在输出时，是unicode码对应的字符</li><li>可以直接给char赋一个整数，然后输出时，会按照对应的unicode字符输出</li><li>char类型是可以进行运算的，相当于一个整数，因为它都对应有Unicode码</li></ol><h5 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a><span id="boolean">布尔类型</span></h5><ol><li>布尔类型也叫boolean类型，boolean类型数据只允许取值true和false，无null</li><li>boolean类型占1个字节</li><li>boolean类型适用于逻辑运算，一般用于程序流程控制</li></ol><h4 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h4><p>当java程序在进行赋值或运算时，精度小的类型自动转换为精度大的数据类型，为自动类型转换</p><h5 id="基本数据类型转换"><a href="#基本数据类型转换" class="headerlink" title="基本数据类型转换"></a>基本数据类型转换</h5><ol><li>有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算</li><li>当我们把精度大的数据类型赋值给精度小的数据类型时，就会报错，反之就会进行自动类型转换</li><li>(byte,short)和char之间不会相互自动转换</li><li>byte,short,char 他们三者可以计算，在计算时首先转换为int类型</li><li>boolean不参与转换</li><li>自动提示原则：表达式结果的类型自动提升为 操作数中最大的类型</li></ol><h5 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h5><ol><li>当进行数据的大小从大—&gt;小，就需要使用强制转换</li><li>强转符号只针对最近的操作数有效，往往会使用小括号提升优先级</li><li>char类型可以保存int的常量值，但不能保存int的变量值，需要强转</li><li>byte和short类型在进行运算时，当做int类型处理</li></ol><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><p>取模%的本质 a%b = a - a / b * b</p><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>&amp;&amp;与&amp;的区别(||与|类似)</p><ol><li>&amp;&amp;短路与：如果第一个条件为false，则第二个条件不会判断，最终结果为false</li><li>&amp;逻辑与：不管第一个条是否为false，第二个条件都要判断</li><li>开发中，基本使用&amp;&amp;</li></ol><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><blockquote><blockquote><blockquote><p>无符号右移 &gt;&gt; 算术右移 &lt;&lt; 算术左移</p></blockquote></blockquote></blockquote><h4 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h4><p>基本语法：条件表达式?表达式1：表达式2</p><p>表达式1和表达式2要为可以赋给接收变量的类型（或可以自动转换）</p><h4 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h4><h5 id="n进制转10进制"><a href="#n进制转10进制" class="headerlink" title="n进制转10进制"></a>n进制转10进制</h5><p>规则：从最低位开始，将每个位上的数据提取出来，乘以n的(位数-1)次方，然后求和</p><h5 id="10进制转n进制"><a href="#10进制转n进制" class="headerlink" title="10进制转n进制"></a>10进制转n进制</h5><p>规则：将该数不断除以n，直到商为0为止，然后将每步得到的余数倒过来，就是对应的n进制</p><h5 id="2进制转n进制"><a href="#2进制转n进制" class="headerlink" title="2进制转n进制"></a>2进制转n进制</h5><p>规则：从低位开始，将二进制数$sqrt(n)$位一组，转成对应的n进制数即可</p><h5 id="n进制转2进制"><a href="#n进制转2进制" class="headerlink" title="n进制转2进制"></a>n进制转2进制</h5><p>规则：将n进制数每一位，转成对应点一个$sqrt(n)$位二进制数即可</p><h4 id="原码反码补码"><a href="#原码反码补码" class="headerlink" title="原码反码补码"></a>原码反码补码</h4><ol><li>二进制的最高位是符号位：0表示正数，1表示负数</li><li>正数的原码，反码，补码都一样</li><li>负数的反码=它的原码符号位不变，其他位取反</li><li>负数的补码=它的反码+1，负数的反码=负数的补码-1</li><li>0的反码，补码都是0</li><li>java没有无符号数，换言之，java中的数都是有符号的</li><li>在计算机运算的时候，都是以补码的方式来运算的</li><li>但我们看运算结果的时候，要看它的原码</li></ol><h3 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h3><h4 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h4><p>程序从上到下逐行地执行，中间没有任何判断和跳转</p><h4 id="分支控制"><a href="#分支控制" class="headerlink" title="分支控制"></a>分支控制</h4><h5 id="if-else-分支结构"><a href="#if-else-分支结构" class="headerlink" title="if else 分支结构"></a>if else 分支结构</h5><h5 id="switch-分支结构"><a href="#switch-分支结构" class="headerlink" title="switch 分支结构"></a>switch 分支结构</h5><p>注意case穿透，当没有break时，会跳到下一个执行语句，一直下去</p><ol><li>表达式数据类型，应和case后的常量类型一致，或者是可以自动转成可以互相比较的类型，比如输入的是字符，而常量是int</li><li>switch中表达式的返回值必须是：(byte,short,int,char,enum,String)</li><li>case子句中的值必须是常量，而不能是变量</li><li>default子句是可选的，当没有匹配的case时，执行default</li><li>break语句用来在执行完一个case分支后使程序跳出switch语句块；如果没有写break，程序会顺序执行到switch结尾</li></ol><h4 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h4><h5 id="for循环控制"><a href="#for循环控制" class="headerlink" title="for循环控制"></a>for循环控制</h5><p>基本语法<br>for(循环变量初始化;循环条件;循环变量迭代){<br>循环操作(可以多条语句);<br>}</p><ol><li>循环条件是返回一个布尔值的表达式</li><li>for(;循环判断条件;)中的初始化和变量迭代可以写到其它地方，但是两边的分号不能省略</li><li>循环初始值可以有多条初始化语句，但要求类型一样，并且中间用逗号隔开，循环变量迭代也可以由多条变量迭代语句，中间用逗号隔开</li></ol><h5 id="while循环控制"><a href="#while循环控制" class="headerlink" title="while循环控制"></a>while循环控制</h5><p>基本语法<br>while(循环条件){<br>循环体(语句);<br>循环变量迭代;<br>}</p><h5 id="do-while循环控制"><a href="#do-while循环控制" class="headerlink" title="do-while循环控制"></a>do-while循环控制</h5><p>do{<br>循环体(语句);<br>循环变量迭代;<br>}while(循环条件)</p><h5 id="break"><a href="#break" class="headerlink" title="break"></a>break</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lable1:</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">4</span>;j++)&#123;</span><br><span class="line">  lable2:</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">2</span>)&#123;</span><br><span class="line">      <span class="keyword">break</span> lable1;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;i=&quot;</span>+i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>break 语句可以指定退出哪层</li><li>lable1是标签，由程序员指定</li><li>break后指定到哪个lable就退出到哪里</li><li>在实际的开发中，尽量不要使用标签</li><li>如果没有指定break，默认退出最近的循环体</li></ol><h3 id="数组、排序和查找"><a href="#数组、排序和查找" class="headerlink" title="数组、排序和查找"></a>数组、排序和查找</h3><h4 id="动态初始化"><a href="#动态初始化" class="headerlink" title="动态初始化"></a>动态初始化</h4><h4 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h4><p>语法：数据类型 数组名[] = {元素值，元素值，，，}</p><h4 id="数组使用注意事项和细节"><a href="#数组使用注意事项和细节" class="headerlink" title="数组使用注意事项和细节"></a>数组使用注意事项和细节</h4><ol><li>数组是多个相同类型数据的组合，实现对这些数据的统一管理</li><li>数组中的元素可以是任何数据类型，包括基本类型和引用类型，但是不能混用</li><li>数组创建后，如果没有赋值，有默认值int 0,short 0,byte 0,long 0,float 0.0,double 0.0,char \u0000,boolean false,String null</li><li>使用数组的步骤1.声明数组并开辟空间 2 给数组各个元素负债 3 使用数组</li><li>数组的下标是从0开始</li><li>数组下标必须是在指定范围内使用，否则报：下标越界异常</li><li>数组属引用类型，数组型数据是对象</li></ol><h4 id="数组赋值机制"><a href="#数组赋值机制" class="headerlink" title="数组赋值机制"></a>数组赋值机制</h4><ol><li>基本数据类型赋值，这个值就是具体的数据，而且相互不影响</li><li>数组在默认情况下是引用传递，赋的值是地址</li></ol><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><h5 id="内部排序"><a href="#内部排序" class="headerlink" title="内部排序"></a>内部排序</h5><p>指将需要处理的所有数据都加载到内部存储器中进行排序</p><h5 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h5><p>数据量过大，无法全部加载到内存中，需要借助外部存储进行排序</p><h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><h5 id="动态初始化-1"><a href="#动态初始化-1" class="headerlink" title="动态初始化"></a>动态初始化</h5><p>方式1 语法：类型[][] 数组名 = new 类型[大小][大小]</p><p>方式2<br>先声明：类型 数组名[][]<br>再定义数组名 = new 类型 [大小][大小]<br>赋值</p><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h4><p>Java内存的结构分析</p><ol><li>栈：一般存放基本数据类型（局部变量）</li><li>堆：存放对象</li><li>方法区：常量池，类加载信息</li></ol><p>形参列表</p><ol><li>一个方法可以有0个参数，也可以有多个参数，中间用逗号隔开</li><li>参数类型可以为任意类型，包含基本类型或引用类型</li><li>调用带参数的方法时，一定对应着参数列表传入相同类型或兼容类型的参数</li><li>方法定义时的参数统称为形式参数，简称形参；方法调用时的传入参数称为实际参数，简称实参，实参和形参的类型要一致或兼容、个数、顺序必须一致</li></ol><p>方法调用细节</p><ol><li>同一个类中的方法调用：直接调用即可</li><li>跨类中的方法A类调用B类方法：需要通过对象名调用</li><li>跨类的方法调用和方法的访问修饰符相关</li></ol><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><h5 id="递归重要规则"><a href="#递归重要规则" class="headerlink" title="递归重要规则"></a>递归重要规则</h5><ol><li>执行一个方法时，就创建一个新的受保护的独立空间（栈空间）</li><li>方法的局部变量是独立的，不会相互影响，比如n变量</li><li>如果方法中使用的是引用类型变量，就会共享该引用类型的数据</li><li>递归必须向退出递归的条件逼近，否则就是无限递归</li><li>当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕</li></ol><h4 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h4><p>同一个类中，多个同名方法的存在，但要求形参列表不一致</p><p>重载的好处</p><ol><li>减轻了起名的麻烦</li></ol><p>注意事项</p><ol><li>方法名必须相同</li><li>参数列表必须不同</li><li>返回类型无要求</li></ol><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><ol><li>可变参数的实参可以为0个或任意多个</li><li>可变参数的实参可以为数组</li><li>可变参数的本质就是数组</li><li>可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后</li><li>一个形参列表中只能出现一个可变参数</li></ol><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><p>构造方法又叫构造器，是类的一种特殊的方法，它的主要作用是完成对新对象的初始化</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol><li>方法名和类名相同</li><li>没有返回值</li><li>在创建对象时，系统会自动的调用该类的构造器完成对对象的初始化</li></ol><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ol><li>一个类可以定义多个不同的构造器，即构造器重载</li><li>构造器名和类名要相同</li><li>构造器没有返回值</li><li>构造器是完成对象的初始化，并不是创建对象</li><li>在创建对象时，系统自动的调用该类的构造方法</li><li>如果程序员没有定义构造器，系统会自动给类生成一个默认无参构造方法</li><li>一旦定义了自己的构造器，默认的构造器就覆盖了，就不能再使用默认的无参构造器，除非显式的定义一下</li></ol><h4 id="对象创建流程"><a href="#对象创建流程" class="headerlink" title="对象创建流程"></a>对象创建流程</h4><ol><li>加载类信息，只会加载一次</li><li>在堆中分配空间(地址)</li><li>完成对象初始化（默认初始化，显式初始化，构造器初始化）</li><li>对象在堆中的地址，返回给p(p是对象名,也可理解为对象的引用)</li></ol><h4 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h4><ol><li>this关键字可以用来访问本类的属性、方法、构造器</li><li>this用于区分当前类的属性和局部布局</li><li>访问成员方法的语法：this.方法名</li><li>访问构造器语法：this(参数列表)；只能在构造器中使用(即只能在构造器中访问另外一个构造器，必须放在第一条语句)</li><li>this不能在类定义的外部使用，只能在类定义的方法中使用</li></ol><h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><p>三大作用</p><ol><li>区分相同名字的类</li><li>当类很多时，可以很好的管理类</li><li>控制访问范围</li></ol><p>命名规则：只能包含数字、字母、下划线、小圆点，不能用数字开头，不能是关键字或保留字</p><p>命名规范：com.公司名.项目名.业务模块名</p><h4 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h4><p>公开级别：用public修饰<br>受保护级别：用protected修饰，对子类和同一个包中的类公开<br>默认级别：没有修饰符号，向同一个包的类公开<br>私有级别：用private修饰，只有类本身可以访问，不对外公开<br><img src="/2021/10/02/Java%E5%AD%A6%E4%B9%A0/访问修饰符.png" alt="photo"></p><ol><li>修饰符可以用来修饰类中的属性，成员方法以及类</li><li>只有默认的和public才能修饰类，并且遵循上述访问权限的特点</li><li>成员方法的访问规则和属性完全一样</li></ol><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装就是把抽象出的数据[属性]和对数据的操作[方法]封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作[方法]，才能对数据进行操作</p><h5 id="封装的理解与好处"><a href="#封装的理解与好处" class="headerlink" title="封装的理解与好处"></a>封装的理解与好处</h5><ol><li>隐藏实现细节</li><li>可以对数据进行验证，保证安全合理</li></ol><h5 id="封装实现步骤"><a href="#封装实现步骤" class="headerlink" title="封装实现步骤"></a>封装实现步骤</h5><ol><li>将属性进行私有化private 【不能直接修改属性】</li><li>提供一个公共的(public)set方法，用于对属性判断并赋值</li><li>提供一个公共的get方法，用于获取属性的值</li></ol><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><h5 id="继承基本语法"><a href="#继承基本语法" class="headerlink" title="继承基本语法"></a>继承基本语法</h5><p>class 子类 extends 父类{<br>}<br>子类就会自动拥有父类定义的属性和方法<br>父类又叫超类，基类<br>子类又叫派生类</p><h5 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h5><ol><li>子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问，但是私有属性不能在子类直接访问，要通过父类提供公共的方法去访问</li><li>子类必须调用父类的构造器，完成父类的初始化</li><li>当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参的构造器，则必须在子类的构造器中用super去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过</li><li>如果希望指定去调用父类的某个构造器，则显式的调用一下</li><li>super在使用时，需要放在构造器第一行</li><li>super()和this()都只能放在构造器第一行，因此这两个方法不能共存在一个构造器</li><li>java所有类都是Object类的子类</li><li>父类构造器的调用不限于直接父类！将一直往上追溯到Object类</li><li>子类最多只能继承一个父类（指直接继承），即java中是单继承机制</li><li>不能滥用继承，子类和父类之间必须满足is-a的逻辑关系</li></ol><h4 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h4><ol><li>访问父类的属性，但不能访问父类的private属性 super.属性名</li><li>访问父类的方法，不能访问父类的private方法 super.方法名(参数列表)</li><li>访问父类的构造器：super(参数列表);只能放在构造器的第一句</li><li>当子类中有和父类中的成员(属性和方法)重名时，为了访问父类的成员，必须通过super。如果没有重名，使用super、this、直接访问时一样的效果</li><li>super的访问不限于直接父类，如果爷爷类和本类中有同名的的成员，也可以使用super去访问爷爷类的成员；如果多个基类中都有同名的成员，使用super访问遵循就近原则</li></ol><h4 id="方法重写-覆盖-override"><a href="#方法重写-覆盖-override" class="headerlink" title="方法重写/覆盖(override)"></a>方法重写/覆盖(override)</h4><ol><li>子类的方法的形参列表，方法名称，要和父类方法的参数，方法名称完全一样</li><li>子类方法的返回类型和父类方法返回类型一样，或者是父类返回类型的子类</li><li>子类方法不能缩小父类方法的访问权限</li></ol><p><img src="/2021/10/02/Java%E5%AD%A6%E4%B9%A0/方法重写和重载.png" alt="photo"></p><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><h5 id="多态的具体实现"><a href="#多态的具体实现" class="headerlink" title="多态的具体实现"></a>多态的具体实现</h5><ol><li>方法的多态。重写和重载就体现多态</li><li>对象的多态<ol><li>一个对象的编译类型和运行类型可以不一致</li><li>编译类型在定义对象时，就确定了，不能改变</li><li>运行类型是可以改变的</li><li>编译类型看定义时 = 号 的左边，运行类型看 = 号的 右边</li></ol></li></ol><h5 id="多态细节"><a href="#多态细节" class="headerlink" title="多态细节"></a>多态细节</h5><p>多态的前提是：两个对象存在继承关系<br>多态的向上转型</p><ol><li>本质：父类的引用指向了子类的对象</li><li>语法：父类类型 引用名 = new 子类类型();</li><li>特点：编译类型看左边，运行类型看右边。可以调用父类中的所有成员，不能调用子类中的特有成员；最终运行效果看子类的具体实现</li></ol><p>多态的向下转型</p><ol><li>语法：子类类型 引用名 = （子类类型）父类引用;</li><li>只能强转父类的引用，不能强转父类的对象</li><li>要求父类的引用必须指向的是当前目标类型的对象</li><li>可以调用子类类型中所有成员</li></ol><p>属性没有重写之说，属性的值看编译类型<br>instanceOf比较操作符，用于判断对象的运行类型是否为xx类型或xx类型的子类型</p><h5 id="动态绑定机制"><a href="#动态绑定机制" class="headerlink" title="动态绑定机制"></a>动态绑定机制</h5><ol><li>当调用对象方法时的时候，该方法会和对象的内存地址/运行类型绑定</li><li>当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用</li></ol><h5 id="多态应用"><a href="#多态应用" class="headerlink" title="多态应用"></a>多态应用</h5><p>多态数组：数组定义类型为父类类型，里面保存的实际元素类型为子类类型<br>多态参数：方法定义的形参类型为父类类型，实参类型运行子类类型</p><h4 id="Object类详解"><a href="#Object类详解" class="headerlink" title="Object类详解"></a>Object类详解</h4><h5 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h5><ol><li>==：既可以判断基本类型，又可以判断引用类型</li><li>==：如果判断基本类型，判断的是值是否相等</li><li>==：如果判断引用类型，判断的是地址是否相等，即判定是不是同一个对象</li><li>equals：是Object类中的方法，只能判断引用类型</li><li>equals默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等</li></ol><h5 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h5><ol><li>提高具有哈希结构的容器的效率</li><li>两个引用，如果指向的是同一个对象，则哈希值肯定是一样的</li><li>两个引用，如果指向的是不同对象，则哈希值是不一样的</li><li>哈希值主要根据地址号来的！，不能完全将哈希值等价于地址</li></ol><h5 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h5><p>默认返回：全类名+@+哈希值的十六进制，子类往往重写toString方法，用于返回对象的属性信息</p><h5 id="finalize方法"><a href="#finalize方法" class="headerlink" title="finalize方法"></a>finalize方法</h5><ol><li>当对象被回收时，系统自动调用该对象的finalize方法，子类可以重写该方法，做一下释放资源的操作</li><li>什么时候回收：当某个对象没有任何引用时，则jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁对象，在销毁该对象前，会先调用finalize方法</li><li>垃圾回收机制的调用，是由系统来决定，也可以通过System.gc()主动触发垃圾回收机制</li></ol><h5 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h5><p>在断点调试过程中，是运行状态，是以对象的运行类型来执行的</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://ran-barry.github.io/2021/06/11/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Ran-Barry"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hello"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2021/06/11/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6/" class="post-title-link" itemprop="url">高等数学-多元函数微分学</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-06-11 20:34:27" itemprop="dateCreated datePublished" datetime="2021-06-11T20:34:27+08:00">2021-06-11</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">数学</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>3k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>3 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="重极限、连续、偏导数、全微分"><a href="#重极限、连续、偏导数、全微分" class="headerlink" title="重极限、连续、偏导数、全微分"></a>重极限、连续、偏导数、全微分</h2><h3 id="重极限"><a href="#重极限" class="headerlink" title="重极限"></a>重极限</h3><h4 id="求重极限常用方法"><a href="#求重极限常用方法" class="headerlink" title="求重极限常用方法"></a>求重极限常用方法</h4><ol><li>利用极限性质（四则运算法则，夹逼定理）</li><li>消去分母中极限为零的因子（有理化，等价无穷小代换）</li><li>利用无穷小量与有界变量之积的无穷小量</li></ol><p><strong>证明重极限不存在常用方法</strong><br>沿两种不同路径极限不同（通常可取过($x_0,y_0$)的直线)</p><h3 id="连续"><a href="#连续" class="headerlink" title="连续"></a>连续</h3><p>若$\lim\limits_{\substack{x\rightarrow x_0 \\y\rightarrow y_0}}f(x,y)=f(x_0,y_0)$，则称$f(x,y)$在$(x_0,y_0)$处连续</p><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ol><li>连续函数的和、差、积、商（分母不为零）及复合仍连续</li><li>基本初等函数在其定义域内连续；初等函数在其定义区域内连续</li><li>有界闭区域上连续函数的性质<ol><li>有界性：若$f(x,y)$在有界闭区域D上连续，则$f(x,y)$在D上有界</li><li>最值性：若$f(x,y)$在有界闭区域D上连续，则$f(x,y)$在D上必有最大值和最小值</li><li>介值性：若$f(x,y)$在有界闭区域D上连续，则$f(x,y)$在D上可取到介于最小值与最大值之间的任何值</li></ol></li></ol><h3 id="偏导数"><a href="#偏导数" class="headerlink" title="偏导数"></a>偏导数</h3><h3 id="全微分"><a href="#全微分" class="headerlink" title="全微分"></a>全微分</h3><h4 id="以下四条等价"><a href="#以下四条等价" class="headerlink" title="以下四条等价"></a>以下四条等价</h4><ol><li>$\Delta z=f(x_0+\Delta x,y_0+\Delta y)-f(x_0,y_0)=A\Delta x+B\Delta y+o(\rho)$</li><li>$\lim\limits_{\substack{\Delta x\rightarrow0 \\ \Delta y\rightarrow0}}\frac{[f(x_0+\Delta x,y_0+\Delta y)-f(x_0,y_0)]-[A\Delta x+B\Delta y]}{\sqrt{(\Delta x)^2+(\Delta y)^2}}=0$</li><li>$\Delta z=f(x,y)-f(x_0,y_0)=A(x-x_0)+B(y-y_0)+o(\rho)$</li><li>$\lim\limits_{\substack{x\rightarrow x_0\\y\rightarrow y_0}}\frac{[f(x,y)-f(x_0,y_0)]-[A(x-x_0)+B(y-y_0)]}{\sqrt{(x-x_0)^2+(y-y_0)^2}}=0$</li></ol><h4 id="可微性判定"><a href="#可微性判定" class="headerlink" title="可微性判定"></a>可微性判定</h4><ol><li>必要条件：$f’_x(x_0,y_0)$与$f’_y(x_0,y_0)$都存在</li><li>充分条件：$f’_x(x_0,y_0)$和$f’_y(x_0,y_0)$在$(x_0,y_0)$连续</li><li>用定义判定<ol><li>$f’_x(x_0,y_0)$和$f’_y(x_0,y_0)$是否都存在</li><li>$\lim\limits_{\substack{\Delta x\rightarrow0 \\ \Delta y\rightarrow0}}\frac{[f(x_0+\Delta x,y_0+\Delta y)-f(x_0,y_0)]-[f’_x(x_0,y_0)\Delta x+f’_y(x_0,y_0)\Delta y]}{\sqrt{(\Delta x)^2+(\Delta y)^2}}$是否为零</li></ol></li></ol><h4 id="连续、可导、可微的关系"><a href="#连续、可导、可微的关系" class="headerlink" title="连续、可导、可微的关系"></a>连续、可导、可微的关系</h4><p><img src="/2021/06/11/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6/连续、可导、可微关系.png" alt="photo"></p><h2 id="偏导数与全微分的计算"><a href="#偏导数与全微分的计算" class="headerlink" title="偏导数与全微分的计算"></a>偏导数与全微分的计算</h2><h3 id="复合函数求导"><a href="#复合函数求导" class="headerlink" title="复合函数求导"></a>复合函数求导</h3><p>设$u=u(x,y),v=v(x,y)$可导，$z=f(u,v)$在相应点有连续一阶偏导数，则</p><script type="math/tex;mode=display">\frac{\delta z}{\delta x}=\frac{\delta f}{\delta u}\frac{\delta u}{\delta x}+\frac{\delta f}{\delta v}\frac{\delta v}{\delta x} \\ \frac{\delta z}{\delta y}=\frac{\delta f}{\delta u}\frac{\delta u}{\delta y}+\frac{\delta f}{\delta v}\frac{\delta v}{\delta y}\\</script><h3 id="隐函数求导法"><a href="#隐函数求导法" class="headerlink" title="隐函数求导法"></a>隐函数求导法</h3><p>由一个方程所确定的隐函数<br>设$F(x,y,z)$有连续一阶偏导数，$F’_z\ne0,z=z(x,y)$由$F(x,y,z)=0$所确定<br><strong>方法：</strong></p><ol><li>公式：$\frac{\delta z}{\delta x}=-\frac{F’_x}{F’_z},\frac{\delta z}{\delta y}=-\frac{F’_y}{F’_z}$</li><li>等式两边求导$F’_x+F’_z\frac{\delta z}{\delta x}=0,F’_y+F’_z\frac{\delta z}{\delta y}=0$</li><li>利用微分形式不变性：$F’_xdx+F’_ydy+F’_zdz=0$</li></ol><p>注：<br>若$p(x,y)$和$Q(x,y)$有一阶连续偏导数，且$P(x,y)dx+Q(x,y)dy$是某一函数的全微分，则$\frac{\delta P}{\delta y}=\frac{\delta Q}{\delta x}$</p><h2 id="极值与最值"><a href="#极值与最值" class="headerlink" title="极值与最值"></a>极值与最值</h2><h3 id="无条件极值"><a href="#无条件极值" class="headerlink" title="无条件极值"></a>无条件极值</h3><p><strong>极值的必要条件</strong><br>设$z=f(x,y)$在点$(x_0,y_0)$存在偏导数，且$(x_0,y_0)$为$f(x,y)$的极值点，则$f’_x(x_0,y_0)=0,f’_y(x_0,y_0)=0$</p><p><strong>极值的充分条件</strong><br>设$z=f(x,y)$在点$P_0(x_0,y_0)$的某邻域内有二阶连续偏导数，又$f’_x(x_0,y_0),f’_y(x_0,y_0)=0$，记$A=f’’_{xx}(x_0,y_0),B=f’’_{xy}(x_0,y_0),C=f’’_{yy}(x_0,y_0)$<br>有下列结论</p><ol><li>若$AC-B^2&gt;0,$则$(x_0,y_0)$为f(x,y)的极值点<ol><li>A&lt;0,则$(x_0,y_0)$为f(x,y)的极大值点</li><li>A&gt;0,则$(x_0,y_0)$为f(x,y)的极小值点</li></ol></li><li>若$AC-B^2&lt;0$，则$(x_0,y_0)$不为f(x,y)的极值点</li><li>若$AC-B^2=0$，则$(x_0,y_0)$可能为f(x,y)的极值点，也可能不为f(x,y)的极值点</li></ol><p>求具有二阶连续偏导数二元函数$z=f(x,y)$极值的一般步骤为：<br>(1) 求出f(x,y)的驻点$P_1,\dotsb,P_k$<br>(2) 利用极值的充分条件判定驻点$P_i$是否为极值点<br>二元函数$z=f(x,y)$在偏导数不存在的点也可能取到极值（如$f(x,y)=\sqrt{x^2+y^2}$，而这种点是否取得极值一般用极值定义判定</p><h3 id="条件极值及拉格朗日乘数法"><a href="#条件极值及拉格朗日乘数法" class="headerlink" title="条件极值及拉格朗日乘数法"></a>条件极值及拉格朗日乘数法</h3><p>求$z=f(x,y)$在条件$\varphi(x,y)=0$下的条件极值的一般方法：<br>(1) 构造拉格朗日函数$F(x,y,\lambda)=f(x,y)+\lambda\varphi(x,y)$；<br>(2) 将$F(x,y,\lambda)$分别对$x,y,\lambda$求偏导数，构造方程组</p><script type="math/tex;mode=display">\begin{cases}
   f'_x(x,y)+\lambda\varphi'_x(x,y)=0 \\
   f'_y(x,y)+\lambda\varphi'_y(x,y)=0 \\
   \varphi(x,y)=0 \\
\end{cases}</script><h3 id="最大最小值"><a href="#最大最小值" class="headerlink" title="最大最小值"></a>最大最小值</h3><p>求连续函数$f(x,y)$在有界闭区域D上的最大最小值三部曲<br>(1) 求f(x,y)在D内部可能的极值点<br>(2) 求f(x,y)在D的边界上的最大最小值<br>(3) 比较</p><p>应用题</p><p>点到直线的距离公式:<br>直线为$Ax+By+C=0,A,B\ne0$，则直线外一点$(x_0,y_0)$到该直线最短的距离为$d=\frac{Ax_0+By_0+C}{\sqrt{A^2+B^2}}$</p><p>三角形面积公式：海伦公式<br>设三角形三边为x,y,z,周长为2p，则面积为$S=\sqrt{p(p-a)(p-b)(p-c)}$</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://ran-barry.github.io/2021/06/11/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Ran-Barry"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hello"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2021/06/11/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86/" class="post-title-link" itemprop="url">高等数学-二重积分</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-06-11 15:59:16" itemprop="dateCreated datePublished" datetime="2021-06-11T15:59:16+08:00">2021-06-11</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">数学</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>1.4k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>1 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="二重积分的概念"><a href="#二重积分的概念" class="headerlink" title="二重积分的概念"></a>二重积分的概念</h2><script type="math/tex;mode=display">\iint_Df(x,y)d\sigma=\lim\limits_{\lambda\rightarrow0}\sum_{i=1}^nf(\xi_i,\eta_i)\Delta\sigma_i</script><h2 id="二重积分的几何意义"><a href="#二重积分的几何意义" class="headerlink" title="二重积分的几何意义"></a>二重积分的几何意义</h2><p>二重积分$\iint_Df(x,y)d\sigma$是一个数。当$f(x,y)\ge0$时，其值等于以积分域D为底，以曲面$z=f(x,y)$为曲顶的曲顶柱体的体积</p><h2 id="二重积分的性质"><a href="#二重积分的性质" class="headerlink" title="二重积分的性质"></a>二重积分的性质</h2><h3 id="不等式性质"><a href="#不等式性质" class="headerlink" title="不等式性质"></a>不等式性质</h3><ol><li>若在D上$f(x,y)\le g(x,y)$，则$\iint_Df(x,y)d\sigma\le\iint_Dg(x,y)d\sigma$</li><li>若$f(x,y)$在D上连续，则$mS\le\iint_Df(x,y)d\sigma\le MS$，其中m和M分别为$f(x,y)$在D上的最小值和最大值，S为积分域D的面积</li><li>$|\iint_Df(x,y)d\sigma|\le\iint_D|f(x,y)|d\sigma$</li></ol><h3 id="积分中值定理"><a href="#积分中值定理" class="headerlink" title="积分中值定理"></a>积分中值定理</h3><p>若$f(x,y)$在D上连续，则$\iint_Df(x,y)d\sigma=f(\xi,\eta)S$，其中$(\xi,\eta)\in D,S$为积分域D的面积</p><h2 id="二重积分的计算"><a href="#二重积分的计算" class="headerlink" title="二重积分的计算"></a>二重积分的计算</h2><h3 id="利用直角坐标计算"><a href="#利用直角坐标计算" class="headerlink" title="利用直角坐标计算"></a>利用直角坐标计算</h3><p><strong>先y后x</strong><br>若积分域D是X型区域，即积分域D可以用不等式$y_1(x)\le y\le y_2(x),a\le x\le b$来表示，则<br><img src="/2021/06/11/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86/1-1.png" alt="photo"></p><script type="math/tex;mode=display">\iint_Df(x,y)d\sigma=\int_a^bdx\int_{y_1(x)}^{y_2(x)}f(x,y)dy</script><p><strong>先x后y</strong><br>若积分域D是Y型区域，即积分域D可以用不等式$x_1(y)\le x\le x_2(y),c\le y\le d$来表示，则<br><img src="/2021/06/11/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86/1-2.png" alt="photo"></p><script type="math/tex;mode=display">\iint_Df(x,y)d\sigma=\int_c^ddy\int_{x_1(y)}^{x_2(y)}f(x,y)dx</script><h3 id="利用极坐标计算"><a href="#利用极坐标计算" class="headerlink" title="利用极坐标计算"></a>利用极坐标计算</h3><p><strong>先r后$\theta$</strong><br>若积分域D可以用不等式$r_1(\theta)\le r\le r_2(\theta),\alpha\le\theta\le\beta$，来表示，则<br><img src="/2021/06/11/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86/2-1.png" alt="photo"></p><script type="math/tex;mode=display">\iint_Df(x,y)d\sigma=\int_\alpha^\beta d\theta\int_{r_1(\theta)}^{r_2(\theta)}f(r\cos\theta,r\sin\theta)rdr</script><h3 id="利用对称性和奇偶性计算"><a href="#利用对称性和奇偶性计算" class="headerlink" title="利用对称性和奇偶性计算"></a>利用对称性和奇偶性计算</h3><p>(1) 若积分域D关于y轴对称，f(x,y)关于x有奇偶性，则：</p><script type="math/tex;mode=display">\iint_Df(x,y)d\sigma=\begin{cases}
    2\iint_{D_{x\ge0}}f(x,y)d\sigma,&f(-x,y)=f(x,y) \\
    0,&f(-x,y)=-f(x,y)
\end{cases}</script><p>(1) 若积分域D关于x轴对称，f(x,y)关于y有奇偶性，则：</p><script type="math/tex;mode=display">\iint_Df(x,y)d\sigma=\begin{cases}
    2\iint_{D_{y\ge0}}f(x,y)d\sigma,&f(x,-y)=f(x,y) \\
    0,&f(x,-y)=-f(x,y)
\end{cases}</script><h3 id="利用变量对称性计算"><a href="#利用变量对称性计算" class="headerlink" title="利用变量对称性计算"></a>利用变量对称性计算</h3><p>二重积分$\iint_Df(x,y)d\sigma$的积分域D是点(x,y)的集合，记为$D_{(x,y)}$，类似一元定积分的值与积分变量用什么记号无关，则<br><img src="/2021/06/11/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86/3-1.png" alt="photo"></p><script type="math/tex;mode=display">\iint_{D_{(x,y)}}f(x,y)d\sigma=\iint_{D_{(y,x)}}f(y,x)d\sigma</script><p>即把二重积分的被积函数f(x,y)及积分域$D_{(x,y)}$中的x和y对调，积分值不变</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://ran-barry.github.io/2021/05/31/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Ran-Barry"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hello"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2021/05/31/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/" class="post-title-link" itemprop="url">高等数学-常微分方程</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-05-31 13:32:05" itemprop="dateCreated datePublished" datetime="2021-05-31T13:32:05+08:00">2021-05-31</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">数学</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>3.6k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>3 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="一阶微分方程的种类与解法"><a href="#一阶微分方程的种类与解法" class="headerlink" title="一阶微分方程的种类与解法"></a>一阶微分方程的种类与解法</h2><div class="table-container"><table><thead><tr><th>种类</th><th>通解公式或解法</th></tr></thead><tbody><tr><td>可分离变量的微分方程<br>$\frac{dy}{dx}=f(x,y)$,其中$f(x,y)=\varPhi_1(x)\varPhi_2(y)$</td><td>解法：<br>$\frac{dy}{dx}=f(x,y)\implies\frac{dy}{dx}=\varPhi_1(x)\varPhi_2(y)$<br>$\implies\frac{dy}{\varPhi_2(y)}=\varPhi_1(x)dx$<br>$\implies\int\frac{dy}{\varPhi_2(y)}=\int\varPhi_1(x)dx+C$</td></tr><tr><td>齐次微分方程<br>$\frac{dy}{dx}=f(x,y)$，其中$f(x,y)=\varPhi(\frac{y}{x})$</td><td>解法：<br>$\frac{dy}{dx}=f(x,y)\implies\frac{dy}{dx}=\varPhi(\frac{y}{x})$<br>$\xRightarrow{\frac{y}{x}=u} u+x\frac{du}{dx}=\varPhi(u)$<br>$\implies \int \frac{du}{\varPhi(u)-u}=\int \frac{dx}{x}+C$</td></tr><tr><td>一阶齐次线性微分方程<br>$\frac{dy}{dx}+P(x)y=0$</td><td>通解公式：<br>$y = Ce^{-\int P(x)dx}$(其中C为任意常数)</td></tr><tr><td>一阶非齐次线性微分方程<br>$\frac{dy}{dx}+P(x)y=Q(x)$</td><td>通解公式：<br>$y=[\int Q(x)e^{\int P(x)dx}dx+C]e^{-\int P(x)dx}$(其中C为任意常数)</td></tr></tbody></table></div><h2 id="可降阶的高阶微分方程及解法"><a href="#可降阶的高阶微分方程及解法" class="headerlink" title="可降阶的高阶微分方程及解法"></a>可降阶的高阶微分方程及解法</h2><div class="table-container"><table><thead><tr><th>种类</th><th>解法</th></tr></thead><tbody><tr><td>$y^{(n)}=f(x)$</td><td>$y^{(n)}=f(x)$进行n次不定积分</td></tr><tr><td>$f(x,y’,y’’)=0$</td><td>令$y’=p,y’’=\frac{dp}{dx},f(x,y’,y’’)=0$化为$f(x,p,\frac{dp}{dx})=0$</td></tr><tr><td>$f(y,y’,y’’)=0$</td><td>$y’=p,y’’=\frac{dy}{dx}\cdot\frac{dp}{dy}=p\frac{dp}{dy},f(y,y’,y’’)=0$化为$f(y,p,p\frac{dp}{dy})=0$</td></tr></tbody></table></div><h2 id="高阶线性微分方程理论"><a href="#高阶线性微分方程理论" class="headerlink" title="高阶线性微分方程理论"></a>高阶线性微分方程理论</h2><p><strong>n阶齐次线性微分方程</strong><br>形如</p><script type="math/tex;mode=display">y^{n}+a_1y^{n-1}+...+a_{n-1}y'+a_n(x)y=0 \tag{1}</script><p><strong>n阶非齐次线性微分方程</strong><br>形如</p><script type="math/tex;mode=display">y^{n}+a_1y^{n-1}+...+a_{n-1}y'+a_n(x)y=f(x) \tag{2}</script><p>若$f(x)=f_1(x)+f_2(x)$,则(2)可分解为如下两个方程：</p><script type="math/tex;mode=display">y^{n}+a_1y^{n-1}+...+a_{n-1}y'+a_n(x)y=f_1(x) \tag{2.1}</script><script type="math/tex;mode=display">y^{n}+a_1y^{n-1}+...+a_{n-1}y'+a_n(x)y=f_2(x) \tag{2.2}</script><h3 id="高阶线性微分方程解的结构"><a href="#高阶线性微分方程解的结构" class="headerlink" title="高阶线性微分方程解的结构"></a>高阶线性微分方程解的结构</h3><ol><li>设$\varPhi_1(x),\varPhi_2(x),…,\varPhi_s(x)$为(1)的一组解，则$k_1\varPhi_1(x)+k_2\varPhi_2(x)+…+k_s\varPhi_s(x)$也为方程(1)的解</li><li>若$\varPhi_1(x),\varPhi_2(x)$分别为(1)、(2)的两个解，则$\varPhi_1(x)+\varPhi_2(x)$为(2)的一个解</li><li>若$\varPhi_1(x),\varPhi_2(x)$为(2)的两个解，则$\varPhi_1(x)-\varPhi_2(x)$为(1)的解</li><li>若$\varPhi_1(x),\varPhi_2(x)$分别为(2.1)及(2.2)的两个解，则$\varPhi_1(x)+\varPhi_2(x)$为(2)的解</li><li>若$\varPhi_1(x),\varPhi_2(x),…,\varPhi_s(x)$为(2)的一组解，则$k_1\varPhi_1(x)+k_2\varPhi_2(x)+…+k_s\varPhi_s(x)$为(2)的解的充分必要条件是$k_1+k_2+…+k_s=1$</li><li>若$\varPhi_1(x),\varPhi_2(x),…,\varPhi_s(x)$为(2)的一组解，则$k_1\varPhi_1(x)+k_2\varPhi_2(x)+…+k_s\varPhi_s(x)$为(1)的解的充分必要条件是$k_1+k_2+…+k_s=0$</li><li>设$\varPhi_1(x),\varPhi_2(x),…,\varPhi_n(x)$为(1)的n个线性无关解，则$k_1\varPhi_1(x)+k_2\varPhi_2(x)+…+k_n\varPhi_n(x)$为(1)的通解</li><li>若$\varPhi_1(x),\varPhi_2(x),…,\varPhi_n(x)$为(1)的n个线性无关解，$\varPhi_0(x)$为(2)的一个特解，则$k_1\varPhi_1(x)+k_2\varPhi_2(x)+…+k_n\varPhi_n(x)+\varPhi_0(x)$为(2)的通解</li></ol><h3 id="二阶常系数齐次线性微分方程及解法"><a href="#二阶常系数齐次线性微分方程及解法" class="headerlink" title="二阶常系数齐次线性微分方程及解法"></a>二阶常系数齐次线性微分方程及解法</h3><div class="table-container"><table><thead><tr><th>方程形式</th><th>$y’’+py’+qy=0$(其中p，q为常数)</th></tr></thead><tbody><tr><td>特征方程</td><td>$\lambda^2+p\lambda+q=0$</td></tr><tr><td>$\Delta=p^2-4q$的情况</td><td>$y’’+py’+qy=0$的通解</td></tr><tr><td>$\Delta&gt;0$</td><td>$y=C_1e^{\lambda_1x}+C_2^{\lambda_2x}$($C_1,C_2$为任意常数)</td></tr><tr><td>$\Delta=0$</td><td>$y=(C_1+C_2x)e^{\lambda_1x}$($C_1,C_2$为任意常数)</td></tr><tr><td>$\Delta&lt;0$</td><td>$\lambda_1=\alpha+i\beta,\lambda_2=\alpha-i\beta$<br>$y=e^{\alpha x}(C_1\cos\beta x+C_2\sin\beta x)$</td></tr></tbody></table></div><h3 id="三阶常系数齐次线性微分方程及解法"><a href="#三阶常系数齐次线性微分方程及解法" class="headerlink" title="三阶常系数齐次线性微分方程及解法"></a>三阶常系数齐次线性微分方程及解法</h3><p>对$y’’’+py’’+qy’+ry=0$(其中p，q，r为常数)，特征方程为</p><script type="math/tex;mode=display">\lambda^3+p\lambda^2+q\lambda+r=0</script><p>(1) 若特征值$\lambda_1,\lambda_2,\lambda_3$为实单根，则通解为$y=C_1e^{\lambda_1x}+C_2^{\lambda_2x}+C_3e^{\lambda_3x}$</p><p>(2) 若特征值$\lambda_1=\lambda_2\not=\lambda_3$为实根，则通解为$y=(C_1+C_2x)e^{\lambda_1x}+C_3e^{\lambda_3x}$</p><p>(3) 若特征值$\lambda_1=\lambda_2=\lambda_3$为实根，则通解为$y=(C_1+C_2x+C_3x^2)e^{\lambda_1x}$</p><p>(4) 若$\lambda_{1,2}=\alpha\pm i\beta,\lambda_3\in R$，则通解为$y=e^{\alpha x}(C_1\cos\beta x+C_2\sin\beta x))+C_3e^{\lambda_3x}$</p><h3 id="二阶常系数非齐次线性微分方程的特解求法"><a href="#二阶常系数非齐次线性微分方程的特解求法" class="headerlink" title="二阶常系数非齐次线性微分方程的特解求法"></a>二阶常系数非齐次线性微分方程的特解求法</h3><p>类型一：$f(x)=e^{kx}P_n(x)$，其中$P_n(x)$为n次多项式</p><p>(1) 当$k\not ={\lambda_1}$且$k\not ={\lambda_2}$时，令特解$y_0(x)=(a_0+a_1x+…+a_nx^n)e^{kx}=Q(x)e^{kx}$</p><p>(2) 当$k={\lambda_1}$且$k\not ={\lambda_2}$时，令特解$y_0(x)=x(a_0+a_1x+…+a_nx^n)e^{kx}=xQ(x)e^{kx}$</p><p>(3) 当$k={\lambda_1}={\lambda_2}$时，令特解$y_0(x)=x^2(a_0+a_1x+…+a_nx^n)e^{kx}=x^2Q(x)e^{kx}$</p><p>类型二：$f(x)=e^{\alpha x}[P_m(x)cos\beta x+P_s(x)sin\beta x]$，其中$P_m,P_s(x)$分别为m及s次多项式</p><p>(1) 当$\alpha+i\beta$不是特征值时，令$y_0=e^{\alpha x}[Q_n^{(1)}(x)cos\beta x+Q_n^{2}(x)sin\beta x$，其中n=max{m,s}，且$Q_n^{1}(x),Q_n^{2}(x)$为两个n次多项式</p><p>(2) 当$\alpha+i\beta$是特征值时，令$y_0=xe^{\alpha x}[Q_n^{(1)}(x)cos\beta x+Q_n^{2}(x)sin\beta x$，其中n=max{m,s}，且$Q_n^{1}(x),Q_n^{2}(x)$为两个n次多项式</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://ran-barry.github.io/2021/05/23/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="Ran-Barry"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hello"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2021/05/23/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6/" class="post-title-link" itemprop="url">高等数学-一元函数积分学</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-05-23 17:06:50" itemprop="dateCreated datePublished" datetime="2021-05-23T17:06:50+08:00">2021-05-23</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%95%B0%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">数学</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>5.3k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>5 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="不定积分"><a href="#不定积分" class="headerlink" title="不定积分"></a>不定积分</h2><h3 id="两个基本概念"><a href="#两个基本概念" class="headerlink" title="两个基本概念"></a>两个基本概念</h3><p><em>原函数</em><br>$F’(x)=f(x)$<br><em>不定积分</em><br>$\int f(x)dx=F(x)+C$</p><h3 id="原函数的存在性"><a href="#原函数的存在性" class="headerlink" title="原函数的存在性"></a>原函数的存在性</h3><p>(1) 若$f(x)$在区间$I$上连续，则$f(x)$在区间$I$上必有原函数<br>(2) 若$f(x)$在区间$I$上有第一类间断点，则$f(x)$在区间$I$上没有原函数<br>(3) 若$f(x)$在区间$I$上只有震荡间断点，则$f(x)$在区间$I$上可能存在原函数（专指不定积分）</p><h3 id="不定积分的性质"><a href="#不定积分的性质" class="headerlink" title="不定积分的性质"></a>不定积分的性质</h3><p><img src="/2021/05/23/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6/不定积分的性质.png" alt="photo"></p><h3 id="基本积分公式"><a href="#基本积分公式" class="headerlink" title="基本积分公式"></a>基本积分公式</h3><p><img src="/2021/05/23/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6/不定积分公式-1.png" alt="积分公式-1"><br><img src="/2021/05/23/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6/不定积分公式-2.png" alt="积分公式-2"></p><p>(23) $\int\tan^2xdx=\sec^2x-1+C$</p><p>(24) $\int\arcsin xdx=x\arcsin x+\sqrt{1-x^2}$</p><p>(25) $\int_{-\infty}^{+\infty}e^{-x^2}dx=\sqrt{\pi}$</p><p>(26) $\int_{-\infty}^{+\infty}e^{-\frac{x^2}{a}}dx=\sqrt{a}\int_{-\infty}^{+\infty}e^{-(\frac{x}{\sqrt{a}})^2}d\frac{x}{\sqrt{a}}=\sqrt{a\pi}$</p><h3 id="三种主要积分法"><a href="#三种主要积分法" class="headerlink" title="三种主要积分法"></a>三种主要积分法</h3><h4 id="第一类换元法-凑微分"><a href="#第一类换元法-凑微分" class="headerlink" title="第一类换元法(凑微分)"></a>第一类换元法(凑微分)</h4><p>若$\int f(u)du=F(u)+C, and\varphi(x)$可导，则</p><script type="math/tex;mode=display">\int f(\varphi(x))\varphi'(x)dx=\int f(\varphi(x))d\varphi(x)=F(\varphi(x))+C</script><h4 id="第二类换元法"><a href="#第二类换元法" class="headerlink" title="第二类换元法"></a>第二类换元法</h4><p>设函数$x=\varphi(t)$可导，且$\varphi’(t)\ne0$,又设$\int f(\varphi(t))\varphi’(t)dt=F(t)+C$，则$\int f(x)dx=\int f(\varphi(t))\varphi’(t)dt=F(\varphi^{-1}(x))+C$</p><p>三种常用的变量代换<br>(1) 被积函数中含有$\sqrt{a^2-x^2}$时，令$x=a\sin t,or x = a\cos t$<br>(2) 被积函数中含有$\sqrt{a^2-x^2}$时，令$x=a\tan t$<br>(3) 被积函数中含有$\sqrt{a^2-x^2}$时，令$x=a\sec t$</p><h4 id="分部积分法"><a href="#分部积分法" class="headerlink" title="分部积分法"></a>分部积分法</h4><p>设$u(x),v(x)$有连续一阶导数，则$\int udv=uv-\int vdu$</p><h3 id="三类常见可积函数积分"><a href="#三类常见可积函数积分" class="headerlink" title="三类常见可积函数积分"></a>三类常见可积函数积分</h3><h4 id="有理函数积分"><a href="#有理函数积分" class="headerlink" title="有理函数积分"></a>有理函数积分</h4><h4 id="三角有理式积分"><a href="#三角有理式积分" class="headerlink" title="三角有理式积分"></a>三角有理式积分</h4><script type="math/tex;mode=display">\int R(\sin x,\cos x)dx</script><p>(1) 一般方法（万能代换）<br>令$\tan\frac{x}{2}=t$<br>$\sin\alpha=\frac{2\tan\frac{\alpha}{2}}{1+\tan^2\frac{\alpha}{2}}、\cos\alpha=\frac{1-\tan^2\frac{\alpha}{2}}{1+\tan^2\frac{\alpha}{2}}、dx=\frac{2dt}{1+t^2}$</p><script type="math/tex;mode=display">\int R(\sin x,\cos x)dx=\int R(\frac{2t}{1+t^2},\frac{1-t^2}{1+t^2})\frac{2}{1+t^2}du</script><p>(2) 特殊方法（三角变形，换元，分部）</p><ol><li>若$R(-\sin x,\cos x)=-R(\sin x,\cos x)$，则令$u=\cos x$，即凑$d\cos x$</li><li>若$R(\sin x,-\cos x)=-R(\sin x,\cos x)$，则令$u=\sin x$，即凑$d\sin x$</li><li>若$R(-\sin x,-\cos x)=R(\sin x,\cos x)$，则令$u=\tan x$，即凑$d\tan x$</li></ol><h4 id="简单无理函数积分"><a href="#简单无理函数积分" class="headerlink" title="简单无理函数积分"></a>简单无理函数积分</h4><script type="math/tex;mode=display">\int R(x,\sqrt[n]{\frac{ax+b}{cx+d}})dx</script><p>令$\sqrt[n]{\frac{ax+b}{cx+d}}=t$，将其化为有理函数积分进行计算</p><h2 id="定积分"><a href="#定积分" class="headerlink" title="定积分"></a>定积分</h2><h3 id="定积分的概念"><a href="#定积分的概念" class="headerlink" title="定积分的概念"></a>定积分的概念</h3><h3 id="定积分的几何意义"><a href="#定积分的几何意义" class="headerlink" title="定积分的几何意义"></a>定积分的几何意义</h3><ol><li>设$\int_a^bf(x)dx$存在，若在[a,b]上$f(x)\ge0$，则$\int_a^bf(x)dx$的值等于以曲线$y=f(x)$，$y=a,x=b$及x轴所围成的曲边梯形的面积</li><li>若在[a,b]上$f(x)\le0$，则$\int_a^bf(x)dx$的值等于以曲线$y=f(x),x=a,x=b$及x轴所围成的曲边梯形面积的负值</li><li>若在[a,b]上$f(x)$的值有正也有负，则$\int_a^bf(x)dx$在几何上表示$y=f(x),x=a,x=b$及x轴所围成的x轴上方图形的面积减去下方图形的面积所得之差</li></ol><h3 id="可积性"><a href="#可积性" class="headerlink" title="可积性"></a>可积性</h3><p><strong>必要条件</strong><br>若$\int_a^bf(x)dx$存在，则$f(x)$在[a,b]上有界</p><p><strong>充分条件</strong><br>(1) 若$f(x)$在[a,b]上连续，则$\int_a^bf(x)dx$必定存在<br>(2) 若$f(x)$在[a,b]上有界，且只有有限个间断点，则$\int_a^bf(x)dx$必定存在<br>(3) 若$f(x)$在[a,b]上只有有限个第一类间断点，则$\int_a^bf(x)dx$必定存在</p><p>f(x)在[a,b]上可积，则$\int_a^xf(t)dt$连续</p><h3 id="定积分的计算"><a href="#定积分的计算" class="headerlink" title="定积分的计算"></a>定积分的计算</h3><p><strong>牛顿莱布尼茨公式</strong><br>如果函数$F(x)$是连续函数$f(x)$在区间[a,b]上的一个原函数，则$\int_a^bf(x)dx=F(b)-F(a)$</p><p><strong>换元积分法</strong><br>设f(x)在区间[a,b]上连续，函数$x=\varphi(t)满足以下条件$：<br>(1) $\varphi(\alpha)=a,\varphi(\beta)=b$</p><p>(2) $\varphi(t)$在$<a href="or[\beta,\alpha]">\alpha,\beta</a>$上具有连续导数，且其值域$R_\varphi=[a,b]$，则</p><script type="math/tex;mode=display">\int_a^bf(x)dx=\int_\alpha^\beta f(\varphi(t))\varphi'(t)dt</script><p><strong>分部积分法</strong><br>设函数$u(x)、v(x)$在[a,b]上有连续一阶导数，则$\int_a^budv=uv|\overset{b}{a}-\int_a^bvdu$</p><p><strong>利用奇偶性和周期性</strong><br>(1) 设$f(x)$为[-a,a]上的连续函数(a&gt;0)，则</p><script type="math/tex;mode=display">\int_{-a}^a=\begin{cases}
    0,&f(x)为奇函数\\
    2\int_a^bf(x)dx,&f(x)为偶函数
\end{cases}</script><p>(2) 设$f(x)$是以T为周期的连续函数，则对任给数a，总有$\int_a^{a+T}f(x)dx=\int_0^Tf(x)dx$</p><p><strong>利用公式</strong><br>(1)<script type="math/tex">\int_0^{\frac{\pi}{2}}\sin^nxdx=\int_0^\frac{\pi}{2}\cos^nxdx=\begin{cases}
    \frac{n-1}{n}\cdot\frac{n-3}{n-2}\cdot\dotsb\cdot\frac{1}{2}\cdot\frac{\pi}{2},&n为偶数\\
    \frac{n-1}{n}\cdot\frac{n-3}{n-2}\cdot\dotsb\cdot\frac{2}{3},&n为大于1的奇数
\end{cases}</script><br>(2) $\int_0^\pi xf(\sin x)dx=\frac{\pi}{2}\int_0^\pi f(\sin x)dx$(其中$f(x)$连续)</p><h3 id="变上限积分：-int-a-xf-t-dt"><a href="#变上限积分：-int-a-xf-t-dt" class="headerlink" title="变上限积分：$\int_a^xf(t)dt$"></a>变上限积分：$\int_a^xf(t)dt$</h3><p><strong>定理</strong><br>若$f(x)$在[a,b]上连续，则$\int_a^xf(t)dt$在[a,b]上可导且$(\int_a^xf(t)dt)’=f(x)$</p><p><em>有关$F(x)=\int_a^xf(t)dt$在一点处的可导性的结论</em><br>| $f(x)$ | $F(x)=\int_a^xf(t)dt$ |<br>| —- | —- |<br>|连续|可导，且$F’(x_0)=f(x_0)$|<br>|可去间断|可导，且$F’(x_0)=\lim\limits_{x\rightarrow x_0}f(x)$|<br>|跳跃间断|连续但不可导，且$F_+’(x_0)=f(x_0^+),F_-‘(x_0)=f(x_0^-)$|</p><p><strong>变上限求导的三个类型</strong><br>(1) $(\int_{\varphi(x)}^{\psi(x)}f(t)dt)’= f(\psi(x))\psi’(x)-f(\varphi(x))\varphi’(x)$</p><p>(2) $(\int_a^bf(x,t)dt)’=\int_a^b\frac{\vartheta f(x,t)}{\vartheta x}dt$</p><p><strong>连续性</strong><br>设$f(x)$在[a,b]上可积，则$\int_a^xf(x)dt$在[a,b]上连续</p><p><strong>奇偶性</strong><br>(1) 若$f(x)$为奇函数，则$\int_a^xf(t)dt$为偶函数</p><p>(2) 若$f(x)$为偶函数，则$\int_0^xf(t)dt$为奇函数</p><h3 id="定积分的性质"><a href="#定积分的性质" class="headerlink" title="定积分的性质"></a>定积分的性质</h3><p><strong>不等式</strong><br>(1) 若$f(x)\le g(x),x\in[a,b]$，则$\int_a^bf(x)dx\le\int_a^bg(x)dx$</p><p>(2) 若$f(x)$在[a,b]上连续，则$m(b-a)\le\int_a^bf(x)dx\le M(b-a)$，其中m,M分别为$f(x)$在[a,b]上的最小值与最大值</p><p>(3) $|\int_a^bf(x)dx|\le\int_a^b|f(x)|dx$</p><p><strong>积分中值定理</strong><br>(1) 若$f(x)$在[a,b]上连续，则$\int_a^bf(x)dx=f(\xi)(b-a),a&lt;\xi&lt;b$</p><p>(2) 若$f(x),g(x)$在[a,b]上连续，且$g(x)$不变号，则$\int_a^bf(x)g(x)dx=f(\xi)\int_a^bg(x)dx,a\le\xi\le b$</p><h3 id="积分不等式"><a href="#积分不等式" class="headerlink" title="积分不等式"></a>积分不等式</h3><p>柯西积分不等式：$(\int_a^bf(x)g(x)dx)^2\le\int_a^bf^2(x)dx\int_a^bg^2(x)dx$</p><h2 id="反常积分"><a href="#反常积分" class="headerlink" title="反常积分"></a>反常积分</h2><h3 id="无穷区间上的反常积分"><a href="#无穷区间上的反常积分" class="headerlink" title="无穷区间上的反常积分"></a>无穷区间上的反常积分</h3><p><strong>定义</strong> 设$f(x)$为$(-\infty,+\infty)$上的连续函数，如果反常积分$\int_{-\infty}^0f(x)dx$和$\int_0^{+\infty}f(x)dx$都收敛，则称反常积分$\int_{-\infty}^{+\infty}f(x)dx$收敛，且$\int_{-\infty}^{+\infty}f(x)dx=\int_{-\infty}^0f(x)dx+\int_0^{+\infty}f(x)dx$<br>如果$\int_{-\infty}^0f(x)dx$与$\int_0^{+\infty}f(x)dx$之一发散，则称$\int_{-\infty}^{+\infty}f(x)dx$发散</p><p><strong>定理1（比较判别法）</strong> 设$f(x),g(x)$在$[a,+\infty)$上连续，且$0\le f(x)\le g(x)$，且</p><p>(1) 当$\int_a^{+\infty}g(x)dx$收敛时，$\int_a^{+\infty}f(x)dx$收敛</p><p>(2) 当$\int_a^{+\infty}f(x)dx$发散时，$\int_a^{+\infty}g(x)dx$发散</p><p><strong>定理2（比较法的极限形式）</strong> 设$f(x),g(x)$在$[a,+\infty)$上非负连续，且$\lim\limits_{x\rightarrow+\infty}\frac{f(x)}{g(x)}=\lambda$(有限或无穷)，则</p><p>(1) 当$\lambda\ne0$时，$\int_a^{+\infty}f(x)dx$与$\int_a^{+\infty}g(x)dx$同敛散</p><p>(2) 当$\lambda=0$时，若$\int_a^{+\infty}g(x)dx$收敛，则$\int_a^{+\infty}f(x)dx$也收敛</p><p>(3) 当$\lambda=+\infty$时，若$\int_a^{+\infty}g(x)dx$发散，则$\int_a^{+\infty}f(x)dx$也发散</p><p>常用结论：<script type="math/tex">\int_a^{+\infty}\frac{1}{x^p}dx\begin{cases}
    p>1,&收敛 \\
    p\le1,&发散
\end{cases}\tag{a>0}</script></p><h3 id="无界函数的反常积分"><a href="#无界函数的反常积分" class="headerlink" title="无界函数的反常积分"></a>无界函数的反常积分</h3><p><strong>定理1（比较判别法</strong> 设$f(x),g(x)$在$(a,b]$上连续，且$0\le f(x)\le g(x),x=a$为$f(x)$和$g(x)$的瑕点，则<br>(1) 当$\int_a^bg(x)dx$收敛时，$\int_a^bf(x)dx$收敛<br>(2) 当$\int_a^bf(x)dx$发散时，$\int_a^bg(x)dx$发散</p><p><strong>定理2（比较法的极限形式</strong> 设$f(x),g(x)$在$(a,b]$上非负连续，且$\lim\limits_{x\rightarrow a^+}\frac{f(x)}{g(x)}=\lambda$(有限或无穷)，则<br>(1) 当$\lambda\ne0$时，$\int_a^{b}f(x)dx$与$\int_a^{b}g(x)dx$同敛散<br>(2) 当$\lambda=0$时，若$\int_a^bg(x)dx$收敛，则$\int_a^bf(x)dx$也收敛<br>(3) 当$\lambda=+\infty$时，若$\int_a^bg(x)dx$发散，则$\int_a^bf(x)dx$也发散</p><p>常用结论：</p><script type="math/tex;mode=display">\int_a^b\frac{1}{(x-a)^p}dx\begin{cases}
    p<1,&收敛 \\
    p\ge1,&发散
\end{cases}</script><script type="math/tex;mode=display">\int_a^b\frac{1}{(b-x)^p}dx\begin{cases}
    p<1,&收敛 \\
    p\ge1,&发散
\end{cases}</script><h2 id="定积分应用"><a href="#定积分应用" class="headerlink" title="定积分应用"></a>定积分应用</h2><h3 id="几何应用"><a href="#几何应用" class="headerlink" title="几何应用"></a>几何应用</h3><p><strong>平面图形的面积</strong><br>设有平面域D,则该平面域D的面积为$\iint_D1d\sigma$<br>(1) 若平面域D由曲线$y=f(x),y=g(x)(f(x)\ge g(x)),x=a,x=b(a&lt;b)$所围成，则<br><img src="/2021/05/23/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6/平面图形面积-1.png" alt="photo"></p><script type="math/tex;mode=display">S=\iint_D1d\sigma=\int_a^bdx\int_{g(x)}^{f(x)}1dy=\int_a^b[f(x)-g(x)]dx</script><p>(2) 若平面域D由曲线$r=r(\theta),\theta=\alpha,\theta=\beta(\alpha&lt;\beta)$所围成，则面积为<br><img src="/2021/05/23/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6/平面图形面积-2.png" alt="photo"></p><script type="math/tex;mode=display">S=\iint_D1d\sigma=\int_\alpha^\beta d\theta\int_0^{r(\theta)}rdr=\frac{1}{2}\int_\alpha^\beta r^2(\theta)d\theta</script><p><strong>空间体的体积</strong><br>(1) 旋转体的体积<br>平面域D绕直线L:ax+by+c=0(该直线不穿过区域D)旋转所得旋转体体积记为V<br><img src="/2021/05/23/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6/旋转体体积-1.png" alt="photo"></p><script type="math/tex;mode=display">r(x,y)=\frac{|ax+by+c|}{\sqrt{a^2+b^2}}</script><script type="math/tex;mode=display">dV=2\pi r(x,y)d\sigma</script><script type="math/tex;mode=display">V=2\pi\iint_Dr(x,y)d\sigma</script><p>特别的，若区域D由曲线$y=f(x)(f(x)\ge0$和直线$x=a,x=b(0\le a\le b)$及x轴所围成，则<br>(1) 区域D绕x轴旋转$(r(x,y)=y)$一周所得旋转体的体积为</p><script type="math/tex;mode=display">V_x=2\pi \iint_Dyd\sigma=2\pi\int_a^bdx\int_0^{f(x)}ydy=\pi\int_a^bf^2(x)dx</script><p>(2) 区域D绕y轴旋转$(r(x,y)=x)$一周所得旋转体的体积为</p><script type="math/tex;mode=display">V_y=2\pi\iint_Dxd\sigma=2\pi\int_a^bdx\int_0^{f(x)}xdy=2\pi\int_a^bxf(x)dx</script><p>(2) 横截面面积的体积<br><img src="/2021/05/23/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6/横截面面积的体积.png" alt="photo"></p><script type="math/tex;mode=display">V=\int_a^bS(x)dx</script><p><strong>曲线弧长</strong><br>(1) 设曲线段C由直角坐标方程$y=f(x)(a\le x\le b)$给出，其中$y(x)$在[a,b]上有一阶连续导数，则该曲线段的弧长为</p><script type="math/tex;mode=display">s=\int_a^b\sqrt{1+y'^2}dx</script><p>(2) 设曲线段C由参数方程$\begin{cases}<br>x=x(t),\\<br>y=y(t),<br>\end{cases}(a\le t\le \beta)$给出，其中$x(t),y(t)$在$[\alpha,\beta]$上有一阶连续导数，则该曲线段的弧长为</p><script type="math/tex;mode=display">s=\int_\alpha^\beta\sqrt{x'^2(t)+y'^2(t)}dt</script><p>(3) 设曲线段C由极坐标方程$r=r(\theta)(\alpha\le\theta\beta)$给出，其中$r(\theta)$在$[\alpha,\beta]$上有一阶连续导数，则该曲线段的弧长为</p><script type="math/tex;mode=display">s=\int_\alpha^\beta\sqrt{r^2(\theta)+r'^2(\theta)}d\theta</script><p>(4) 旋转体侧面积<br>曲线$y=f(x)(f(x)\ge0)$和直线$x=a,x=b(0\le a\le b)$及x轴所围成区域绕x轴旋转所得旋转体的侧面积是</p><script type="math/tex;mode=display">S=2\pi\int_a^bf(x)\sqrt{1+f'^2(x)}dx</script><h4 id="特殊图形"><a href="#特殊图形" class="headerlink" title="特殊图形"></a>特殊图形</h4><p><strong>星形线</strong><br><img src="/2021/05/23/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6/星形线.png" alt="星形线"><br>直角坐标方程：$x^{\frac{2}{3}}+y^{\frac{2}{3}}=a^{\frac{2}{3}}$<br>极坐标方程：$x=a\cos^3t,y=a\sin^3t$<br>围成面积$A=4\int_0^aydx$<br>弧长$L=4\int_0^a\sqrt{1+y’^2}dx$<br>绕x轴体积$V=2\pi\int_a^a y^2dx$<br>旋转体横截面积$2*2\pi\int_0^ay\sqrt{1+y’^2}dx$</p><p><strong>摆线</strong><br><img src="/2021/05/23/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6/摆线.png" alt="摆线"><br>极坐标方程：$x=a(t-\sin t),y=a(1-\cos t)$</p><p><strong>心形线</strong><br><img src="/2021/05/23/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6/心形线.png" alt="心形线"><br>极坐标方程：$r=a(1+\cos\theta)$</p><p><strong>双纽线</strong><br><img src="/2021/05/23/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6/双纽线.png" alt="双纽线"><br>直角坐标方程：$(x^2+y^2)^2=a^2(x^2-y^2)$<br>极坐标方程：$r^2=a^2\cos2\theta$<br>旋转体侧面积：$2\int_0^\frac{\pi}{4}2\pi*r\sin\theta\sqrt{r^2+r’^2(\theta)}d\theta$</p><h3 id="物理应用"><a href="#物理应用" class="headerlink" title="物理应用"></a>物理应用</h3><ol><li>压力<ol><li>水的压力F=水的压强P x 装水的容器的底面积S（F=pghS)</li></ol></li><li>变力做功</li><li>引力</li></ol><p>质心计算公式$r_\sigma=\frac{\sum_im_ir_i}{M}$和$r_\sigma=\frac{\int^b_ax\rho(x)dx}{\int^b_a\rho(x)dx}$</p></div><footer class="post-footer"><div class="post-eof"></div></footer></article><nav class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a></nav></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Ran-Barry</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">56</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">8</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">18</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-cn" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Ran-Barry</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span class="post-meta-item-text">站点总字数：</span> <span title="站点总字数">203k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span class="post-meta-item-text">站点阅读时长 &asymp;</span> <span title="站点阅读时长">3:04</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script>if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{scale:1,hHeadPos:.5,vHeadPos:.618,jsonPath:"/live2dw/assets/haruto.model.json"},display:{superSample:2,width:150,height:300,position:"left",hOffset:0,vOffset:-10},mobile:{show:!1,scale:.05},react:{opacityDefault:.7,opacityOnHover:.2}})</script></body></html>